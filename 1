? 1
? 2
? 3
? TODO.modDinoex
? config.temp
? config.temp.c
? config.temp.p
? log
Index: Configure
===================================================================
RCS file: /usr/home/public/iroffer/Configure,v
retrieving revision 1.220
retrieving revision 1.228
diff -u -r1.220 -r1.228
--- Configure	19 Feb 2011 19:39:47 -0000	1.220
+++ Configure	30 Jul 2011 20:08:25 -0000	1.228
@@ -1,10 +1,10 @@
 #!/bin/sh
 
 #
-# $Id: Configure,v 1.220 2011/02/19 19:39:47 cvs Exp $
+# $Id: Configure,v 1.228 2011/07/30 20:08:25 cvs Exp $
 #
 
-VERSION="3.26"
+VERSION="3.27"
 RELEASE=1
 
 if [ $RELEASE -eq 1 ]; then
@@ -691,7 +691,6 @@
 -Wformat-nonliteral
 -Wformat=2
 -Wfloat-equal
--Wlarger-than-20000
 -Wpacked
 -Wpadded
 -Wswitch-default
@@ -706,7 +705,6 @@
 -Wformat-nonliteral
 -Wformat=2
 -Wfloat-equal
--Wlarger-than-20000
 -Wpacked
 -Wpadded
 -Wswitch-default
@@ -770,17 +768,19 @@
 fi
 
 ${msg} -n "${irt_checkfor} make... "
-if [ -f "`type make | awk '{print $NF}'`" ]; then
+makebin="`type make | awk '{print $NF}'`"
+gmakebin="`type gmake | awk '{print $NF}'`"
+if [ -f "${makebin}" ]; then
  maketype="make"
- if [ -x "`type $maketype | awk '{print $NF}'`" ]; then
+ if [ -x "${makebin}" ]; then
   ${msg} "${irt_found} $maketype"
  else
   ${msg} "${irt_found} $maketype. ${irt_error} ${irt_noexec} $maketype"
   waserror
  fi
-elif [ -f "`type gmake | awk '{print $NF}'`" ]; then
+elif [ -f "${gmakebin}" ]; then
  maketype="gmake"
- if [ -x "`type $maketype | awk '{print $NF}'`" ]; then
+ if [ -x "${gmakebin}" ]; then
   ${msg} "${irt_found} $maketype"
  else
   ${msg} "${irt_found} $maketype. ${irt_error} ${irt_noexec} $maketype"
@@ -817,15 +817,26 @@
  fi
 fi
 
-${msg} -n "${irt_seeingif} $cctype ${irt_works}... "
-echo "
-#include <stdlib.h>
+main1="
 int
 #ifdef __GNUC__
+#if !defined(__STDC_VERSION__) || __STDC_VERSION__ != 199901L
 __attribute__ ((noreturn))
 #endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+#endif
+main (int argc, char **argv)
+{
+"
+
+main2=" exit(0);
+}"
+
+main0="${main1}${main2}"
+
+${msg} -n "${irt_seeingif} $cctype ${irt_works}... "
+echo "
+#include <stdlib.h>
+${main0}" > config.temp.c
 if $cctype -o config.temp $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_yes}"
 else
@@ -836,12 +847,7 @@
 ${msg} -n "${irt_seeingif} $cctype ${irt_accepts} '-Wall'... "
 echo "
 #include <stdlib.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+${main0}" > config.temp.c
 if $cctype -o config.temp -Wall $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_yes}"
  WARNS="-Wall $WARNS"
@@ -852,12 +858,7 @@
 ${msg} -n "${irt_seeingif} $cctype ${irt_accepts} '-Werror'... "
 echo "
 #include <stdlib.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+${main0}" > config.temp.c
 if $cctype -o config.temp -Werror $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_yes}"
  WERROR="-Werror"
@@ -870,15 +871,9 @@
 echo "
 #include <stdlib.h>
 #include <stdio.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+${main1}
  printf(\"%d\", (int)sizeof( C_IR_INT16 ));
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp -DC_IR_INT16="short" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "2" ]; then
  echo "short"
  echo "typedef short ir_int16;" >> src/iroffer_config.h
@@ -897,15 +892,9 @@
 echo "
 #include <stdlib.h>
 #include <stdio.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+${main1}
  printf(\"%d\", (int)sizeof( C_IR_INT32 ));
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp -DC_IR_INT32="int" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "4" ]; then
  echo "int"
  echo "typedef int ir_int32;" >> src/iroffer_config.h
@@ -931,15 +920,9 @@
 echo "
 #include <stdlib.h>
 #include <stdio.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+${main1}
  printf(\"%d\", (int)sizeof( C_IR_INT64 ));
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp -DC_IR_INT64="long" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "8" ]; then
  echo "long"
  echo "typedef long ir_int64;" >> src/iroffer_config.h
@@ -967,15 +950,9 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <sys/socket.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+${main1}
  printf(\"%d\", (int)AF_INET6);
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
  if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_yes}"
  else
@@ -985,19 +962,20 @@
  fi
 fi
 
-${msg} -n "${irt_seeingif} ${irt_compiling} ${irt_works}... "
-echo "
+irheaders="
 #include \"src/iroffer_config.h\"
 #include \"src/iroffer_defines.h\"
 #include \"src/iroffer_headers.h\"
 #include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
-if $cctype -o config.temp -DSIGNEDSOCK=signed $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
+"
+
+irmain1="${irheaders}${main1}"
+
+irmain0="${irmain1}${main2}"
+
+${msg} -n "${irt_seeingif} ${irt_compiling} ${irt_works}... "
+echo "${irmain0}" > config.temp.c
+if $cctype -o config.temp $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_yes}"
 else
  ${msg} " ${irt_error} ${irt_nocompiling}."
@@ -1006,14 +984,10 @@
 
 
 ${msg} -n "${irt_seeinghow} ${irt_large} FD_SETSIZE ${irt_is}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
+echo "${irheaders}
 FD_SETSIZE
 " > config.temp.c
-if $cctype -o config.temp.p -E $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
+if $cctype -o config.temp.p -E $WARNS $WERROR $CFLAGS config.temp.c; then
  setsize=`tail -2 config.temp.p |grep -v "config.temp"`
  setsize="${setsize%U}"
  echo -n " $setsize"
@@ -1030,20 +1004,9 @@
 fi
 
 ${msg} -n "${irt_endianness}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+echo "${irmain1}
  printf(\"%s\", (100 == ntohl(100)) ? \"big\" : \"little\");
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "big" ]; then
  ${msg} "${irt_endianbig}"
  echo "#define IR_ENDIAN_BIG" >> src/iroffer_config.h
@@ -1057,24 +1020,13 @@
 
 
 ${msg} -n "${irt_seeingif} ${irt_largefile} ${irt_works}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+echo "${irmain1}
  int fd;
  int array[ ((int)sizeof(off_t)) - 7 ];
  fd=open(\"foo\", O_RDWR | O_CREAT | ADDED_OPEN_FLAGS, CREAT_PERMISSIONS);
  array[0] = array[0];
  close(fd);
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_yes}"
  echo "#define _FILE_OFFSET_BITS 64" >> src/iroffer_config.h
@@ -1084,21 +1036,10 @@
 fi
 
 ${msg} -n "${irt_signedness} 'addrlen'... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+echo "${irmain1}
  int a=1; struct sockaddr_in b; SIGNEDSOCK int c;
  getsockname(a,(struct sockaddr *)&b,&c);
- exit(0);
- }
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp -DSIGNEDSOCK=signed $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "signed"
  echo "#define SIGNEDSOCK signed" >> src/iroffer_config.h
@@ -1113,32 +1054,20 @@
 
 
 ${msg} -n "${irt_seeinghow} ${irt_display_int64} printf... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-  {
-    ir_int64 a = 1000000000;
-    a = a*10;
-    printf(\"%\" LLPRINTFMT \"i\",a);
-    exit(0);
-  }
-" > config.temp.c
+echo "${irmain1}
+ ir_int64 a = 1000000000;
+ a = a*10;
+ printf(\"%\" LLPRINTFMT \"i\",a);
+${main2}" > config.temp.c
 if $cctype -o config.temp -DLLPRINTFMT=\"L\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
  echo "L"
  echo "#define LLPRINTFMT \"L\"" >> src/iroffer_config.h
-elif $cctype -o config.temp -DLLPRINTFMT=\"ll\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
- echo "ll"
- echo "#define LLPRINTFMT \"ll\"" >> src/iroffer_config.h
 elif $cctype -o config.temp -DLLPRINTFMT=\"l\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
  echo "l"
  echo "#define LLPRINTFMT \"l\"" >> src/iroffer_config.h
+elif $cctype -o config.temp -DLLPRINTFMT=\"ll\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
+ echo "ll"
+ echo "#define LLPRINTFMT \"ll\"" >> src/iroffer_config.h
 else
  ${msg} "${irt_unknown}. ${irt_error} ${irt_neither1} 'll', 'l', ${irt_neither2} 'L' ${irt_neither3}."
  echo "#define LLPRINTFMT \"L\"" >> src/iroffer_config.h
@@ -1147,32 +1076,20 @@
 
 
 ${msg} -n "${irt_seeinghow} ${irt_display_time} printf... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-  {
-    time_t a = 1000000000;
-    a = a*10;
-    printf(\"%\" TTPRINTFMT, a);
-    exit(0);
-  }
-" > config.temp.c
+echo "${irmain1}
+ time_t a = 1000000000;
+ a = a*10;
+ printf(\"%\" TTPRINTFMT, a);
+${main2}" > config.temp.c
 if $cctype -o config.temp -DTTPRINTFMT=\"Li\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
  echo "Li"
  echo "#define TTPRINTFMT \"Li\"" >> src/iroffer_config.h
-elif $cctype -o config.temp -DTTPRINTFMT=\"lli\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
- echo "lli"
- echo "#define TTPRINTFMT \"lli\"" >> src/iroffer_config.h
 elif $cctype -o config.temp -DTTPRINTFMT=\"li\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" -o "`./config.temp`" = "1410065408" ]; then
  echo "li"
  echo "#define TTPRINTFMT \"li\"" >> src/iroffer_config.h
+elif $cctype -o config.temp -DTTPRINTFMT=\"lli\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" ]; then
+ echo "lli"
+ echo "#define TTPRINTFMT \"lli\"" >> src/iroffer_config.h
 elif $cctype -o config.temp -DTTPRINTFMT=\"i\" $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && [ "`./config.temp`" = "10000000000" -o "`./config.temp`" = "1410065408" ]; then
  echo "i"
  echo "#define TTPRINTFMT \"i\"" >> src/iroffer_config.h
@@ -1184,17 +1101,9 @@
 
 
 ${msg} -n "${irt_checkfor} snprintf()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {char *s=0; snprintf(s,10,\"blah\"); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ char *s=0; snprintf(s,10,\"blah\");
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_found}"
 else
@@ -1203,17 +1112,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} strcasecmp()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {(void)strcasecmp(\"blah\",\"blah\"); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ (void)strcasecmp(\"blah\",\"blah\");
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_found}"
 else
@@ -1222,17 +1123,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} strcasestr()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {(void)strcasestr(\"blah\",\"blah\"); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ (void)strcasestr(\"blah\",\"blah\");
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_found}"
 else
@@ -1242,17 +1135,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} strsignal()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {strsignal(1); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ strsignal(1);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_found}"
 else
@@ -1261,17 +1146,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/mman.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_MMAN_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_MMAN_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1280,17 +1155,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/sendfile.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_SENDFILE_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_SENDFILE_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1299,17 +1164,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/vfs.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_VFS_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_VFS_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1318,17 +1173,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/statfs.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_STATFS_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_STATFS_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1337,17 +1182,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/param.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_PARAM_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_PARAM_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1356,17 +1191,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/mount.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_MOUNT_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_MOUNT_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1375,17 +1200,7 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'sys/statvfs.h' ${irt_exists}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp.o -c -DHAS_SYS_STATVFS_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  echo "#define HAS_SYS_STATVFS_H" >> src/iroffer_config.h
  ${msg} "${irt_found}"
@@ -1394,17 +1209,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} statvfs()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {struct statvfs stf; statvfs(\"\",&stf); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ struct statvfs stf; statvfs(\"\",&stf);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_found}"
 else
@@ -1413,17 +1220,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} statfs()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {struct statfs stf; statfs(\"\",&stf); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ struct statfs stf; statfs(\"\",&stf);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_found}"
 else
@@ -1432,17 +1231,9 @@
 fi
 
 ${msg} -n "${irt_seeingif} 'crypt.h' ${irt_isneeded}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {crypt(\"aaaaaaaa\",\"aa\"); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ crypt(\"aaaaaaaa\",\"aa\");
+${main2}" > config.temp.c
 if $cctype -o config.temp.o -c $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
  ${msg} "${irt_notneeded}"
 elif $cctype -o config.temp.o -c -DHAS_CRYPT_H $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
@@ -1474,37 +1265,24 @@
 fi
 
 ${msg} -n "${irt_seeingif} crypt() ${irt_works} ${irt_asexpected}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-  {
-    char *pwout;
-    pwout = crypt(\"testtest\",\"LH\");
-    if (pwout && !strcmp(\"LHD/pLKwfn0.k\", pwout))
-      {
-        fputs(\"result: <plain> \", stderr);
-        exit(0);
-      }
-    if (pwout && !strcmp(\"\$1\$LH\$l9z.KKYlyrg6tmiWYw85h0\", pwout))
-      {
-        fputs(\"result: <md5> \", stderr);
-        exit(0);
-      }
-    if (pwout && !strcmp(\"\$2a\$04\$L.....................6oC9YEWGQG17v9bdZ7bATu6dyyWPzMy\", pwout))
-      {
-        fputs(\"result: <blf> \", stderr);
-        exit(0);
-      }
-    fprintf(stderr, \"result: <unknown> hash = %s \", pwout);
-    exit(1);
-  }
+echo "${irmain1}
+ char *pwout;
+ pwout = crypt(\"testtest\",\"LH\");
+ if (pwout && !strcmp(\"LHD/pLKwfn0.k\", pwout)) {
+   fputs(\"result: <plain> \", stderr);
+   exit(0);
+ }
+ if (pwout && !strcmp(\"\$1\$LH\$l9z.KKYlyrg6tmiWYw85h0\", pwout)) {
+   fputs(\"result: <md5> \", stderr);
+   exit(0);
+ }
+ if (pwout && !strcmp(\"\$2a\$04\$L.....................6oC9YEWGQG17v9bdZ7bATu6dyyWPzMy\", pwout)) {
+   fputs(\"result: <blf> \", stderr);
+   exit(0);
+ }
+ fprintf(stderr, \"result: <unknown> hash = %s \", pwout);
+ exit(1);
+}
 " > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS && ./config.temp; then
  ${msg} "${irt_yes}"
@@ -1515,17 +1293,9 @@
 
 
 ${msg} -n "${irt_checkfor} chroot()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {chroot(\".\"); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ chroot(\".\");
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1534,17 +1304,7 @@
 fi
 
 ${msg} -n "${irt_seeingif_lib} NSS ${irt_lib_exists} (${irt_for} chroot)... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+echo "${irmain0}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS -lnss_files -lnss_dns $libs $LIBS; then
 NSSLIBS="-lnss_files -lnss_dns"
 ${msg} "${irt_found}"
@@ -1554,17 +1314,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} setuid()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {setuid(0); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ setuid(0);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1573,17 +1325,9 @@
 fi
 
 ${msg} -n "${irt_checkfor} getgrouplist()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {getgrouplist (NULL, 0, NULL, NULL); exit(0);}
-" > config.temp.c
+echo "${irmain1}
+ getgrouplist (NULL, 0, NULL, NULL);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1593,26 +1337,15 @@
 
 if [ "x$ostype" = "xLinux" ]; then
 ${msg} -n "${irt_checkfor} Linux-style sendfile()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-{
-  int     out_fd = 0;
-  int     in_fd = 0;
-  off_t   offset = 0;
-  size_t  count = 0;
-  ssize_t ret_val;
-  ret_val = sendfile(out_fd, in_fd, &offset, count);
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ int     out_fd = 0;
+ int     in_fd = 0;
+ off_t   offset = 0;
+ size_t  count = 0;
+ ssize_t ret_val;
+ ret_val = sendfile(out_fd, in_fd, &offset, count);
+ ret_val++;
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 echo "#define HAVE_LINUX_SENDFILE" >> src/iroffer_config.h
 ${msg} "${irt_found}"
@@ -1623,30 +1356,18 @@
 
 if [ "x$ostype" = "xFreeBSD" ]; then
 ${msg} -n "${irt_checkfor} FreeBSD-style sendfile()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-{
-  int     in_fd = 0;
-  int     out_fd = 0;
-  off_t   offset = 0;
-  off_t   offset2 = 0;
-  size_t  count = 0;
-  struct sf_hdtr hdr = {};
-  int ret_val;
-  ret_val = sendfile(in_fd, out_fd, offset, count,
-                     &hdr, &offset2, 0);
-  ret_val++;
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ int     in_fd = 0;
+ int     out_fd = 0;
+ off_t   offset = 0;
+ off_t   offset2 = 0;
+ size_t  count = 0;
+ struct sf_hdtr hdr = {};
+ int ret_val;
+ ret_val = sendfile(in_fd, out_fd, offset, count,
+                    &hdr, &offset2, 0);
+ ret_val++;
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 echo "#define HAVE_FREEBSD_SENDFILE" >> src/iroffer_config.h
 ${msg} "${irt_found}"
@@ -1656,22 +1377,10 @@
 fi
 
 ${msg} -n "${irt_checkfor} mmap()/munmap()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-{
-  mmap(NULL,0,PROT_READ,MAP_SHARED,0,0);
-  munmap(NULL,0);
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ mmap(NULL,0,PROT_READ,MAP_SHARED,0,0);
+ munmap(NULL,0);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 echo "#define HAVE_MMAP" >> src/iroffer_config.h
 ${msg} "${irt_found}"
@@ -1681,41 +1390,17 @@
 
 
 ${msg} -n "${irt_checkfor} ${irt_fdlimit}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-{
-  struct rlimit rlim;
-  getrlimit(RLIMIT_NOFILE, &rlim);
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ struct rlimit rlim;
+ getrlimit(RLIMIT_NOFILE, &rlim);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 echo "RLIMIT_NOFILE"
 else
-${msg} "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-{
-  struct rlimit rlim;
-  getrlimit(RLIMIT_OFILE, &rlim);
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ struct rlimit rlim;
+ getrlimit(RLIMIT_OFILE, &rlim);
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 echo "RLIMIT_OFILE"
 echo "#define USE_OFILE" >> src/iroffer_config.h
@@ -1726,26 +1411,14 @@
 fi
 
 ${msg} -n "${irt_checkfor} siginfo_t/sa_sigaction... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv)
-{
-  siginfo_t si;
-  struct sigaction sa;
-  sa.sa_sigaction = NULL;
-  si.si_code = 0;
-  bzero(&si, sizeof(si));
-  bzero(&sa, sizeof(sa));
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ siginfo_t si;
+ struct sigaction sa;
+ sa.sa_sigaction = NULL;
+ si.si_code = 0;
+ bzero(&si, sizeof(si));
+ bzero(&sa, sizeof(sa));
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1754,42 +1427,31 @@
 fi
 
 ${msg} -n "${irt_checkfor} 'si_code' ${irt_values}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
-  siginfo_t si;
-  si.si_code = BUS_ADRALN;
-  si.si_code = BUS_ADRERR;
-  si.si_code = BUS_OBJERR;
-  si.si_code = ILL_ILLOPC;
-  si.si_code = ILL_ILLOPN;
-  si.si_code = ILL_ILLADR;
-  si.si_code = ILL_ILLTRP;
-  si.si_code = ILL_PRVOPC;
-  si.si_code = ILL_PRVREG;
-  si.si_code = ILL_COPROC;
-  si.si_code = ILL_BADSTK;
-  si.si_code = FPE_INTDIV;
-  si.si_code = FPE_INTOVF;
-  si.si_code = FPE_FLTDIV;
-  si.si_code = FPE_FLTOVF;
-  si.si_code = FPE_FLTUND;
-  si.si_code = FPE_FLTRES;
-  si.si_code = FPE_FLTINV;
-  si.si_code = FPE_FLTSUB;
-  si.si_code = SEGV_MAPERR;
-  si.si_code = SEGV_ACCERR;
-  bzero(&si, sizeof(si));
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ siginfo_t si;
+ si.si_code = BUS_ADRALN;
+ si.si_code = BUS_ADRERR;
+ si.si_code = BUS_OBJERR;
+ si.si_code = ILL_ILLOPC;
+ si.si_code = ILL_ILLOPN;
+ si.si_code = ILL_ILLADR;
+ si.si_code = ILL_ILLTRP;
+ si.si_code = ILL_PRVOPC;
+ si.si_code = ILL_PRVREG;
+ si.si_code = ILL_COPROC;
+ si.si_code = ILL_BADSTK;
+ si.si_code = FPE_INTDIV;
+ si.si_code = FPE_INTOVF;
+ si.si_code = FPE_FLTDIV;
+ si.si_code = FPE_FLTOVF;
+ si.si_code = FPE_FLTUND;
+ si.si_code = FPE_FLTRES;
+ si.si_code = FPE_FLTINV;
+ si.si_code = FPE_FLTSUB;
+ si.si_code = SEGV_MAPERR;
+ si.si_code = SEGV_ACCERR;
+ bzero(&si, sizeof(si));
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1798,27 +1460,15 @@
 fi
 
 ${msg} -n "${irt_checkfor} wait() status ${irt_values}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
-  int status = 0;
-  if (WIFEXITED(status) ||
-      WIFSIGNALED(status) ||
-      WEXITSTATUS(status) ||
-      WTERMSIG(status))
-    {
-      status++;
-    }
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ int status = 0;
+ if (WIFEXITED(status) ||
+     WIFSIGNALED(status) ||
+     WEXITSTATUS(status) ||
+     WTERMSIG(status)) {
+  status++;
+ }
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1828,22 +1478,11 @@
 
 
 ${msg} -n "${irt_seeingif} ${irt_tos}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
-  int fd = 0;
-  int tempc = 0x8; /* IPTOS_THROUGHPUT */
-  setsockopt(fd, IPPROTO_IP, IP_TOS, &tempc, sizeof(int));
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ int fd = 0;
+ int tempc = 0x8; /* IPTOS_THROUGHPUT */
+ setsockopt(fd, IPPROTO_IP, IP_TOS, &tempc, sizeof(int));
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_yes}"
 else
@@ -1852,27 +1491,16 @@
 fi
 
 ${msg} -n "${irt_checkfor} getaddrinfo()... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
-  struct addrinfo hints, *res0;
-  int error;
-
-  memset(&hints, 0, sizeof(hints));
-  hints.ai_family = PF_UNSPEC;
-  hints.ai_socktype = SOCK_STREAM;
-  error = getaddrinfo(\"www.kame.net\", \"http\", &hints, &res0);
-  error ++;
-  exit(0);
-}
-" > config.temp.c
+echo "${irmain1}
+ struct addrinfo hints, *res0;
+ int error;
+
+ memset(&hints, 0, sizeof(hints));
+ hints.ai_family = PF_UNSPEC;
+ hints.ai_socktype = SOCK_STREAM;
+ error = getaddrinfo(\"www.kame.net\", \"http\", &hints, &res0);
+ error ++;
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 else
@@ -1881,31 +1509,21 @@
 fi
 
 ${msg} -n "${irt_checkfor} gethostbyname() error ${irt_values}... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
-  int i;
-  switch (h_errno)
-    {
-     case HOST_NOT_FOUND:
-     case NO_ADDRESS:
+echo "${irmain1}
+ int i;
+ switch (h_errno) {
+ case HOST_NOT_FOUND:
+ case NO_ADDRESS:
 #if NO_ADDRESS != NO_DATA
-     case NO_DATA:
+ case NO_DATA:
 #endif
-     case NO_RECOVERY:
-     case TRY_AGAIN:
-       i = 1;
-     default:
-       i = 0;
-    }
-  exit(i);
+ case NO_RECOVERY:
+ case TRY_AGAIN:
+  i = 1;
+ default:
+  i = 0;
+ }
+ exit(i);
 }
 " > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
@@ -1916,21 +1534,11 @@
 fi
 
 ${msg} -n "${irt_checkfor} res_init() ... "
-echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
+echo "${irheaders}
 #include <resolv.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {
+${main1}
   res_init();
-  exit(0);
-}
-" > config.temp.c
+${main2}" > config.temp.c
 if $cctype -o config.temp $WARNS $WERROR $CFLAGS config.temp.c $LDFLAGS $libs $LIBS; then
 ${msg} "${irt_found}"
 echo "#define WITH_RESINIT" >> src/iroffer_config.h
@@ -1940,18 +1548,11 @@
 
 if $OPT_GEOIP; then
  ${msg} -n "${irt_seeingif_lib} GeoIP ${irt_lib_exists}... "
- echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
+ echo "${irheaders}
 #include <GeoIP.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) { GeoIP_country_code_by_addr(NULL, NULL);; exit(0);}
-" > config.temp.c
+${main1}
+ GeoIP_country_code_by_addr(NULL, NULL);
+${main2}" > config.temp.c
  if $cctype -o config.temp -DUSE_GEOIP $WARNS $WERROR $CFLAGS "-I${LOCALBASE}/include" config.temp.c "-L${LOCALBASE}/lib" -lGeoIP $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_found}"
   echo "#define USE_GEOIP" >> src/iroffer_config.h
@@ -1960,18 +1561,11 @@
   GEOINC="-I${LOCALBASE}/include"
   GEOLDF="-L${LOCALBASE}/lib"
   ${msg} -n "${irt_seeingif} ${irt_geoip6}... "
-  echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
+  echo "${irheaders}
 #include <GeoIP.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) { struct in6_addr remoteip; GeoIP_country_code_by_ipnum_v6(NULL, remoteip); exit(0);}
-" > config.temp.c
+${main1}
+ struct in6_addr remoteip; GeoIP_country_code_by_ipnum_v6(NULL, remoteip);
+${main2}" > config.temp.c
   if $cctype -o config.temp -DUSE_GEOIP6 $WARNS $WERROR $CFLAGS ${GEOINC} config.temp.c ${GEOLDF} ${GEOLIB} $LDFLAGS $libs $LIBS; then
    FEATURES="${FEATURES}6"
    ${msg} "${irt_found}"
@@ -1988,20 +1582,13 @@
 
 if $OPT_UPNP; then
  ${msg} -n "${irt_seeingif_lib} miniupnpc ${irt_lib_exists}... "
- echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
+ echo "${irheaders}
 #include <miniupnpc/miniwget.h>
 #include <miniupnpc/miniupnpc.h>
 #include <miniupnpc/upnpcommands.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) { upnpDiscover(2000, NULL, NULL, 0); exit(0);}
-" > config.temp.c
+${main1}
+ upnpDiscover(2000, NULL, NULL, 0);
+${main2}" > config.temp.c
  if $cctype -o config.temp -DUSE_UPNP $WARNS $WERROR $CFLAGS "-I${LOCALBASE}/include" config.temp.c "-L${LOCALBASE}/lib" -lminiupnpc $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_found}"
   echo "#define USE_UPNP" >> src/iroffer_config.h
@@ -2017,18 +1604,11 @@
 
 if $OPT_CURL; then
  ${msg} -n "${irt_seeingif_lib} libcurl ${irt_lib_exists} (${irt_for} FETCH-Command)... "
- echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
+ echo "${irheaders}
 #include <curl/curl.h>
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {curl_global_cleanup(); exit(0);}
-" > config.temp.c
+${main1}
+ curl_global_cleanup();
+${main2}" > config.temp.c
  if $cctype -o config.temp -DUSE_CURL $WARNS $CFLAGS `curl-config  --cflags` config.temp.c "-L${LOCALBASE}/lib" `curl-config  --libs` $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_found}"
   echo "#define USE_CURL" >> src/iroffer_config.h
@@ -2053,17 +1633,7 @@
 
 if $OPT_SSL; then
  ${msg} -n "${irt_seeingif_lib} OpenSSL ${irt_lib_exists}... "
- echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+ echo "${irmain0}" > config.temp.c
  if $cctype -o config.temp -DUSE_OPENSSL $WARNS $CFLAGS "-I${LOCALBASE}/include" config.temp.c "-L${LOCALBASE}/lib" -lssl -lcrypto $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_found}"
   ${msg} "${irt_start} OpenSSL."
@@ -2085,17 +1655,7 @@
 
 if $OPT_TLS; then
  ${msg} -n "${irt_seeingif_lib} GNU TLS ${irt_lib_exists}... "
- echo "
-#include \"src/iroffer_config.h\"
-#include \"src/iroffer_defines.h\"
-#include \"src/iroffer_headers.h\"
-#include \"src/iroffer_globals.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) {exit(0);}
-" > config.temp.c
+ echo "${irmain0}" > config.temp.c
  if $cctype -o config.temp -DUSE_GNUTLS $WARNS $CFLAGS "-I${LOCALBASE}/include" config.temp.c "-L${LOCALBASE}/lib" -lgnutls $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_found}"
   echo "#define USE_GNUTLS" >> src/iroffer_config.h
@@ -2133,12 +1693,9 @@
  ${msg} -n "${irt_seeingif_lib} libruby ${irt_lib_exists} (${irt_for} RUBY-Scripts)... "
  echo "
 #include \"ruby.h\"
-int
-#ifdef __GNUC__
-__attribute__ ((noreturn))
-#endif
-main (int argc, char **argv) { ruby_init(); ruby_finalize(); exit(0);}
-" > config.temp.c
+${main1}
+ ruby_init(); ruby_finalize();
+${main2}" > config.temp.c
  if $cctype -o config.temp -DUSE_RUBY $WARNS $CFLAGS ${incruby} config.temp.c ${libruby} $LDFLAGS $libs $LIBS; then
   ${msg} "${irt_found}"
   ${msg} "${irt_start} Ruby."
@@ -2288,10 +1845,26 @@
 clobber: clean
 	rm -rf src.* *.sed
 
+'
+ for html in doc/INSTALL-*.html
+ do
+    txt="${html%.html}.txt"
+    echo "${txt}: ${html}
+	lynx -dump ${html} > ${txt}
+"
+ done
+ echo '
+
 man:
 	groff -t -e -mandoc -Tascii iroffer.1
 
-doc:	doc/iroffer.1.txt doc/iroffer.1.ps doc/iroffer.1.html
+doc:	doc/iroffer.1.txt doc/iroffer.1.ps doc/iroffer.1.html \'
+ for html in doc/INSTALL-*.html
+ do
+    txt="${html%.html}.txt"
+    echo "	${txt} \\"
+ done
+ echo '
 
 doc/iroffer.1.html: iroffer.1
 	groff -t -e -mandoc -Thtml iroffer.1 > doc/iroffer.1.html
Index: LICENSE
===================================================================
RCS file: /usr/home/public/iroffer/LICENSE,v
retrieving revision 1.11
retrieving revision 1.12
diff -u -r1.11 -r1.12
--- LICENSE	5 Jan 2011 17:41:36 -0000	1.11
+++ LICENSE	12 Jun 2011 07:35:28 -0000	1.12
@@ -8,7 +8,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-src/iroffer*.[ch], README-iroffer.txt, dynip.sh, iroffer.cron
+src/iroffer*.[ch], dynip.sh, iroffer.cron
 are copyrighted by David Johnson (PMG) under GPL2 below.
 
 Configure, sample.config are written by
Index: LIESMICH.modDinoex
===================================================================
RCS file: /usr/home/public/iroffer/LIESMICH.modDinoex,v
retrieving revision 1.575
retrieving revision 1.606
diff -u -r1.575 -r1.606
--- LIESMICH.modDinoex	10 Feb 2011 18:31:33 -0000	1.575
+++ LIESMICH.modDinoex	17 Jul 2011 20:14:43 -0000	1.606
@@ -1,5 +1,114 @@
 Aktuelle Version auf: http://iroffer.dinoex.net/
 
+Ab Version 3.27:
+----------------
+
+bugfix: XDCC SEND
+  Wenn ein Benutzer schon Pakete in der 2. Warteschlange hat,
+  werden alle weiteren Pakete ebenfalls dort eingetragen.
+
+381) subdirs_delayed
+  Wenn aktiviert, iwerden bei addir, addnew und autoadd die Unter-
+  Verzeichnisse später durchsucht. Damit bleibt der Bot auch bei großer
+  Anzahl von Unter-Verzeichnissen reaktionsschnell.
+  Default: aus, Verzeichnisse werden sofort durchsucht.
+
+bugfix: DUMP
+  Die Ausgabe von Werten mit Mutiplikationsfaktor ist jetzt richtig.
+
+380) server_connect_timeout
+  Setze den Startwert für das Timeout in Sekunden für die Verbindung
+  zum IRC-Server.
+  Default: 5
+
+379) DCLD
+  Zeige IP und Land bei dem Kommando "DCLD".
+
+378) respondtochannellist, respondtochannelxdcc
+  Global oder je Netzwerk einstellbar.
+
+377) periodicmsg
+  Nur per Netzwerk einstellbar. Mehrere Zeilen pro Netzwerk möglich.
+
+376) IQSEND
+
+  Neue Admin Kommandos:
+  IQSEND                             Verschiebe einen Eintrag von der 2. Warteschlange in die 1. Warteschlange
+  IQSEND <id>                        Verschiebe den Eintrag von der 2. Warteschlange in die 1. Warteschlange
+
+bugfix: HOLDQUEUE
+  Zeige in der Ausgabe von BOTINFO an das HOLDQUEUE aktiv ist.
+
+375) OFFLINE, ONLINE
+
+  Neue Admin Kommandos:
+  OFFLINE                            Trenne Bot von allen Netzen
+  OFFLINE <net>                      Trenne Bot vom angegebenen Netz
+  ONLINE                             Verbine Bot zu allen Netzen
+  ONLINE <net>                       Verbine Bot zum angegebenen Netz
+
+374) announce_size
+  Melde die Größe des Paks beim Announce.
+  Default: no
+
+bugfix: http_port
+  Erzwinge Zeitzone 'GMT' in allen Datumsangaben.
+
+373) http_dir
+  Erlaube den teilweisen Download und das fortsetzen von Dateien.
+  Zähle alle Dateien bei der Berechnung des "maxspeed" mit.
+
+bugfix: ignore_duplicate_ip
+  Entferne den Benutzer auch aus den Warteschlangen.
+
+372) statefile
+  Starten und Beenden des Bots ist jetzt deutlich schneller.
+
+371) tcp_nodelay, tcp_buffer_size
+  Bessere Default-Werte unter Windows/CYGWIN.
+
+Debugging und Logging verbessert.
+
+bugfix: BATCH
+  versions affected: 3.23 - 3.26
+  Bot stürtze beim Admin Kommando ab wenn der Bereich über das letze Paket hinaus ging.
+
+370) delayed announce
+  Warte mit dem Announce bis der AUTOADD fertig ist
+  und die Prüfsumme der Dateien brechnet wurde.
+  Warte auch wenn die CRC nicht zur Datei passt.
+
+bugfix: autosendpack
+  Erlaube "autosendpack" mit Paketnummer '-1'.
+
+369) RUBY
+
+  Neue Admin Kommandos:
+  RUBY <method> <args>               Rufe die Methode <methode> im Ruby-Script mit den Parametern <args> auf
+  RUBY <method>                      Rufe die Methode <methode> im Ruby-Script ohne Parameter auf
+
+bugfix: REHASH
+  versions affected: 3.0 - 3.26
+  Bot crashte wenn "user_nick" nicht global definiert wurde.
+
+368) XDCC SEND
+  Hinweis an den Benutzer einer Warteschlange "XDCC REMOVE <number>".
+
+367) PRINT, ruby_script
+  Neue Variablen für irconfig() "disk_space", "disk_space_text", "packsum",
+  "idlequeueused", "mainqueueused", "slotsfree", "slotsused",
+  "transfereddaily", "transferedweekly", "transferedmonthly",
+  "transferedtotal", "transferedtotalbytes", "uptime", "totaluptime",
+  "bandmax", "banduse"
+  Neue Variable "mynick"
+
+366) http_port 
+  Benutze kurze URLs in der Webliste.
+
+bugfix: mime_type
+  versions affected: 3.0 - 3.26
+  Zusätzliche mime_type Zeilen wurden nur ein einziges mal verwendet.
+
 Ab Version 3.26:
 ----------------
 
Index: README.modDinoex
===================================================================
RCS file: /usr/home/public/iroffer/README.modDinoex,v
retrieving revision 1.833
retrieving revision 1.868
diff -u -r1.833 -r1.868
--- README.modDinoex	10 Feb 2011 18:31:33 -0000	1.833
+++ README.modDinoex	17 Jul 2011 20:14:43 -0000	1.868
@@ -1,5 +1,112 @@
 Aktuelle Version auf: http://iroffer.dinoex.net/
 
+With Version 3.27:
+------------------
+
+bugfix: XDCC SEND
+  If user has already packs in the idlequeue, do not add new packs from him to the mainqueue.
+
+381) subdirs_delayed
+  When configured, addir, addnew, and autoadd will scan subdirs later.
+  This keeps the bot responsive if you have a huge directory tree.
+  Default: off, subdirectories are scanned immediatly.
+
+bugfix: DUMP
+  Fix output of values with multiplier.
+
+380) server_connect_timeout (insprired by Thom)
+  Set the starting timeout in seconds on connect to the IRC-server.
+  This setting can only be set per network.
+  Default: 5
+
+379) DCLD (insprired by Aashiqmunda)
+  Show IP and country with DCLD.
+
+378) respondtochannellist, respondtochannelxdcc (inspired by CreeW)
+  This setting can be global or per network.
+
+377) periodicmsg (insprired by nanashiRei)
+  Setting now only per network. Multiple lines per net allowed.
+
+376) IQSEND (inspired by CreeW)
+
+  new admin commands:
+  IQSEND                             Push next entry from idle queue into main queue
+  IQSEND <id>                        Push given entry from idle queue into main queue
+
+bugfix: HOLDQUEUE
+  Show HOLDQUEUE in botinfo when active.
+
+375) OFFLINE, ONLINE (inspired by isengaurd)
+
+  new admin commands:
+  OFFLINE                            Close all networks
+  OFFLINE <net>                      Close given network
+  ONLINE                             Resume all networks
+  ONLINE <net>                       Resume given network
+
+374) announce_size (inspired by vice)
+  Print size of pack on announce.
+  Default: no
+
+bugfix: http_port
+  Force GMT to all Dates.
+
+373) http_dir
+  Support partial downloads and resume of files.
+  Count all files into maxspeed.
+
+bugfix: ignore_duplicate_ip
+  Remove user from queue too.
+
+372) statefile
+  Startup and shutdown of the bot is now much faster.
+
+371) tcp_nodelay, tcp_buffer_size (inspired by Aashiqmunda)
+  Better defaults for Windows/CYGWIN builds.
+
+extend debug and log information.
+
+bugfix: BATCH (reported by Aashiqmunda)
+  versions affected: 3.23 - 3.26
+  Bot did crash on admin command if the range was exeeding the last pack on the bot.
+
+370) delayed announce (inspired by TheDeath)
+  Delay announce till all files are added
+  and the checkums has been computed.
+  Wait if pack stays locked.
+
+bugfix: autosendpack (reported by Jikan)
+  Allow "autosendpack" with packnumber '-1'.
+
+369) RUBY
+
+  new admin commands:
+  RUBY <method> <args>               Call a method in the ruby_script with parameters <args>
+  RUBY <method>                      Call a method in the ruby_script with no parameters
+
+bugfix: REHASH (reported by CreeW)
+  versions affected: 3.0 - 3.26
+  Bot crashed when no global "user_nick" was defined.
+
+368) XDCC SEND (inspired by TheDeath)
+  Tell user to use "XDCC REMOVE <number>".
+
+367) PRINT, ruby_script
+  New variables for irconfig() "disk_space", "disk_space_text", "packsum",
+  "idlequeueused", "mainqueueused", "slotsfree", "slotsused",
+  "transfereddaily", "transferedweekly", "transferedmonthly",
+  "transferedtotal", "transferedtotalbytes", "uptime", "totaluptime",
+  "bandmax", "banduse"
+  New variable "mynick"
+
+366) http_port
+  Use short urls in weblist.
+
+bugfix: mime_type
+  versions affected: 3.0 - 3.26
+  Extra mime_type definitions where only used once.
+
 With Version 3.26:
 ------------------
 
@@ -27,7 +134,7 @@
   Disable connecting to this network.
 
 bugfix: CLOSEC (reported by unlogisch)
-  Bot did crash when paramater did not match a chat.
+  Bot did crash when parameter did not match a chat.
   versions affected: 3.25
 
 bugfix: getip_network (reported by Gotanius)
@@ -627,7 +734,7 @@
   Set version 2 in the "statefile".
   Fix error messages while parsing.
 
-302) CHCOLOR (inspred by CreeW)
+302) CHCOLOR (inspired by CreeW)
 
   new admin commands:
   CHCOLOR <n> <m> <x>                Set the of pack <n> to <m> to color <x>
Index: THANKS
===================================================================
RCS file: /usr/home/public/iroffer/THANKS,v
retrieving revision 1.368
retrieving revision 1.379
diff -u -r1.368 -r1.379
--- THANKS	27 Jan 2011 20:56:32 -0000	1.368
+++ THANKS	10 Jun 2011 06:27:29 -0000	1.379
@@ -101,6 +101,8 @@
 	suggesting HTTP 403 response
 	option "http_forbidden"
 	suggesting "expire_logfiles"
+	suggesting announce of "XDCC REMOVE <nr>"
+	suggesting delayed announce
 
 [GFE]Lunix
 	alias xdcc list group <group>
@@ -555,6 +557,9 @@
 	reporting "CHCOLOR" bug
 	suggesting "CHMAXS" with range
 	suggesting "NEWANN" with params
+	reporting "REHASH" bug
+	suggesting "IQSEND"
+	suggesting "respondtochannellist" per network
 
 [M]-V
 	reporting ADDDIR spaces bug
@@ -574,6 +579,8 @@
 	reporting "autaaddann" text problem
 	suggesting "announce_suffix_color"
 	reporting "XDCC BATCH" bug
+	reporting "BATCH" crash
+	suggesting "DCLD" with IP/country
 
 SellKony
 	reporting CONFIG crash
@@ -619,6 +626,7 @@
 
 isengaurd
 	reporting "linux-sendfile" bug
+	suggesting "OFFLINE" mode
 
 PastisD
 	suggesting "xdccxmlfile" with nicknames
@@ -696,6 +704,7 @@
 
 nanashiRei
 	reporting "xdccxmlfile" spelling of bandwidth
+	suggesting multiple "periodicmsg"
 
 paulhamm
 	reporting "getip_network" bug
@@ -721,3 +730,12 @@
 Gotanius
 	reporting "getip_network" bug
 
+Jikan
+	reporting "autosendpack" bug
+
+vice
+	suggestimg "announce_size"
+
+Thom
+	suggesting "server_connect_timeout"
+
Index: TODO
===================================================================
RCS file: /usr/home/public/iroffer/TODO,v
retrieving revision 1.191
retrieving revision 1.205
diff -u -r1.191 -r1.205
--- TODO	30 Jan 2011 08:10:28 -0000	1.191
+++ TODO	21 Jul 2011 15:39:14 -0000	1.205
@@ -2,6 +2,8 @@
 Feature #38 xdcc command to export the crc32/md5 as sumfile
 Feature #70 command for saving the "running" config
 Feature #89 limit autoaddan to file that matches a given mask
+Feature #114: Support for compressing the rotated logfiles
+Feature #118: Add ability to whitelist certain filetypes for adddir
 
 [Iroffer.org]
 
@@ -63,19 +65,12 @@
 
 Short Term Features:
   1379  different packlists for different groups
-  1394  pack size included in the output of announce
   1438  more announce types for plist
-  1486  autotrim input
-  1488  offline or maintenance mode
   1494  send note to user when queuing
   1498  rss feed on the bot
   1516  allow batch syntax for XDCC SEND
-  1517  more than one periodicmsg
-  1523  config Server Connection Timed Out
-  1534  state the ip of the user in dcld and geoip
   1535  reduce queued message on batch
   1536  silent add
-  1539  RUBY command
 
 Long Term Features:
   1015  http admin
@@ -144,6 +139,7 @@
   1459  transfer new files to another bot
   1477  batch announce
   1483  autoaddann pattern
+  1486  autotrim input from users " XDCC SEND"
   1490  delay the responce to the !new command
   1500  force to send a pack to someone who downloaded a certain pack
   1521  hostmask or nick in exempt list for ignoreduplicate ip
@@ -151,6 +147,17 @@
   1526  variables in config file
   1529  XDCC-DELTA
   1530  summary after find.
+  1542  Fix future date
+  1544  Warn if ssl connects do non-ssl port
+  1545  Supoort color codes in announce
+  1546  Auth telnet/chat with CERTFP
+  1547  Monitor diskload and reduce slots
+  1552  wildcards dirnames in autoadd_dir
+  1555  easier color for announce
+  1558  suppress batch notices, suppress remove notices
+  1563  Restrict group admin access to DCLD and others
+  1567  Support netmap for line rate (14.88Mpps) on a 10GigE link 
+  1578  multiple(batch) files announce
 
 Not going to happen anytime soon:
   1001  need voice seperate for each channel
@@ -215,4 +222,7 @@
   1452  zeroconf/mdns/avahi-support
   1495  support for plowshare
   1525  user defined limits
+  1543  native windows build with MINGW
+  1565  lock packs on fixed posion while sorting the rest
+  1575  aspera transfer protocol
 
Index: beispiel.config
===================================================================
RCS file: /usr/home/public/iroffer/beispiel.config,v
retrieving revision 1.204
retrieving revision 1.212
diff -u -r1.204 -r1.212
--- beispiel.config	10 Feb 2011 18:31:33 -0000	1.204
+++ beispiel.config	17 Jul 2011 19:10:21 -0000	1.212
@@ -5,14 +5,13 @@
 
 # Version dieser Datei:
 #
-# $Id: beispiel.config,v 1.204 2011/02/10 18:31:33 cvs Exp $
+# $Id: beispiel.config,v 1.212 2011/07/17 19:10:21 cvs Exp $
 #
 
 ##############################################################################
 ##                                  FILES                                   ##
 ##############################################################################
 
-
 ##############################################################################
 ###                             - pid file -                               ###
 ### Schreibt die Prozess-ID beim Start in diese Datei                      ###
@@ -95,7 +94,7 @@
 ##############################################################################
 ###                         - dos text files -                             ###
 ### Schreibe das xdcclistfile als DOS Text, mit CRLF als Zeilenumbruch.    ###
-### Default: no, auf CYGWIN default: yes                                   ###
+### Default: no, auf CYGWIN Default: yes                                   ###
 #dos_text_files yes
 #dos_text_files no
 
@@ -144,6 +143,12 @@
 #http_port 8000
 
 ##############################################################################
+###                         - http access log -                            ###
+### Schreibe alle Zugriffe via HTTP im Format CLF in die angegebene Datei. ###
+### Default: kein Protokoll.                                               ###
+#http_access_log httpd_access.log
+
+##############################################################################
 ###                            - http vhost -                              ###
 ### Liste von bis zu zwei lokale IP-Adressen die der Webserver nutzen      ###
 ### soll. z.B.: "::" oder "0.0.0.0" für alle IP-Adressen.                  ###
@@ -153,12 +158,6 @@
 http_vhost 0.0.0.0
 
 ##############################################################################
-###                         - http access log -                            ###
-### Schreibe alle Zugriffe via HTTP im Format CLF in die angegebene Datei. ###
-### Default: kein Protokoll.                                               ###
-#http_access_log httpd_access.log
-
-##############################################################################
 ###                            - http admin -                              ###
 ### Erlaube Verwaltung über den eingebauten Webserver.                     ###
 ### Default: kein Login                                                    ###
@@ -311,6 +310,14 @@
 #proxyinfo blah blah
 
 ##############################################################################
+###                       - server connect timeout -                       ###
+### Setze den Startwert für das Timeout in Sekunden für die Verbindung     ###
+### zum IRC-Server.                                                        ###
+### Dies ist nur je Netzwerk einstellbar.                                  ###
+### Default: 5                                                             ###
+#server_connect_timeout 10
+
+##############################################################################
 ###                         - onjoin information -                         ###
 ### Mittels server_join_raw, server_connected_raw und channel_join_raw     ###
 ### können RAW-IRC-Commands an den Server zu verschiedenen Zeitpunkten     ###
@@ -454,8 +461,8 @@
 #channel #chan04 -plist 14 -pformat full -joinmsg "!voiceme"
 #channel #chan04 -plist 14 -pformat full -fish geheim
 
-# 1. Netzwerk
 
+# 1. Netzwerk
 network euirc.net
 {
 server irc.euirc.net
@@ -463,14 +470,12 @@
 }
 
 # 2. Netzwerk
-
 network otakubox.at
 {
 server irc.otakubox.at 6667
 channel #dinoex -noannounce
 }
 
-
 ##############################################################################
 ###                           - wait after join -                          ###
 ### Nach den Betreten eines Channels mach der Bot keine Announces für die  ###
@@ -536,12 +541,15 @@
 ###                           - TCP buffer size -                          ###
 ### Setzt den Netzwerkbuffer für TCP auf den angegebenen Wert in kByte.    ###
 ### Default: 0 = das Betriebssystem optimiert.                             ###
-#tcp_buffer_size 128
+### Unter CYGWIN ist der Default 372                                       ###
+#tcp_buffer_size 372
 
 ##############################################################################
 ###                            - TCP no delay -                            ###
 ### Schalte das Nagle-Verfahren zur Optimierung der TCP Pakete aus.        ###
-#tcp_nodelay
+### Default: no, auf CYGWIN Default: yes                                   ###
+#tcp_nodelay no
+#tcp_nodelay yes
 
 ##############################################################################
 ###                       - override unix loginname -                      ###
@@ -637,7 +645,7 @@
 ### Wenn ein User einen Trasfer beendet, so wird der nächste Transfer      ###
 ### von einem anderen User in der Warteschlange bevorzugt. Damit wird      ###
 ### die vorhandene Bandbreite gelichmäiger verteilt.                       ###
-### default: der älteste Eintrag                                           ###
+### Default: der älteste Eintrag                                           ###
 balanced_queue
 
 ##############################################################################
@@ -650,7 +658,7 @@
 ##############################################################################
 ###                          - send batch -                                ###
 ### Erlaube XDCC BATCH. Die Pakete werden in die Warteschlangen eingefügt. ###
-### default: nicht erlaubt                                                 ###
+### Default: nicht erlaubt                                                 ###
 send_batch
 
 ##############################################################################
@@ -688,6 +696,14 @@
 include_subdirs
 
 ##############################################################################
+###                     - subdirs delayed -                                ###
+### Wenn aktiviert, iwerden bei addir, addnew und autoadd die Unter-       ###
+### Verzeichnisse später durchsucht. Damit bleibt der Bot auch bei großer  ###
+### Anzahl von Unter-Verzeichnissen reaktionsschnell.                      ###
+### Default: aus, Verzeichnisse werden sofort durchsucht.                  ###
+#subdirs_delayed
+
+##############################################################################
 ###                     - remove lost files -                              ###
 ### Wenn eine Datei auf dem Server gelöscht wird, wird die Datei vom Bot   ###
 ### entfernt. Bitte vorsichtig einsetzten, falls man den Bot im falschen   ###
@@ -697,7 +713,7 @@
 ##############################################################################
 ###                        - monitor files -                               ###
 ### Überwache maximal n Datein pro Skeunde ib gelöscht oder geändert.      ###
-### default: 20
+### Default: 20                                                            ###
 #monitor_files 20
 
 ##############################################################################
@@ -762,6 +778,12 @@
 announce_seperator " - "
 
 ##############################################################################
+###                       - announce size -                                ###
+### Melde die Größe des Paks beim Announce.                                ###
+### Default: no                                                            ###
+#announce_size
+
+##############################################################################
 ###                      - auto add time -                                 ###
 ### Zeit in Sekunden nach der der Bot nach neuen Files im Verzeichnis      ###
 ### autoadd_dir sucht. Standardwert 0 d.h. nicht aktiv.                    ###
@@ -779,8 +801,7 @@
 ### Dies passiert regelmäßig über die Konfiguraion "autoadd_time" oder     ###
 ### mit den Befehl "AUTOADD" durch den Admin.                              ###
 ### either by "autoadd_time" or by the "AUTOADD" command.                  ###
-
-##ä Es können mehrere Verzeichnisse angegeben werden.                      ###
+### Es können mehrere Verzeichnisse angegeben werden.                      ###
 #autoadd_dir /home/me/new
 #autoadd_dir /home/other/new
 
@@ -857,7 +878,6 @@
 ### Default: natürlliche sortierenung.                                     ###
 #no_natural_sort
 
-
 ##############################################################################
 ###                  - restrict xdcc list and xdcc send -                  ###
 ### Wenn restrictlist gesetzt wird, kann xdcc list und xdcc info nur von   ###
@@ -940,18 +960,20 @@
 ###                      - channel !list command -                         ###
 ### Wenn respondtochannellist gesetzt wird, reagiert der bot auf !list     ###
 ### im Channel geschrieben.                                                ###
+### Global oder je Netzwerk einstellbar.                                   ###
 respondtochannellist
 
 ##############################################################################
 ###                      - channel !list text -                            ###
 ### Text der in die Antwort auf das !list im channel eingebaut wird.       ###
+### Global oder je Netzwerk einstellbar.                                   ###
 #respondtochannellistmsg packlist at http://www.examle.com/
 
 ##############################################################################
 ###                      - slow slow_privmsg -                             ###
 ### Begrenze PRIVMSG auf 1 Zeile alle n Sekunden. Damit verhindert man das ###
 ### der Bot ein Flooding auslöst.                                          ###
-### Nur per Netzwerk einstellbar.ork.                                      ###
+### Nur per Netzwerk einstellbar.                                          ###
 ### Default: 1                                                             ###
 #slow_privmsg 1
 
@@ -1280,7 +1302,8 @@
 ### Wenn iroffer periodisch jemanden eine Mitteilung schicken soll für     ###
 ### Indizierungszwecke oder anderen bedarf, kann perdidocmsg verwendet     ###
 ### werden:                                                                ###
-### "periodicmsg <nick> <zeit in min> <mitteilung>
+### "periodicmsg <nick> <zeit in min> <mitteilung>                         ###
+### Nur per Netzwerk einstellbar. Mehrere Zeilen pro Netzwerk möglich.     ###
 #periodicmsg nick 10 index me
 
 ##############################################################################
@@ -1309,7 +1332,7 @@
 ### 3 = Hinzufügen und Ändern von Packs                                    ###
 ### 4 = Löschen von Packs                                                  ###
 ### 5 = Vollzugriff, auch Umbenennen und Löschen von Dateien               ###
-### default: 5                                                             ###
+### Default: 5                                                             ###
 #adminlevel 4
 
 ##############################################################################
@@ -1331,7 +1354,7 @@
 ###                     - remote half admin level -                        ###
 ### Beschränke die Helfer Befehle per DCC-Chat oder '/msg'.                ###
 ### Werte siehe adminlevel                                                 ###
-### default: 2                                                             ###
+### Default: 2                                                             ###
 #hadminlevel 3
 
 ##############################################################################
@@ -1390,7 +1413,7 @@
 ###                             - max upspeed -                            ###
 ### Hier wird die Bandbreite von Uploads auf maximal n KB/sec begrenzt.    ###
 ### Default: keine Beschränkung.                                           ###
-#max_upspeed 100
+max_upspeed 1000
 
 ##############################################################################
 ###                          - hide OS information -                       ###
Index: cygwin-gen-dist.sh
===================================================================
RCS file: /usr/home/public/iroffer/cygwin-gen-dist.sh,v
retrieving revision 1.26
retrieving revision 1.27
diff -u -r1.26 -r1.27
--- cygwin-gen-dist.sh	21 Jan 2011 10:56:28 -0000	1.26
+++ cygwin-gen-dist.sh	13 Jul 2011 03:20:10 -0000	1.27
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-all="LICENSE README-iroffer.txt THANKS header.html footer.html doc/iroffer.1.txt"
+all="LICENSE README THANKS header.html footer.html doc/iroffer.1.txt"
 fen="README.modDinoex sample.config help-admin-en.txt"
 fde="LIESMICH.modDinoex beispiel.config help-admin-de.txt"
 fit="README.modDinoex sample.config help-admin-it.txt"
Index: cygwin-install-upnp.sh
===================================================================
RCS file: /usr/home/public/iroffer/cygwin-install-upnp.sh,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- cygwin-install-upnp.sh	12 Nov 2010 06:07:24 -0000	1.2
+++ cygwin-install-upnp.sh	20 Feb 2011 16:36:40 -0000	1.3
@@ -1,7 +1,5 @@
 #!/bin/sh
-ver="${1-1.4.20100609}"
-# 1.4 has regressions
-ver="${1-1.3}"
+ver="${1-1.5}"
 name="miniupnpc-${ver}"
 curl -o "${name}.tar.gz" "http://miniupnp.free.fr/files/${name}.tar.gz"
 tar -xvzf "${name}.tar.gz"
Index: de.txt
===================================================================
RCS file: /usr/home/public/iroffer/de.txt,v
retrieving revision 1.376
retrieving revision 1.396
diff -u -r1.376 -r1.396
--- de.txt	9 Feb 2011 06:20:04 -0000	1.376
+++ de.txt	21 Jul 2011 10:40:07 -0000	1.396
@@ -241,9 +241,6 @@
 243 ","
 244 "** Kein Befehl eingegeben, versuche es noch einmal"
 245 "** Befehl nicht erkannt, versuche es mit \"HELP\""
-246 "ADMIN %s requested (console)"
-247 "ADMIN %s requested (DCC Chat: %s) (network: %s)"
-248 "ADMIN %s requested (MSG: %s) (network: %s)"
 249 "-- %s Befehle --"
 250 "Info"
 251 "Transfer"
@@ -550,7 +547,7 @@
 575 "Could Not Create Socket, Aborting: %s"
 576 "Couldn't Bind to Socket, Aborting: %s"
 577 "Couldn't Listen, Aborting: %s"
-578 "\1DCC CHAT CHAT %s\1"
+578 "DCC CHAT CHAT %s"
 579 "DCC CHAT sent to %s on %s, waiting for connection on %s"
 580 "Accept Error, Aborting: %s"
 581 "DCC CHAT connection received, authenticating"
@@ -608,13 +605,10 @@
 640 "try"
 641 "Select returned an error: %s"
 642 "got"
-643 "Unable to resolve server %s (status=0x%.8X)"
 644 "host not found"
 645 "no ip address"
 646 "non-recoverable name server"
 647 "try again later"
-648 "Unable to resolve server %s (%s)"
-649 "Unable to resolve server %s (status=0x%.8X, %s: %d)"
 650 "exit"
 651 "signaled"
 652 "gettimeofday() failed! %s\n"
@@ -625,7 +619,6 @@
 657 "Couldn't determine connection status: %s on %s"
 658 "Server Connection Failed: %s on %s"
 659 "Server Connection to %s Established, Logging In"
-660 "Couldn't Set Blocking"
 661 "ourip = "
 662 "couldn't get ourip on %s"
 663 "Error resolving server %s on %s"
@@ -698,22 +691,22 @@
 741 ":"
 743 "Auto-ignore activated for %s (%s) lasting %i%c%i%c"
 744 ". Further messages will increase duration."
-748 ":Use CTCP CLIENTINFO <COMMAND> to get more specific information\1"
+748 ":Use CTCP CLIENTINFO <COMMAND> to get more specific information"
 749 "PING"
-750 "\1CLIENTINFO PING returns the arguments it receives\1"
+750 "CLIENTINFO PING returns the arguments it receives"
 751 "DCC"
-752 "\1CLIENTINFO DCC requests a DCC for chatting or file transfer\1"
+752 "CLIENTINFO DCC requests a DCC for chatting or file transfer"
 753 "VERSION"
-754 "\1CLIENTINFO VERSION shows information about this client's version\1"
+754 "CLIENTINFO VERSION shows information about this client's version"
 755 "XDCC"
-756 "\1CLIENTINFO XDCC LIST|SEND list and DCC file(s) to you\1"
+756 "CLIENTINFO XDCC LIST|SEND list and DCC file(s) to you"
 757 "UPTIME"
-758 "\1CLIENTINFO UPTIME shows how long this client has been running\1"
+758 "CLIENTINFO UPTIME shows how long this client has been running"
 759 "[CTCP] %s in %s: CLIENTINFO"
 763 " "
 764 "[CTCP] %s on %s: PING"
-767 "\1VERSION iroffer-dinoex "
-768 "\1"
+767 "VERSION iroffer-dinoex "
+768 ""
 769 "[CTCP] %s on %s: VERSION"
 773 "[CTCP] %s on %s: UPTIME"
 777 "[CTCP] %s on %s: STATUS"
@@ -797,7 +790,6 @@
 892 "requested"
 893 "** Sende dir jetzt die Datei #%u (\"%s\")"
 894 "%s, die Größe ist %sB. (Resume wird unterstützt)"
-896 "d\1"
 898 "unlimitedhost found: %s (%s on %s)"
 899 "** XDCC INFO denied, disabled by configuration"
 905 "Denied (queue/dup)"
@@ -808,7 +800,7 @@
 910 "abgewiesen, die Warteschlange ist voll, max. %u Dateien, Versuche es später nochmal"
 911 "Queued (slot)"
 912 "Du bist jetzt in der Warteschlange für Datei %u (\"%s\") in Position %u. Wenn Du später Abbrechen "
-913 "willst schreibe \"/MSG %s XDCC REMOVE\"."
+913 "willst schreibe \"/MSG %s XDCC REMOVE %u\"."
 914 " (low bandwidth)"
 915 " (manual)"
 916 "QUEUED SEND%s: %s (%s on %s), Pack #%u"
@@ -1070,13 +1062,12 @@
 1385 "(%li Sekunden bis zum Abbruch)"
 1386 "Dein Download ist mit %2.1fK/sec ist zu langsam, mindestens %2.1fK/sec erforderlich"
 1387 "Du wirst wegen zu langsamen Download bestratft"
-1388 "** Du wurdest aus der Warteschlange entfernt: Strafe für zu langsame Übertragung"
 1390 "Punish-ignore activated for (%s on %s) (%s) %u minutes"
 1391 "Zur Strafe wirst du %s (%s) für %u Minuten ignoriert."
 1392 "Cant Stat Upload File '%s': %s"
 1393 "File Error, File couldn't be opened for writing"
 1394 "File Error, That filename already exists"
-1395 "\1DCC RESUME %s %d %"
+1395 "DCC RESUME %s %d %"
 1396 "Cant Access Upload File '%s': %s"
 1397 "Couldn't Bind Virtual Host, Sorry"
 1398 "Couldn't Connect"
@@ -1130,7 +1121,6 @@
 1485 "Pointer 0x%8.8lX not found in meminfo database while trying to free!!"
 1486 "Please report this error to Dinoex dinoex@dinoex.net"
 1488 "Aborting Program! (core file should be generated)"
-1489 "adminpass is not encrypted!"
 1490 "Trace %3i  %-20s %-16s:%5i  %lu.%06lu"
 1491 "UNKNOWN"
 1492 "<undef>"
@@ -1143,7 +1133,6 @@
 1499 "[%d]: %s"
 1500 "="
 1501 "=%s"
-1502 "  : "
 1503 "  : %s"
 1504 "  "
 1505 "GDATA DUMP BEGIN"
@@ -1474,7 +1463,6 @@
 1954 "<a class=\"credits\" href=\""
 1955 "Quellcode"
 1956 "footer.html"
-1957 "gruppe="
 1958 "help-admin-de.txt"
 1959 "  : left=%ld"
 1965 "host=%s port=%s"
@@ -1497,7 +1485,6 @@
 1985 "(mehr)"
 1986 "<th class=\"right\">%.1f</th>\n"
 1988 "<td class=\"right\">%.1f</td>\n"
-1990 "traffic="
 1993 " (ssl)"
 1994 "SSL Error %ld:%s"
 1995 "Cant Create SSL context"
@@ -1545,11 +1532,7 @@
 2090 "rget"
 2091 "size"
 2092 "tvol"
-2093 "%s=%s"
 2094 "<a%s title=\"%s\" href=\"/?"
-2095 "traffic"
-2096 "1"
-2097 "order"
 2098 "\">%s</a>"
 2099 " class=\"head\""
 2100 "sortieren nach Paket-Nr."
@@ -1558,17 +1541,13 @@
 2103 "sortieren nach nach Göße der Files"
 2104 "sortieren nach übertragusngsvolumen"
 2105 "sortieren nach Gruppe"
-2106 "order="
-2108 "%2x"
-2109 "%a, %d %b %Y %T %Z"
 2110 "<form action=\"\" method=\"post\">\n"
 2111 "%s&nbsp;\n"
 2112 "Suche"
-2113 "<input type=\"text\" name=\"search\" value=\"%s\" size=30>&nbsp;\n"
+2113 "<input type=\"text\" name=\"s\" value=\"%s\" size=30>&nbsp;\n"
 2114 "<input type=\"submit\" name=\"submit\" value=\" %s \">\n"
 2115 "</form>\n"
 2116 "<br>\n"
-2117 "search="
 2126 "\2**\2 Liste der Pakete anzeigen:     \"/MSG %s XDCC LIST\" \2**\2"
 2127 "\2**\2 Liste der Pakete anzeigen:     \"/MSG %s XDCC LIST gruppe\" \2**\2"
 2128 "\2**\2 Liste abbrechen:               \"/MSG %s XDCC STOP\" \2**\2"
@@ -1586,7 +1565,6 @@
 2154 "Du bist jetzt in der 2. Warteschlange für Datei %u (\"%s\") in Position %u. Wenn Du später Abbrechen "
 2155 "Upload still running"
 2166 "%d.%m.%Y %H:%M"
-2167 "DCC IP: %s NAT=%u"
 2168 "RELOCK"
 2169 "altes-passwort passwort"
 2170 "Ändert alle Pakete mit <altes-password> zu <passwort>"
@@ -1732,7 +1710,6 @@
 2479 "NEWANN"
 2480 "ANNOUNCE für die letzen <n> Pakete in allen Channels"
 2483 "IP From UPnP = %s"
-2525 ";"
 2526 "DEBUG: |%d| %s"
 2537 "CHCOLOR"
 2538 "n [m] x[,b][,s]"
@@ -1799,13 +1776,12 @@
 2602 "  Ignoring added file: %s"
 2603 "  Ignoring queued file: %s"
 2604 "Configured for %s but running on %s?!?"
-2610 "COMMAND %s running: %ld ms"
 2612 "NOANNOUNCE"
 2613 "Sperrt alle ANNOUNCE für die nächsten <x> Minuten"
 2614 " has been"
 2616 "HTTP: connection country blocked"
 2621 "  Ignoring bad filename: %s"
-2622 "\1DCC CHAT CHAT %s %s\1"
+2622 "DCC CHAT CHAT %s %s"
 2623 "DCC passive Chat blockiert, benutze stattdessen \"/MSG %s ADMIN password CHATME\"."
 2630 "Forced quit on %s: %s"
 2631 "** %s: %s\n"
@@ -1820,8 +1796,6 @@
 2654 "Breche den Upload von Bot <nick> ab"
 2655 "DELTRIGGER"
 2656 "Entferne die Trigger von Paket <n> bis <m>"
-2660 "-"
-2661 "%d/%b/%Y:%T %Z"
 2662 "%s - - [%s] \"%s\" %u %ld\n"
 2663 "DISKFREE"
 2664 "Freien Paltz im Uploadverzeichnis anzeigen"
@@ -1832,7 +1806,6 @@
 2694 "DCC Send abgewiesen, %s"
 2695 "DCC Send Denied (%s) from %s on %s"
 2696 "no uploaddir"
-2698 "\2%s\2%s%s"
 2699 "Announced %s%s%s%s%s"
 2700 "\2%u\2%s%s"
 2701 "Announced %u%s%s"
@@ -1869,3 +1842,33 @@
 2774 ", File %s"
 2775 "Upload: Nick %s"
 2776 "Couldn't Set TCP_NODELAY"
+2777 "RUBY"
+2778 "methode [args]"
+2779 "Rufe die Methode <methode> im Ruby-Script mit den Parametern <args> auf"
+2780 "Try Specifying a ruby method"
+2781 "ruby method failed."
+2782 "(console)"
+2783 "(DCC Chat: %s)"
+2784 " (network: %s)"
+2785 "(MSG: %s)"
+2786 "ADMIN %s requested %s"
+2787 "ADMIN %s"
+2788 "Unable to resolve server %s on %s "
+2789 "(status=0x%.8X)"
+2790 "(%s)"
+2791 "(status=0x%.8X, %s: %d)"
+2792 "Iroffer was blocked for %lims"
+2793 " running: %ld ms"
+2794 "Startup"
+2795 "** Du wurdest aus der Warteschlange entfernt: %s"
+2796 "OFFLINE"
+2797 "Trenne Bot vom angegebenen Netz oder von allen Netzen"
+2798 "ONLINE"
+2799 "Verbine Bot zum angegebenen Netz oder zu allen Netzen"
+2800 "DCC IP: %s NAT=%u OFFLINE=%u"
+2801 "NOTICE: HOLDQUEUE is on, no new transfers are started."
+2802 "IQSEND"
+2803 "Verschiebe einen Eintrag von der 2. Warteschlange in die 1. Warteschlange"
+2804 "  ^- [%s country=%s]"
+2805 "\2%s\2%s%s%s%s"
+2806 "%s:%ld %s is not encrypted!"
Index: dynip.sh
===================================================================
RCS file: /usr/home/public/iroffer/dynip.sh,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- dynip.sh	10 Dec 2007 14:27:04 -0000	1.3
+++ dynip.sh	1 Jul 2011 12:26:32 -0000	1.4
@@ -10,8 +10,10 @@
 # 
 # If your ip address changes, the file will be updated by this script
 # and iroffer rehashed to see the change
-
-
+#
+# Call this scrip when your IP changes or put in in your crontab.
+# Rin "crontab -e" and place the following line in the editor:
+# */5 * * * * /full/path/to/iroffer/dynip.sh
 
 URL="http://iroffer.org/myip.cgi"
 CONFIGFILE="dynip.conf"
Index: en.txt
===================================================================
RCS file: /usr/home/public/iroffer/en.txt,v
retrieving revision 1.466
retrieving revision 1.486
diff -u -r1.466 -r1.486
--- en.txt	9 Feb 2011 06:20:05 -0000	1.466
+++ en.txt	21 Jul 2011 10:40:07 -0000	1.486
@@ -49,7 +49,7 @@
 49 "channel style [net]"
 50 "Sends <style> (full|minimal|summary) XDCC LIST to <channel>"
 51 "QSEND"
-52 "Start an extra transfer from queue"
+52 "Start an extra transfer from main queue"
 53 "SLOTSMAX"
 54 "[slots]"
 55 "temporary change slotsmax to <slots>"
@@ -241,9 +241,6 @@
 243 ","
 244 "** Missing Command, try again"
 245 "** User Command Not Recognized, try \"HELP\""
-246 "ADMIN %s requested (console)"
-247 "ADMIN %s requested (DCC Chat: %s) (network: %s)"
-248 "ADMIN %s requested (MSG: %s) (network: %s)"
 249 "-- %s Commands --"
 250 "Info"
 251 "Transfer"
@@ -550,7 +547,7 @@
 575 "Could Not Create Socket, Aborting: %s"
 576 "Couldn't Bind to Socket, Aborting: %s"
 577 "Couldn't Listen, Aborting: %s"
-578 "\1DCC CHAT CHAT %s\1"
+578 "DCC CHAT CHAT %s"
 579 "DCC CHAT sent to %s on %s, waiting for connection on %s"
 580 "Accept Error, Aborting: %s"
 581 "DCC CHAT connection received, authenticating"
@@ -608,13 +605,10 @@
 640 "try"
 641 "Select returned an error: %s"
 642 "got"
-643 "Unable to resolve server %s (status=0x%.8X)"
 644 "host not found"
 645 "no ip address"
 646 "non-recoverable name server"
 647 "try again later"
-648 "Unable to resolve server %s (%s)"
-649 "Unable to resolve server %s (status=0x%.8X, %s: %d)"
 650 "exit"
 651 "signaled"
 652 "gettimeofday() failed! %s\n"
@@ -625,7 +619,6 @@
 657 "Couldn't determine connection status: %s on %s"
 658 "Server Connection Failed: %s on %s"
 659 "Server Connection to %s Established, Logging In"
-660 "Couldn't Set Blocking"
 661 "ourip = "
 662 "couldn't get ourip on %s"
 663 "Error resolving server %s on %s"
@@ -698,22 +691,22 @@
 741 ":"
 743 "Auto-ignore activated for %s (%s) lasting %i%c%i%c"
 744 ". Further messages will increase duration."
-748 ":Use CTCP CLIENTINFO <COMMAND> to get more specific information\1"
+748 ":Use CTCP CLIENTINFO <COMMAND> to get more specific information"
 749 "PING"
-750 "\1CLIENTINFO PING returns the arguments it receives\1"
+750 "CLIENTINFO PING returns the arguments it receives"
 751 "DCC"
-752 "\1CLIENTINFO DCC requests a DCC for chatting or file transfer\1"
+752 "CLIENTINFO DCC requests a DCC for chatting or file transfer"
 753 "VERSION"
-754 "\1CLIENTINFO VERSION shows information about this client's version\1"
+754 "CLIENTINFO VERSION shows information about this client's version"
 755 "XDCC"
-756 "\1CLIENTINFO XDCC LIST|SEND list and DCC file(s) to you\1"
+756 "CLIENTINFO XDCC LIST|SEND list and DCC file(s) to you"
 757 "UPTIME"
-758 "\1CLIENTINFO UPTIME shows how long this client has been running\1"
+758 "CLIENTINFO UPTIME shows how long this client has been running"
 759 "[CTCP] %s in %s: CLIENTINFO"
 763 " "
 764 "[CTCP] %s on %s: PING"
-767 "\1VERSION iroffer-dinoex "
-768 "\1"
+767 "VERSION iroffer-dinoex "
+768 ""
 769 "[CTCP] %s on %s: VERSION"
 773 "[CTCP] %s on %s: UPTIME"
 777 "[CTCP] %s on %s: STATUS"
@@ -797,7 +790,6 @@
 892 "requested"
 893 "** Sending you pack #%u (\"%s\")"
 894 "%s, which is %sB. (resume supported)"
-896 "d\1"
 898 "unlimitedhost found: %s (%s on %s)"
 899 "** XDCC INFO denied, disabled by configuration"
 905 "Denied (queue/dup)"
@@ -808,7 +800,7 @@
 910 "Main queue of size %u is Full, Try Again Later"
 911 "Queued (slot)"
 912 "Added you to the main queue for pack %u (\"%s\") in position %u. To Remove yourself at "
-913 "a later time type \"/MSG %s XDCC REMOVE\"."
+913 "a later time type \"/MSG %s XDCC REMOVE %u\"."
 914 " (low bandwidth)"
 915 " (manual)"
 916 "QUEUED SEND%s: %s (%s on %s), Pack #%u"
@@ -1070,13 +1062,12 @@
 1385 "(%li seconds remaining until timeout)"
 1386 "Under Min Speed Requirement, %2.1fK/sec is less than %2.1fK/sec"
 1387 "You are being punished for your slowness"
-1388 "** Removed From Queue: You are being punished for your slowness"
 1390 "Punish-ignore activated for (%s on %s) (%s) %u minutes"
 1391 "Punish-ignore activated for %s (%s) %u minutes"
 1392 "Cant Stat Upload File '%s': %s"
 1393 "File Error, File couldn't be opened for writing"
 1394 "File Error, That filename already exists"
-1395 "\1DCC RESUME %s %d %"
+1395 "DCC RESUME %s %d %"
 1396 "Cant Access Upload File '%s': %s"
 1397 "Couldn't Bind Virtual Host, Sorry"
 1398 "Couldn't Connect"
@@ -1130,7 +1121,6 @@
 1485 "Pointer 0x%8.8lX not found in meminfo database while trying to free!!"
 1486 "Please report this error to Dinoex dinoex@dinoex.net"
 1488 "Aborting Program! (core file should be generated)"
-1489 "adminpass is not encrypted!"
 1490 "Trace %3i  %-20s %-16s:%5i  %lu.%06lu"
 1491 "UNKNOWN"
 1492 "<undef>"
@@ -1143,7 +1133,6 @@
 1499 "[%d]: %s"
 1500 "="
 1501 "=%s"
-1502 "  : "
 1503 "  : %s"
 1504 "  "
 1505 "GDATA DUMP BEGIN"
@@ -1474,7 +1463,6 @@
 1954 "<a class=\"credits\" href=\""
 1955 "Sourcecode"
 1956 "footer.html"
-1957 "group="
 1958 "help-admin-en.txt"
 1959 "  : left=%ld"
 1965 "host=%s port=%s"
@@ -1497,7 +1485,6 @@
 1985 "(more)"
 1986 "<th class=\"right\">%.1f</th>\n"
 1988 "<td class=\"right\">%.1f</td>\n"
-1990 "traffic="
 1993 " (ssl)"
 1994 "SSL Error %ld:%s"
 1995 "Cant Create SSL context"
@@ -1545,11 +1532,7 @@
 2090 "rget"
 2091 "size"
 2092 "tvol"
-2093 "%s=%s"
 2094 "<a%s title=\"%s\" href=\"/?"
-2095 "traffic"
-2096 "1"
-2097 "order"
 2098 "\">%s</a>"
 2099 " class=\"head\""
 2100 "sort by pack-Nr."
@@ -1558,17 +1541,13 @@
 2103 "sort by size of file"
 2104 "sort by traffic"
 2105 "sort by group"
-2106 "order="
-2108 "%2x"
-2109 "%a, %d %b %Y %T %Z"
 2110 "<form action=\"\" method=\"post\">\n"
 2111 "%s&nbsp;\n"
 2112 "Search"
-2113 "<input type=\"text\" name=\"search\" value=\"%s\" size=30>&nbsp;\n"
+2113 "<input type=\"text\" name=\"s\" value=\"%s\" size=30>&nbsp;\n"
 2114 "<input type=\"submit\" name=\"submit\" value=\" %s \">\n"
 2115 "</form>\n"
 2116 "<br>\n"
-2117 "search="
 2126 "\2**\2 Request listing:   \"/MSG %s XDCC LIST\" \2**\2"
 2127 "\2**\2 Request listing:   \"/MSG %s XDCC LIST group\" \2**\2"
 2128 "\2**\2 Stop listing:      \"/MSG %s XDCC STOP\" \2**\2"
@@ -1586,7 +1565,6 @@
 2154 "Added you to the idle queue for pack %u (\"%s\") in position %u. To Remove yourself at "
 2155 "Upload still running"
 2166 "%Y-%m-%d %H:%M"
-2167 "DCC IP: %s NAT=%u"
 2168 "RELOCK"
 2169 "old-password password"
 2170 "Lock all packs with <old-password> with <password>"
@@ -1732,7 +1710,6 @@
 2479 "NEWANN"
 2480 "ANNOUNCE for the last <n> packs in all joined channels"
 2483 "IP From UPnP = %s"
-2525 ";"
 2526 "DEBUG: |%d| %s"
 2537 "CHCOLOR"
 2538 "n [m] x[,b][,s]"
@@ -1799,13 +1776,12 @@
 2602 "  Ignoring added file: %s"
 2603 "  Ignoring queued file: %s"
 2604 "Configured for %s but running on %s?!?"
-2610 "COMMAND %s running: %ld ms"
 2612 "NOANNOUNCE"
 2613 "Disables all announces for next <x> minutes"
 2614 " has been"
 2616 "HTTP connection country blocked"
 2621 "  Ignoring bad filename: %s"
-2622 "\1DCC CHAT CHAT %s %s\1"
+2622 "DCC CHAT CHAT %s %s"
 2623 "DCC passive Chat denied, use \"/MSG %s ADMIN password CHATME\" instead."
 2630 "Forced quit on %s: %s"
 2631 "** %s: %s\n"
@@ -1820,8 +1796,6 @@
 2654 "Cancel Request for bot <nick>"
 2655 "DELTRIGGER"
 2656 "Delete trigger for pack <n> to <m>"
-2660 "-"
-2661 "%d/%b/%Y:%T %Z"
 2662 "%s - - [%s] \"%s\" %u %ld\n"
 2663 "DISKFREE"
 2664 "Shows free space in upload directory"
@@ -1832,7 +1806,6 @@
 2694 "DCC Send Denied, %s"
 2695 "DCC Send Denied (%s) from %s on %s"
 2696 "no uploaddir"
-2698 "\2%s\2%s%s"
 2699 "Announced %s%s%s%s%s"
 2700 "\2%u\2%s%s"
 2701 "Announced %u%s%s"
@@ -1869,3 +1842,33 @@
 2774 ", File %s"
 2775 "Upload: Nick %s"
 2776 "Couldn't Set TCP_NODELAY"
+2777 "RUBY"
+2778 "method [args]"
+2779 "Call a method in the ruby_script with parameters <args>"
+2780 "Try Specifying a ruby method"
+2781 "ruby method failed."
+2782 "(console)"
+2783 "(DCC Chat: %s)"
+2784 " (network: %s)"
+2785 "(MSG: %s)"
+2786 "ADMIN %s requested %s"
+2787 "ADMIN %s"
+2788 "Unable to resolve server %s on %s "
+2789 "(status=0x%.8X)"
+2790 "(%s)"
+2791 "(status=0x%.8X, %s: %d)"
+2792 "Iroffer was blocked for %lims"
+2793 " running: %ld ms"
+2794 "Startup"
+2795 "** Removed From Queue: %s"
+2796 "OFFLINE"
+2797 "Close given network or all networks"
+2798 "ONLINE"
+2799 "Connect to given network or to all networks"
+2800 "DCC IP: %s NAT=%u OFFLINE=%u"
+2801 "NOTICE: HOLDQUEUE is on, no new transfers are started."
+2802 "IQSEND"
+2803 "Push entry from idle queue into main queue"
+2804 "  ^- [%s country=%s]"
+2805 "\2%s\2%s%s%s%s"
+2806 "%s:%ld %s is not encrypted!"
Index: exemple.config
===================================================================
RCS file: /usr/home/public/iroffer/exemple.config,v
retrieving revision 1.7
retrieving revision 1.15
diff -u -r1.7 -r1.15
--- exemple.config	10 Feb 2011 18:31:33 -0000	1.7
+++ exemple.config	17 Jul 2011 19:10:21 -0000	1.15
@@ -2,10 +2,12 @@
 ##                       iroffer 1.4.b03 config file                        ##
 ##           les lignes commençant par "#" ou vident sont ignorées          ##
 ##############################################################################
+
 # Version de ce fichier :
 #
-# $Id: exemple.config,v 1.7 2011/02/10 18:31:33 cvs Exp $
+# $Id: exemple.config,v 1.15 2011/07/17 19:10:21 cvs Exp $
 #
+
 ##############################################################################
 ##                                  FILES                                   ##
 ##############################################################################
@@ -37,7 +39,7 @@
 ###                            - log stats -                               ###
 ### Écrit les statistiques/informations du bot. Ces informations peuvent   ###
 ### être envoyées par dcc chat s'il est actif.                             ###
-#logstats yes
+logstats yes
 
 ##############################################################################
 ###                             - state file -                             ###
@@ -89,7 +91,7 @@
 ### Ecrit xdcclistfile en format DOS, avec CRLF comme saut de ligne.       ###
 ### Valeur par défaut : non          sur CYGWIN Valeur par défaut : oui    ###
 #dos_text_files yes
-dos_text_files no
+#dos_text_files no
 
 ##############################################################################
 ###                          - send listfile -                             ###
@@ -97,7 +99,7 @@
 ### Une valeur de -1, envoie un fichier liste xdcc sans créer de pack.     ###
 ### Valeur par défaut : désactivé                                          ###
 #send_listfile 1
-#send_listfile -1
+send_listfile -1
 
 ##############################################################################
 ###                           - xdcc xml file -                            ###
@@ -147,8 +149,8 @@
 ### Utiliser "::" ou "0.0.0.0" pour autoriser n'importe quelle adresse IP. ###
 ### Utiliser "::1" ou "127.0.0.1" pour limiter l'accès à localhost.        ###
 ### Valeur par défaut : désactivé.                                         ###
-#http_vhost ::
-#http_vhost 0.0.0.0
+http_vhost ::
+http_vhost 0.0.0.0
 
 ##############################################################################
 ###                            - http admin -                              ###
@@ -195,7 +197,7 @@
 ###                            - http search -                             ###
 ### Permet les recherches dans une page HTML.                              ###
 ### Valeur par défaut : désactivé.                                         ###
-#http_search
+http_search
 
 ##############################################################################
 ###                            - http index -                              ###
@@ -221,16 +223,16 @@
 ##############################################################################
 ###                           - weblist info -                             ###
 ### Afficher des informations supplémentaires dans la page HTML.           ###
-#weblist_info uptime "Temps de connexion"
+weblist_info uptime "Temps de connexion"
 #weblist_info running "Temps de connexion Total"
 #weblist_info minspeed "Vitesse Mini"
 #weblist_info maxspeed "Vitesse Maxi"
-#weblist_info cap "Bande-passante Maxi"
+weblist_info cap "Bande-passante Maxi"
 #weblist_info record "Record Bande-passante"
 #weblist_info send "Record download"
-#weblist_info daily "Trafic jour"
-#weblist_info weekly "Trafic semaine"
-#weblist_info monthly "Trafic mois"
+weblist_info daily "Trafic jour"
+weblist_info weekly "Trafic semaine"
+weblist_info monthly "Trafic mois"
 
 ##############################################################################
 ###                            - mime type -                               ###
@@ -250,8 +252,9 @@
 ### Utiliser "::" ou "0.0.0.0" pour autoriser n'importe quelle adresse IP. ###
 ### Utiliser "::1" ou "127.0.0.1" pour limiter l'accès à localhost.        ###
 ### Valeur par défaut : désactivé.                                         ###
-#telnet_vhost ::1
-#telnet_vhost 127.0.0.1
+telnet_vhost ::1
+telnet_vhost 127.0.0.1
+
 
 ##############################################################################
 ##                                   IRC                                    ##
@@ -285,7 +288,7 @@
 ###                          personnalisé de commandes, voir proxyinfo     ###
 ###                          pour plus d'informations.                     ###
 ### la plupart des gens préfèrent utiliser direct.                         ###
-connectionmethod direct
+#connectionmethod direct
 
 ##############################################################################
 ###                       - custom connection info -                       ###
@@ -296,6 +299,12 @@
 #proxyinfo blah blah
 
 ##############################################################################
+###                       - server connect timeout -                       ###
+### Set the starting timeout in seconds on connect to the IRC-server.      ###
+### Ce paramètre est définit par réseau. Valeur par défaut : 5             ###
+#server_connect_timeout 10
+
+##############################################################################
 ###                         - onjoin information -                         ###
 ### Utiliser server_join_raw pour envoyer des commandes IRC sur le serveur ###
 ### une fois connecté (envoyé après Nick, USER, avant MODE).               ###
@@ -436,6 +445,7 @@
 #channel #chan04 -plist 14 -pformat full -joinmsg "!voiceme"
 #channel #chan04 -plist 14 -pformat full -fish secret
 
+
 # 1er Réseau
 network rizon.net
 {
@@ -460,7 +470,7 @@
 ##############################################################################
 ###                           - no auto rejoin -                           ###
 ### Ne pas rejoindre le chan quand le bot est kické.                       ###
-#noautorejoin
+noautorejoin
 
 ##############################################################################
 ###                          - reconnect delay -                           ###
@@ -507,13 +517,16 @@
 ###                           - TCP buffer size -                          ###
 ### Set the Networkbuffer for TCP connection to the given value in kByte.  ###
 ### Default: 0 = the operating system default.                             ###
-#tcp_buffer_size 128
+### On CYGWIN the default is 372                                           ###
+#tcp_buffer_size 372
 
 ##############################################################################
 ###                            - TCP no delay -                            ###
 ### Disable the Nagle buffering algorithm in TCP.                          ###
 ### The operating system will not optimze the size of each TCP packet.     ###
-#tcp_nodelay
+### Valeur par défaut : non          sur CYGWIN Valeur par défaut : oui    ###
+#tcp_nodelay no
+#tcp_nodelay yes
 
 ##############################################################################
 ###                       - override unix loginname -                      ###
@@ -554,7 +567,8 @@
 ### Combien l'auto-ignore doit-il être stricte ? autoignore_threshold est  ###
 ### le nombre moyen de sec entre 2 requêtes ce qui va déclencher un        ###
 ### auto-ignore. Par défaut 10 secondes/requête.                           ###
-autoignore_threshold 10
+#autoignore_threshold 10
+
 
 ##############################################################################
 ##                                   xdcc                                   ##
@@ -577,11 +591,6 @@
 
 ##############################################################################
 ###                        - ignore duplicate ip -                         ###
-### détecte les host truquées et coupe les transferts pour le même hôte.   ###
-#ignoreduplicateip
-
-##############################################################################
-###                        - ignore duplicate ip -                         ###
 ### Détecte les faux hostmasks et annule les multiples transferts pour le  ###
 ### même host et ignore l'user pour X heures.                              ###
 ### Valeur par défaut : 0 == pas de vérification                           ###
@@ -659,6 +668,13 @@
 include_subdirs
 
 ##############################################################################
+###                     - subdirs delayed -                                ###
+### When configured, addir, addnew, and autoadd will scan subdirs later.   ###
+### This keeps the bot responsive if you have a huge directory tree.       ###
+### Default: off, subdirectories are scanned immediatly.                   ###
+subdirs_delayed
+
+##############################################################################
 ###                     - remove lost files -                              ###
 ### Si un fichier n'est plus accessible sur le serveur il sera enlevé.     ###
 ### ATTENTION ! Dans un mauvais répertoire cela effacera tous les packs.   ###
@@ -679,31 +695,31 @@
 ###                        - auto default group -                          ###
 ### Quand on ajoute un nouveau fichier, cherche pour un nom correspondant  ###
 ### et l'ajoute dans le même groupe.                                       ###
-#auto_default_group
+auto_default_group
 
 ##############################################################################
 ###                          - auto path group -                           ###
 ### Quand on ajoute un nouveau fichier, cherche pour un répertoire         ###
 ### correspondant et l'ajoute dans le même groupe.                         ###
-#auto_path_group
+auto_path_group
 
 ##############################################################################
 ###                        - auto crc check -                              ###
 ### Quand on ajoute un fichier, vérifie le crc32 donné dans le nom.        ###
-#auto_crc_check
+auto_crc_check
 
 ##############################################################################
 ###                   - crc exclude pattern -                              ###
 ### auto crc check ignorera les fichiers correspondant à ces critères.     ###
-#autocrc_exclude *.torrent
-#autocrc_exclude *.xdelta
+autocrc_exclude *.torrent
+autocrc_exclude *.xdelta
 
 ##############################################################################
 ###                 - adddir exclude pattern -                             ###
 ### Quand configuré, adddir, addnew et autoadd ignoreront tous les         ###
 ### fichiers correspondant à ces critères.                                 ###
-#adddir_exclude *.txt
-#adddir_exclude *.md5
+adddir_exclude *.txt
+adddir_exclude *.md5
 
 ##############################################################################
 ###                   - adddir min size -                                  ###
@@ -731,6 +747,12 @@
 announce_seperator " - "
 
 ##############################################################################
+###                       - announce size -                                ###
+### Print size of pack on announce.                                        ###
+### Default: no                                                            ###
+#announce_size
+
+##############################################################################
 ###                      - auto add time -                                 ###
 ### Le bot vérifie de nouveaux fichiers dans autoadd_dir toutes les (sec). ###
 ### Valeur par défaut : 0 = désactivé.                                     ###
@@ -795,6 +817,13 @@
 #autoadd_color 0,0,1
 
 ##############################################################################
+###                   - announce suffix color -                            ###
+### Set color for the instructions suffix in the announce message.         ###
+### This will print the text "/MSG <botname> XDCC GET <nr>" in color.      ###
+### Default no color.                                                      ###
+#announce_suffix_color 0,0,1
+
+##############################################################################
 ###                      - auto add sort -                                 ###
 ### Si définit, tous les packs ajoutés seront trié selon l'ordre donné     ###
 ### Les packs existants doivent déjà être triés de la même façon.          ###
@@ -888,11 +917,13 @@
 ##############################################################################
 ###                      - channel !list command -                         ###
 ### Si défini, iroffer répondra aux demandes de !list envoyé à un chan.    ###
+### Cette option peut être globale ou par réseau.                          ###
 respondtochannellist
 
 ##############################################################################
 ###                      - channel !list text -                            ###
 ### Texte qui est mis en réponse à chaque !list sur un chan.               ###
+### Cette option peut être globale ou par réseau.                          ###
 #respondtochannellistmsg Liste des packs sur " http://www.exemple.fr/ "
 
 ##############################################################################
@@ -1206,6 +1237,7 @@
 ### Si vous voulez qu'iroffer envoie des messages de manière périodique    ###
 ### afin d'indexer ou dans un autre but, utilisez periodicmsg :            ###
 ### "periodicmsg <nick> <nbre minutes> <message ...>                       ###
+### This setting is only per network. Multiple lines per net allowed.      ###
 #periodicmsg nick 10 index me
 
 ##############################################################################
@@ -1310,7 +1342,7 @@
 ###                             - max upspeed -                            ###
 ### Vous pouvez définir un max KB/sec qui sera uploadé sur le réseau.      ###
 ### Valeur par défaut : pas de limite.                                     ###
-max_upspeed 100
+max_upspeed 1000
 
 ##############################################################################
 ###                          - hide OS information -                       ###
@@ -1322,7 +1354,7 @@
 ###                        - log notices/messages -                        ###
 ### Si défini, iroffer notera les notices et/ou messages dans le msglog.   ###
 #lognotices
-#logmessages
+logmessages
 
 ##############################################################################
 ###                      - logfile notices/messages -                      ###
@@ -1447,3 +1479,4 @@
 ##############################################################################
 ##                                    Fin                                   ##
 ##############################################################################
+
Index: fr.txt
===================================================================
RCS file: /usr/home/public/iroffer/fr.txt,v
retrieving revision 1.33
retrieving revision 1.53
diff -u -r1.33 -r1.53
--- fr.txt	9 Feb 2011 06:20:05 -0000	1.33
+++ fr.txt	21 Jul 2011 10:40:08 -0000	1.53
@@ -241,9 +241,6 @@
 243 ","
 244 "** Commande absente, essayez encore ! **"
 245 "** Commande non reconnue, essayez \"HELP\" **"
-246 "ADMIN %s demandé (console)"
-247 "ADMIN %s demandé (DCC Chat : %s) (réseau : %s)"
-248 "ADMIN %s demandé (MSG : %s) (réseau : %s)"
 249 "-- %s Commandes --"
 250 "Info"
 251 "Transfert"
@@ -550,7 +547,7 @@
 575 "Impossible de créer le socket, Abandon : %s"
 576 "Impossible de lier le socket, Abandon : %s"
 577 "Impossible d'écouter, Abandon : %s"
-578 "\1DCC CHAT CHAT %s\1"
+578 "DCC CHAT CHAT %s"
 579 "DCC CHAT envoyé à %s sur %s, Attente de connexion sur %s"
 580 "Erreur d'Acceptation, Abandon : %s"
 581 "connexion DCC CHAT reçue, authentification"
@@ -608,13 +605,10 @@
 640 "essaye"
 641 "Select a renvoyé l'erreur : %s"
 642 "avait"
-643 "Impossible de résoudre le serveur %s (status=0x%.8X)"
 644 "host non trouvé"
 645 "pas d'adresse IP."
 646 "Nom de serveur non récupérable."
 647 "réessayer plus tard"
-648 "Impossible de résoudre le serveur %s (%s)"
-649 "Impossible de résoudre le serveur %s (status=0x%.8X, %s : %d)"
 650 "exit"
 651 "signalé"
 652 "gettimeofday() échoué ! %s\n"
@@ -625,7 +619,6 @@
 657 "Impossible de déterminer l'état de la connexion : %s sur %s"
 658 "Connexion au Serveur échouée : %s sur %s"
 659 "Connexion au Serveur  %s Etablit, Logging In"
-660 "Impossible de définir le Blocage"
 661 "notre IP = "
 662 "Impossible d'obtenir notre IP sur %s"
 663 "Erreur de résolution du serveur %s sur %s"
@@ -698,22 +691,22 @@
 741 " :"
 743 "Auto ignore activé pour %s (%s) pendant %i%c%i%c"
 744 ". De nouveaux messages vont augmenter la durée."
-748 " : Utiliser CTCP CLIENTINFO <COMMAND> pour obtenir des informations supplémentaires spécifiques.\1"
+748 " : Utiliser CTCP CLIENTINFO <COMMAND> pour obtenir des informations supplémentaires spécifiques."
 749 "PING"
-750 "\1CLIENTINFO PING retourne les arguments qu'il reçoit\1"
+750 "CLIENTINFO PING retourne les arguments qu'il reçoit"
 751 "DCC"
-752 "\1CLIENTINFO DCC demande un DCC pour une discussion ou un transfert de fichiers\1"
+752 "CLIENTINFO DCC demande un DCC pour une discussion ou un transfert de fichiers"
 753 "VERSION"
-754 "\1CLIENTINFO VERSION montre les informations sur la version de ce client\1"
+754 "CLIENTINFO VERSION montre les informations sur la version de ce client"
 755 "XDCC"
-756 "\1CLIENTINFO XDCC LIST|SEND liste et DCC fichier(s) vers vous\1"
+756 "CLIENTINFO XDCC LIST|SEND liste et DCC fichier(s) vers vous"
 757 "UPTIME"
-758 "\1CLIENTINFO UPTIME vous montre depuis combien de temps le bot tourne.\1"
+758 "CLIENTINFO UPTIME vous montre depuis combien de temps le bot tourne."
 759 "[CTCP] %s in %s : CLIENTINFO"
 763 " "
 764 "[CTCP] %s sur %s : PING"
-767 "\1VERSION iroffer-dinoex "
-768 "\1"
+767 "VERSION iroffer-dinoex "
+768 ""
 769 "[CTCP] %s sur %s : VERSION"
 773 "[CTCP] %s sur %s : UPTIME"
 777 "[CTCP] %s sur %s : STATUS"
@@ -797,7 +790,6 @@
 892 " demandé"
 893 "** Envoi du pack #%u (\"%s\")"
 894 "%s, sa taille est de %sB. (Résume supporté)"
-896 "d\1"
 898 "unlimitedhost trouvé : %s (%s sur %s)"
 899 "** XDCC INFO interdit, désactivé dans la configuration **"
 905 "Interdit (queue/doublon) : "
@@ -808,7 +800,7 @@
 910 "La file d'attente de %u items est pleine, Réessayez plus tard"
 911 "Mis en Attente (slot)"
 912 "Ajouté à la file d'attente pour le pack %u (\"%s\") en position %u. Pour annuler "
-913 "plus tard tapez \"/MSG %s XDCC REMOVE\"."
+913 "plus tard tapez \"/MSG %s XDCC REMOVE %u\"."
 914 " (Bande passante faible)"
 915 " (manuel)"
 916 "QUEUED SEND%s : %s (%s sur %s), Pack #%u"
@@ -1070,13 +1062,12 @@
 1385 "(%li secondes restantes jusqu'au TIMEOUT)"
 1386 "En dessous de la vitesse mini requise, %2.1fK/sec est inférieur à %2.1fK/sec"
 1387 "Vous allez être punis pour votre lenteur"
-1388 "** Enlevé de la file d'attente : Vous avez été puni pour votre lenteur **"
 1390 "Punish-ignore activé pour (%s sur %s) (%s) %u minutes"
 1391 "Punish-ignore activé pour %s (%s) %u minutes"
 1392 "Cant Stat Upload File '%s' : %s"
 1393 "File Error, File couldn't be opened for writing"
 1394 "File Error, That filename already exists"
-1395 "\1DCC RESUME %s %d %"
+1395 "DCC RESUME %s %d %"
 1396 "Cant Access Upload File '%s': %s"
 1397 "Couldn't Bind Virtual Host, Sorry"
 1398 "Couldn't Connect"
@@ -1130,7 +1121,6 @@
 1485 "Pointer 0x%8.8lX not found in meminfo database while trying to free !!"
 1486 "Please report this error to Dinoex dinoex@dinoex.net"
 1488 "Aborting Program ! (core file should be generated)"
-1489 "adminpass is not encrypted !"
 1490 "Trace %3i  %-20s %-16s:%5i  %lu.%06lu"
 1491 "UNKNOWN"
 1492 "<undef>"
@@ -1143,7 +1133,6 @@
 1499 "[%d]: %s"
 1500 "="
 1501 "=%s"
-1502 "  : "
 1503 "  : %s"
 1504 "  "
 1505 "GDATA DUMP BEGIN"
@@ -1474,7 +1463,6 @@
 1954 "<a class=\"credits\" href=\""
 1955 "Sourcecode"
 1956 "footer.html"
-1957 "group="
 1958 "help-admin-fr.txt"
 1959 "  : left=%ld"
 1965 "host=%s port=%s"
@@ -1497,7 +1485,6 @@
 1985 "(more)"
 1986 "<th class=\"right\">%.1f</th>\n"
 1988 "<td class=\"right\">%.1f</td>\n"
-1990 "traffic="
 1993 " (ssl)"
 1994 "Erreur SSL %ld :%s"
 1995 "Impossible de Créer un contexte SSL"
@@ -1545,11 +1532,7 @@
 2090 "rget"
 2091 "size"
 2092 "tvol"
-2093 "%s=%s"
 2094 "<a%s title=\"%s\" href=\"/?"
-2095 "traffic"
-2096 "1"
-2097 "order"
 2098 "\">%s</a>"
 2099 " class=\"head\""
 2100 "Trié par numéro de pack."
@@ -1558,17 +1541,13 @@
 2103 "Trié par taille de fichier"
 2104 "Trié par trafic"
 2105 "Trié par groupe"
-2106 "order="
-2108 "%2x"
-2109 "%a, %d %b %Y %T %Z"
 2110 "<form action=\"\" method=\"post\">\n"
 2111 "%s&nbsp;\n"
 2112 "Search"
-2113 "<input type=\"text\" name=\"search\" value=\"%s\" size=30>&nbsp;\n"
+2113 "<input type=\"text\" name=\"s\" value=\"%s\" size=30>&nbsp;\n"
 2114 "<input type=\"submit\" name=\"submit\" value=\" %s \">\n"
 2115 "</form>\n"
 2116 "<br>\n"
-2117 "search="
 2126 "\2**\2 Demander le Listing :       \"/MSG %s XDCC LIST\" \2**\2"
 2127 "\2**\2 Demander le Listing :       \"/MSG %s XDCC LIST group\" \2**\2"
 2128 "\2**\2 Arrêté le Listing :         \"/MSG %s XDCC STOP\" \2**\2"
@@ -1586,7 +1565,6 @@
 2154 "Ajouté à la file d'attente d'inactivité du Pack %u (\"%s\") en position %u. Pour vous retirer à "
 2155 "Upload toujours en cours"
 2166 "%d-%m-%Y - %H:%M - Pack"
-2167 "Ip du DCC Chat : %s NAT=%u"
 2168 "RELOCK"
 2169 "ancien_password password"
 2170 "Bloque tous les packs avec <ancien_password> par <password>"
@@ -1732,7 +1710,6 @@
 2479 "NEWANN"
 2480 "ANNONCE le(s) dernier(s) <n> packs dans tous les chans joint"
 2483 "IP From UPnP = %s"
-2525 ";"
 2526 "DEBUG: |%d| %s"
 2537 "CHCOLOR"
 2538 "n [m] x[,b][,s]"
@@ -1799,13 +1776,12 @@
 2602 "  Ignore ajout fichier : %s"
 2603 "  Ignore fichier en queue : %s"
 2604 "Configuré pour %s mais tourne sur %s ?!?"
-2610 "COMMANDE %s exécutée : %ld ms"
 2612 "NOANNOUNCE"
 2613 "Désactive toutes les annonces pour les <x> prochaines minutes"
 2614 " a été"
 2616 "HTTP connection country blocked"
 2621 "  Ignore mauvais nom de fichier : %s"
-2622 "\1DCC CHAT CHAT %s %s\1"
+2622 "DCC CHAT CHAT %s %s"
 2623 "DCC Chat passif interdit, utilisez \"/MSG %s ADMIN password CHATME\" à la place."
 2630 "Forcer le quit sur %s: %s"
 2631 "** %s: %s\n"
@@ -1820,8 +1796,6 @@
 2654 "Annule la demande pour le bot <nick>"
 2655 "DELTRIGGER"
 2656 "Efface le trigger du pack <n> à <m>"
-2660 "-"
-2661 "%d/%b/%Y:%T %Z"
 2662 "%s - - [%s] \"%s\" %u %ld\n"
 2663 "DISKFREE"
 2664 "Voir l'espace libre du répertoire d'upload"
@@ -1832,7 +1806,6 @@
 2694 "DCC Send Refusé, %s"
 2695 "DCC Send Refusé (%s) de %s sur %s"
 2696 "no uploaddir"
-2698 "\2%s\2%s%s"
 2699 "Announced %s%s%s%s%s"
 2700 "\2%u\2%s%s"
 2701 "Announced %u%s%s"
@@ -1869,3 +1842,33 @@
 2774 ", Fichier %s"
 2775 "Upload: Nick %s"
 2776 "Couldn't Set TCP_NODELAY"
+2777 "RUBY"
+2778 "method [args]"
+2779 "Call a method in the ruby_script with parameters <args>"
+2780 "Try Specifying a ruby method"
+2781 "ruby method failed."
+2782 "(console)"
+2783 "(DCC Chat : %s)"
+2784 " (réseau : %s)"
+2785 "(MSG: %s)"
+2786 "ADMIN %s demandé %s"
+2787 "ADMIN %s"
+2788 "Impossible de résoudre le serveur %s on %s "
+2789 "(status=0x%.8X)"
+2790 "(%s)"
+2791 "(status=0x%.8X, %s: %d)"
+2792 "Iroffer was blocked for %lims"
+2793 " exécutée : %ld ms"
+2794 "Startup"
+2795 "** Enlevé de la file d'attente : %s"
+2796 "OFFLINE"
+2797 "Close given network or all networks"
+2798 "ONLINE"
+2799 "Connect to given network or to all networks"
+2800 "Ip du DCC : %s NAT=%u OFFLINE=%u"
+2801 "NOTICE: HOLDQUEUE is on, no new transfers are started."
+2802 "IQSEND"
+2803 "Push entry from idle queue into main queue"
+2804 "  ^- [%s country=%s]"
+2805 "\2%s\2%s%s%s%s"
+2806 "%s:%ld %s is not encrypted !"
Index: header.html
===================================================================
RCS file: /usr/home/public/iroffer/header.html,v
retrieving revision 1.30
retrieving revision 1.31
diff -u -r1.30 -r1.31
--- header.html	13 Dec 2010 08:05:54 -0000	1.30
+++ header.html	20 Feb 2011 16:34:58 -0000	1.31
@@ -1,7 +1,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
-<meta name="generator" content="iroffer-dinoex 3.26, iroffer.dinoex.net">
+<meta name="generator" content="iroffer-dinoex 3.27, iroffer.dinoex.net">
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <link rel="icon" href="/favicon.ico">
 <link rel="stylesheet" type="text/css" href="iroffer-state.css">
Index: it.txt
===================================================================
RCS file: /usr/home/public/iroffer/it.txt,v
retrieving revision 1.236
retrieving revision 1.260
diff -u -r1.236 -r1.260
--- it.txt	9 Feb 2011 06:20:05 -0000	1.236
+++ it.txt	21 Jul 2011 10:40:08 -0000	1.260
@@ -241,9 +241,6 @@
 243 ","
 244 "** Comando perso, riprova"
 245 "** Comando non riconosciuto, prova con \"HELP\""
-246 "ADMIN %s Richiesto (console)"
-247 "ADMIN %s Richiesto (DCC Chat: %s) (network: %s)"
-248 "ADMIN %s Richiesto (MSG: %s) (network: %s)"
 249 "-- Comandi %s --"
 250 "Info"
 251 "Trasferimenti"
@@ -373,7 +370,7 @@
 389 "  Chat stabilita con %s. Sto aspettando la password."
 390 "  Chat stabilita con %s."
 391 "Stato della DCC CHAT insapettato %u"
-392 "  Connesso a %s"
+392 "  Connesso il %s"
 393 "  Ultimo contatto %s"
 394 "  Locale: %s, Remoto: %s"
 396 "Ti sto disconnettendo."
@@ -550,7 +547,7 @@
 575 "Non posso creare un Socket, sto annullando: %s"
 576 "Non posso impegnare il Socket, sto annullando: %s"
 577 "Impossibile stare in ascolto, sto annullando: %s"
-578 "\1DCC CHAT CHAT %s\1"
+578 "DCC CHAT CHAT %s"
 579 "DCC CHAT inviata a %s su %s, attendo la connessione com %s"
 580 "Errore nell'accettare, sto annullando: %s"
 581 "DCC CHAT connessione ricevuta, in autenticazione"
@@ -608,13 +605,10 @@
 640 "prova"
 641 "Seleziona un errore restituito: %s"
 642 "avuto"
-643 "Impossibile trovare il server %s (status=0x%.8X)"
 644 "Host non trovato"
 645 "Nessun indirizzo IP"
 646 "Nome server non recuperabile"
 647 "Riprova ancora"
-648 "Impossibile trovare il server %s (%s)"
-649 "Impossibile trovare il server %s (status=0x%.8X, %s: %d)"
 650 "uscita"
 651 "segnalato"
 652 "gettimeofday() fallito! %s\n"
@@ -625,7 +619,6 @@
 657 "Non riesco a determinare lo stato di connessione: %s on %s"
 658 "COnnessione al server fallita: %s on %s"
 659 "Connessione al server %s stabilita. Mi sto loggando"
-660 "Non posso settare il Blocking"
 661 "ourip = "
 662 "Impossibile recuperare ourip su %s"
 663 "Errore nel rintracciare il server %s su %s"
@@ -698,22 +691,22 @@
 741 ":"
 743 "Auto-ignore attivato per %s (%s) per i prossimi %i%c%i%c"
 744 ". Ulteriori messaggi ricevuti ne incrementeranno la durata."
-748 ":Usa CTCP CLIENTINFO <COMMAND> per ottenere maggiori informazioni\1"
+748 ":Usa CTCP CLIENTINFO <COMMAND> per ottenere maggiori informazioni"
 749 "PING"
-750 "\1CLIENTINFO PING restituisce le informazioni richieste\1"
+750 "CLIENTINFO PING restituisce le informazioni richieste"
 751 "DCC"
-752 "\1CLIENTINFO DCC richiede una DCC per chattare o trasferire files\1"
+752 "CLIENTINFO DCC richiede una DCC per chattare o trasferire files"
 753 "VERSION"
-754 "\1CLIENTINFO VERSION mostra le informazioni inerenti alla versione del client\1"
+754 "CLIENTINFO VERSION mostra le informazioni inerenti alla versione del client"
 755 "XDCC"
-756 "\1CLIENTINFO XDCC LIST|SEND ti mostra la LISTA o ti invia i files tramite DCC (SEND)\1"
+756 "CLIENTINFO XDCC LIST|SEND ti mostra la LISTA o ti invia i files tramite DCC (SEND)"
 757 "UPTIME"
-758 "\1CLIENTINFO UPTIME mostra da quanto tempo è avviato il client\1"
+758 "CLIENTINFO UPTIME mostra da quanto tempo è avviato il client"
 759 "[CTCP] %s in %s: CLIENTINFO"
 763 " "
 764 "[CTCP] %s on %s: PING"
-767 "\1VERSION Iroffer CWLabs ITA by CreeW 2010 "
-768 "\1"
+767 "VERSION Iroffer CWLabs ITA by CreeW 2010 "
+768 ""
 769 "[CTCP] %s on %s: VERSION"
 773 "[CTCP] %s on %s: UPTIME"
 777 "[CTCP] %s on %s: STATUS"
@@ -748,8 +741,8 @@
 815 "ADMIN: %s non è abilitato ad usare comandi da ADMIN"
 816 "Hostname ADMIN sbagliato (%s on %s)"
 822 "** XDCC LIST negata. %s"
-823 "Attenti il listing pubblico in chan."
-826 "Sono troppo occupati al momento, riprova tra un pò"
+823 "Attendi il listing pubblico in chan."
+826 "Sono troppo occupato al momento, riprova tra un pò"
 827 "ALL"
 829 "XDLGROUP %s"
 831 "ignorato"
@@ -797,7 +790,6 @@
 892 "richiesto"
 893 "** Ti sto inviando il pack #%u (\"%s\")"
 894 "%s, che ha grandezza %sB. (ripresa download supportata)"
-896 "d\1"
 898 "trovato host illimitato: %s (%s on %s)"
 899 "** XDCC INFO negato, disabilitato nella configurazione"
 905 "Negato (coda/doppio)"
@@ -808,7 +800,7 @@
 910 "La coda principale di grandezza %u è piena. Riprova dopo"
 911 "Accodato (slot)"
 912 "Aggiunto alla coda principale per il pack %u (\"%s\") in posizione %u. Per rimuoverti dalla coda "
-913 "invia \"/MSG %s XDCC REMOVE\"."
+913 "invia \"/MSG %s XDCC REMOVE %u\"."
 914 " (low bandwidth)"
 915 " (manual)"
 916 "QUEUED SEND%s: %s (%s on %s), Pack #%u"
@@ -1070,13 +1062,12 @@
 1385 "(%li secondi rimanenti prima del timeout)"
 1386 "Sei al di sotto della Velocità Minima Richiesta, %2.1fK/sec è minore di %2.1fK/sec"
 1387 "Sei stato punito per la tua lentezza"
-1388 "** Rimosso Dalla Coda: Sei stato punito per la tua lentezza."
 1390 "Punish-ignore attivato per (%s on %s) (%s) %u minuti"
 1391 "Punish-ignore attivato per %s (%s) %u minuti"
 1392 "Impossibile verificare lo Stato del file di Upload '%s': %s"
 1393 "File Error, il file non può essere aperto per scrittura"
 1394 "File Error, questo nome di file è gia esistente"
-1395 "\1DCC RESUME %s %d %"
+1395 "DCC RESUME %s %d %"
 1396 "Impossibile Accedere al file di Upload '%s': %s"
 1397 "Impossibile impegnare il Virtual Host, Mi Dispiace"
 1398 "Impossibile Connettersi"
@@ -1130,7 +1121,6 @@
 1485 "Puntatore 0x%8.8lX non trovato nel database meminfo mentre si tentava di liberare!!"
 1486 "Perfavore riporta questo errore all'amministratore"
 1488 "Chiusura Programma! (il core file dovrebbe essere generato)"
-1489 "la password di admin non è criptata!"
 1490 "Trace %3i  %-20s %-16s:%5i  %lu.%06lu"
 1491 "UNKNOWN"
 1492 "<undef>"
@@ -1143,7 +1133,6 @@
 1499 "[%d]: %s"
 1500 "="
 1501 "=%s"
-1502 "  : "
 1503 "  : %s"
 1504 "  "
 1505 "GDATA DUMP BEGIN"
@@ -1474,7 +1463,6 @@
 1954 "<a class=\"credits\" href=\""
 1955 "Sourcecode"
 1956 "footer.html"
-1957 "group="
 1958 "help-admin-it.txt"
 1959 "  : left=%ld"
 1965 "host=%s porta=%s"
@@ -1497,7 +1485,6 @@
 1985 "(more)"
 1986 "<th class=\"right\">%.1f</th>\n"
 1988 "<td class=\"right\">%.1f</td>\n"
-1990 "traffic="
 1993 " (ssl)"
 1994 "SSL Error %ld:%s"
 1995 "Non posso creare il contesto SSL"
@@ -1545,11 +1532,7 @@
 2090 "rget"
 2091 "size"
 2092 "tvol"
-2093 "%s=%s"
 2094 "<a%s title=\"%s\" href=\"/?"
-2095 "traffic"
-2096 "1"
-2097 "order"
 2098 "\">%s</a>"
 2099 " class=\"head\""
 2100 "Ordina per numero pack"
@@ -1558,17 +1541,13 @@
 2103 "Ordina per grandezza file"
 2104 "Ordina per traffico"
 2105 "Ordina per guuppo"
-2106 "ordine="
-2108 "%2x"
-2109 "%a, %d %b %Y %T %Z"
 2110 "<form action=\"\" method=\"post\">\n"
 2111 "%s&nbsp;\n"
 2112 "Search"
-2113 "<input type=\"text\" name=\"search\" value=\"%s\" size=30>&nbsp;\n"
+2113 "<input type=\"text\" name=\"s\" value=\"%s\" size=30>&nbsp;\n"
 2114 "<input type=\"submit\" name=\"submit\" value=\" %s \">\n"
 2115 "</form>\n"
 2116 "<br>\n"
-2117 "search="
 2126 "\2**\2 Per richiedere la lista:    \"/MSG %s XDCC LIST\" \2**\2"
 2127 "\2**\2 Per richiedere la lista di un gruppo:    \"/MSG %s XDCC LIST gruppo\" \2**\2"
 2128 "\2**\2 Per richiedere lo stop del Listing: \"/MSG %s XDCC STOP\" \2**\2"
@@ -1586,7 +1565,6 @@
 2154 "Sei stato aggiunto alla coda per il pack %u (\"%s\") in posizione %u. Per rimuoverti "
 2155 "Upload ancora in corso"
 2166 "%Y-%m-%d %H:%M"
-2167 "IP in DCC CHAT: %s NAT=%u"
 2168 "RELOCK"
 2169 "vecchia-password password"
 2170 "Riblocca tutti i packs con la <vecchia-password>, con la nuova <password>"
@@ -1732,7 +1710,6 @@
 2479 "NEWANN"
 2480 "Annuncia gli ultimi <n> pacchi in tutti i canali"
 2483 "IP Da UPnP = %s"
-2525 ";"
 2526 "DEBUG: |%d| %s"
 2537 "CHCOLOR"
 2538 "n [m] x[,b][,s]"
@@ -1799,13 +1776,12 @@
 2602 "  Ignoro il file aggiunto: %s"
 2603 "  Ignoro il file in coda: %s"
 2604 "Configurato per %s ma non si sta utilizzando %s?!?"
-2610 "COMMAND %s running: %ld ms"
 2612 "NOANNOUNCE"
 2613 "Annunci disabilitati per i prossimi <x> minuti"
 2614 " sono stati"
 2616 "HTTP Connessione Nazione bloccata"
 2621 "  Ignoro il nome file errato: %s"
-2622 "\1DCC CHAT CHAT %s %s\1"
+2622 "DCC CHAT CHAT %s %s"
 2623 "DCC passive Chat negata, usa il comando \"/MSG %s ADMIN password CHATME \"."
 2630 "Uscita forzata su %s: %s"
 2631 "** %s: %s\n"
@@ -1820,8 +1796,6 @@
 2654 "Cancella le richieste al bot dal <Nick>"
 2655 "DELTRIGGER"
 2656 "Cancella il trigger per i pacchi da <n> a <m>"
-2660 "-"
-2661 "%d/%b/%Y:%T %Z"
 2662 "%s - - [%s] \"%s\" %u %ld\n"
 2663 "DISKFREE"
 2664 "Mostra lo spazio libero nella cartella upload"
@@ -1832,7 +1806,6 @@
 2694 "DCC SEND negato, %s"
 2695 "DCC SEND negato (%s) da %s su %s"
 2696 "no uploaddir"
-2698 "\2%s\2%s%s"
 2699 "Annunciato %s%s%s%s%s"
 2700 "\2%u\2%s%s"
 2701 "Annunciato %u%s%s"
@@ -1850,13 +1823,13 @@
 2747 "Disabilita AUTOADD per i prossimi <x> minuti"
 2749 "** %s disabilitati per i prossimi %u %s"
 2751 "Access Log"
-2752 "Admin Job Done"
+2752 "Admin Job Eseguito"
 2753 "XDCC Remove"
 2754 "Log"
 2755 "Configfile"
 2757 "("
 2758 "RMALLQ"
-2759 "Removes entries from idle and main queue"
+2759 "Rimuove tutte le voci dalla coda attiva e dalla coda inattiva"
 2760 "n [channel] [net]"
 2766 "RUBY %s"
 2767 "%s "
@@ -1868,4 +1841,34 @@
 2773 ", Recv %"
 2774 ", File %s"
 2775 "Upload: Nick %s"
-2776 "Couldn't Set TCP_NODELAY"
+2776 "Non posso settare il TCP_NODELAY"
+2777 "RUBY"
+2778 "parametro [args]"
+2779 "Richiama una funzione nel ruby_script con parametro <args>"
+2780 "Prova a specificare una funzione ruby"
+2781 "funzione ruby fallita."
+2782 "(console)"
+2783 "(DCC Chat: %s)"
+2784 " (network: %s)"
+2785 "(MSG: %s)"
+2786 "ADMIN %s Richiesto %s"
+2787 "ADMIN %s"
+2788 "Impossibile trovare il server %s su %s "
+2789 "(status=0x%.8X)"
+2790 "(%s)"
+2791 "(status=0x%.8X, %s: %d)"
+2792 "Iroffer Ã¨ stato bloccato %lims"
+2793 " avviato: %ld ms"
+2794 "Partenza"
+2795 "** Rimosso Dalla Coda: %s"
+2796 "OFFLINE"
+2797 "Chiudi il network indicato o tutti i networks"
+2798 "ONLINE"
+2799 "Connetti al network indicato o a tutti i networks"
+2800 "IP in DCC: %s NAT=%u OFFLINE=%u"
+2801 "NOTICE: HOLDQUEUE Ã¨ attivo, non sarÃ  avviato alcun trasferimento."
+2802 "IQSEND"
+2803 "Sposta il prossimo invio dalla coda secondaria a quella primaria"
+2804 "  ^- [%s country=%s]"
+2805 "\2%s\2%s%s%s%s"
+2806 "%s:%ld %s la password non è criptata!"
Index: ruby-sample.rb
===================================================================
RCS file: /usr/home/public/iroffer/ruby-sample.rb,v
retrieving revision 1.19
retrieving revision 1.22
diff -u -r1.19 -r1.22
--- ruby-sample.rb	29 Jan 2011 10:45:02 -0000	1.19
+++ ruby-sample.rb	8 Apr 2011 06:43:30 -0000	1.22
@@ -28,7 +28,7 @@
   def on_privmsg
     write_log( "PRIVMSG from", hostmask, "in", channel, "on", network, message )
 
-    # trigger on text
+    # trigger on text somewhere in the message
     if /iroffer-dinoex/.match( message )
       msg = "Thanks for using iroffer."
       # send text to user
@@ -39,15 +39,15 @@
       mode( channel, "+v " + nick )
     end
 
-    # trigger on text
-    if /!autoadd/.match( message )
+    # trigger on exact text
+    if message == '!autoadd'
       # execute admin command
-      command( "msg", config[ "owner_nick" ], "!autoadd was triggered" )
+      command( "msg", irconfig( "owner_nick" ), "!autoadd was triggered" )
       command( "autoadd" )
     end
 
-    # trigger on text
-    if /!hop/.match( message )
+    # trigger on exact text
+    if message == '!hop'
       # execute admin command
       command( "HOP", channel, network )
     end
@@ -86,7 +86,9 @@
     end
     text << " CRC "
     text << crc
-    text << " - /MSG mybot XDCC SEND "
+    text << " - /MSG "
+    text << mynick
+    text << "XDCC SEND "
     text << added_pack.to_s
     text << "\""
     command( "AMSG", text )
Index: sample.config
===================================================================
RCS file: /usr/home/public/iroffer/sample.config,v
retrieving revision 1.253
retrieving revision 1.262
diff -u -r1.253 -r1.262
--- sample.config	10 Feb 2011 18:31:33 -0000	1.253
+++ sample.config	17 Jul 2011 19:10:21 -0000	1.262
@@ -5,14 +5,13 @@
 
 # Version of this file:
 #
-# $Id: sample.config,v 1.253 2011/02/10 18:31:33 cvs Exp $
+# $Id: sample.config,v 1.262 2011/07/17 19:10:21 cvs Exp $
 #
 
 ##############################################################################
 ##                                  FILES                                   ##
 ##############################################################################
 
-
 ##############################################################################
 ###                             - pid file -                               ###
 ### Writes the process id to this file on startup                          ###
@@ -91,7 +90,7 @@
 ##############################################################################
 ###                         - dos text files -                             ###
 ### Write xdcclistfile as DOS text format, with CRLF als line break.       ###
-### Default: no, on CYGWIN default: yes                                    ###
+### Default: no, on CYGWIN Default: yes                                    ###
 #dos_text_files yes
 #dos_text_files no
 
@@ -273,7 +272,6 @@
 ### The found certificate is passed to the server on connect.              ###
 #network irc.efnet.net
 
-
 ##############################################################################
 ###                          - connection method -                         ###
 ### How should iroffer connect to the irc server.  Choices are:            ###
@@ -302,6 +300,13 @@
 #proxyinfo blah blah
 
 ##############################################################################
+###                       - server connect timeout -                       ###
+### Set the starting timeout in seconds on connect to the IRC-server.      ###
+### This setting can only be set per network.                              ###
+### Default: 5                                                             ###
+#server_connect_timeout 10
+
+##############################################################################
 ###                         - onjoin information -                         ###
 ### you can use server_join_raw to send raw IRC commands to the server     ###
 ### when connected (sent after NICK, USER, before MODE )                   ###
@@ -428,7 +433,7 @@
 ###              respondtochannellistmsg.                                  ###
 ### rgroup:      Users in this channel can only access packs in groups     ###
 ###              group1 or group2, or packs in main pool.                  ###
-### notrigger:   No trigegrs are active in this channel.                   ###
+### notrigger:   No triggers are active in this channel.                   ###
 ### plaintext:   Disable colors when announcing for this channel.          ###
 ### waitjoin:    Wait given seconds after connect before joining this      ###
 ###              channel.                                                  ###
@@ -444,7 +449,6 @@
 
 
 # 1st Network
-
 network rizon.net
 {
 server irc.rizon.net
@@ -452,7 +456,6 @@
 }
 
 # 2nd Network
-
 network otakubox.at
 {
 server irc.otakubox.at 6667
@@ -469,7 +472,7 @@
 ##############################################################################
 ###                           - no auto rejoin -                           ###
 ### Do not rejoin channel when bots is kicked.                             ###
-#noautorejoin
+noautorejoin
 
 ##############################################################################
 ###                          - reconnect delay -                           ###
@@ -517,13 +520,16 @@
 ###                           - TCP buffer size -                          ###
 ### Set the Networkbuffer for TCP connection to the given value in kByte.  ###
 ### Default: 0 = the operating system default.                             ###
-#tcp_buffer_size 128
+### On CYGWIN the default is 372                                           ###
+#tcp_buffer_size 372
 
 ##############################################################################
 ###                            - TCP no delay -                            ###
 ### Disable the Nagle buffering algorithm in TCP.                          ###
 ### The operating system will not optimze the size of each TCP packet.     ###
-#tcp_nodelay
+### Default: no, on CYGWIN Default: yes                                    ###
+#tcp_nodelay no
+#tcp_nodelay yes
 
 ##############################################################################
 ###                       - override unix loginname -                      ###
@@ -566,6 +572,7 @@
 ### auto-ignore.  The default is 10 seconds/request.                       ###
 #autoignore_threshold 10
 
+
 ##############################################################################
 ##                                   xdcc                                   ##
 ##############################################################################
@@ -588,7 +595,7 @@
 ###                        - ignore duplicate ip -                         ###
 ### Detect faked hostmasks and abort multiple transfers to the same host   ###
 ### and ignore the user for the give time in hours.                        ###
-### default: 0 == no check.                                                ###
+### Default: 0 == no check.                                                ###
 #ignore_duplicate_ip 24
 
 ##############################################################################
@@ -612,7 +619,7 @@
 ### When a user is done using a slot, the next file retrieved from the     ###
 ### queue would NOT be a file queued by the same user. This helps to       ###
 ### distribute the bandwidth better in bots with few slots.                ###
-### default: first in, first out                                           ###
+### Default: first in, first out                                           ###
 balanced_queue
 
 ##############################################################################
@@ -624,7 +631,7 @@
 ##############################################################################
 ###                          - send batch -                                ###
 ### Permit XDCC BATCH. The packs are Queued up in the bot is possible.     ###
-### default: disabled                                                      ###
+### Default: disabled                                                      ###
 send_batch
 
 ##############################################################################
@@ -662,6 +669,13 @@
 include_subdirs
 
 ##############################################################################
+###                     - subdirs delayed -                                ###
+### When configured, addir, addnew, and autoadd will scan subdirs later.   ###
+### This keeps the bot responsive if you have a huge directory tree.       ###
+### Default: off, subdirectories are scanned immediatly.                   ###
+#subdirs_delayed
+
+##############################################################################
 ###                     - remove lost files -                              ###
 ### if a files is no longer accessible on the server, remove the pack.     ###
 ### use with care, if started in wrong dir it may delete all packs.        ###
@@ -669,8 +683,8 @@
 
 ##############################################################################
 ###                        - monitor files -                               ###
-### check only given number of files per second for removal or update.     ###
-### default: 20
+### Check only given number of files per second for removal or update.     ###
+### Default: 20                                                            ###
 #monitor_files 20
 
 ##############################################################################
@@ -682,32 +696,32 @@
 ###                        - auto default group -                          ###
 ### When adding a new file, search for matching filenames and add the new  ###
 ### file to the same group.                                                ###
-#auto_default_group
+auto_default_group
 
 ##############################################################################
 ###                          - auto path group -                           ###
 ### When adding a new file, search for matching directories and add the    ###
 ### new file to the same group.                                            ###
-#auto_path_group
+auto_path_group
 
 ##############################################################################
 ###                        - auto crc check -                              ###
 ### When adding a new file, verify the crc32 in the given filename.        ###
-#auto_crc_check
+auto_crc_check
 
 ##############################################################################
 ###                   - crc exclude pattern -                              ###
 ### When configured, auto crc check will ignore files matching this        ###
 ### patterns.                                                              ###
-#autocrc_exclude *.torrent
-#autocrc_exclude *.xdelta
+autocrc_exclude *.torrent
+autocrc_exclude *.xdelta
 
 ##############################################################################
 ###                 - adddir exclude pattern -                             ###
 ### When configured, addir, adnew and autoadd will skip all files or dirs  ###
 ### that match this patterns.                                              ###
-#adddir_exclude *.txt
-#adddir_exclude *.md5
+adddir_exclude *.txt
+adddir_exclude *.md5
 
 ##############################################################################
 ###                   - adddir min size -                                  ###
@@ -736,6 +750,12 @@
 announce_seperator " - "
 
 ##############################################################################
+###                       - announce size -                                ###
+### Print size of pack on announce.                                        ###
+### Default: no                                                            ###
+#announce_size
+
+##############################################################################
 ###                      - auto add time -                                 ###
 ### Time in seconds when the bot checks for new files in autoadd_dir.      ###
 ### Default: 0 = disabled.                                                 ###
@@ -827,7 +847,6 @@
 ### Default: use natural sort order.                                       ###
 #no_natural_sort
 
-
 ##############################################################################
 ###                  - restrict xdcc list and xdcc send -                  ###
 ### if set, xdcc list and/or xdcc send|info will be restricted to users    ###
@@ -898,11 +917,13 @@
 ###                      - channel xdcc commands -                         ###
 ### if set, iroffer will respond to xdcc requests sent to a channel in     ###
 ### addition to xdcc requests sent to iroffer directly.                    ###
+### This setting can be global or per network.                             ###
 #respondtochannelxdcc
 
 ##############################################################################
 ###                      - channel !list command -                         ###
 ### if set, iroffer will respond to !list requests sent to a channel       ###
+### This setting can be global or per network.                             ###
 respondtochannellist
 
 ##############################################################################
@@ -943,27 +964,27 @@
 ### with a pattern that contains at least <n> non wild cards chars         ###
 ### wild cards are:                                                        ###
 ###  * = 0 or more characters,  ? = 1 character,  # = any positive integer ###
-### default: 0 = no response at all                                        ###
-#atfind 3
+### Default: 0 = no response at all                                        ###
+atfind 3
 
 ##############################################################################
 ###                         - no find trigger -                            ###
 ### Iroffer will respond to "!find" too if atfind is defined.              ###
 ### This flag will make the bot ignore "!find".                            ###
-### default: response to "!find"                                           ###
+### Default: response to "!find"                                           ###
 #no_find_trigger
 
 ##############################################################################
 ###                           - new trigger -                              ###
 ### iroffer will respond to "!new" requests sent to a channel.             ###
 ### It will respond with latest <n> packs added.                           ###
-### default: 0 = no response at all                                        ###
+### Default: 0 = no response at all                                        ###
 #new_trigger 3
 
 ##############################################################################
 ###                             - max find -                               ###
 ### Limit matches to @find and XDCC SEARCH commands.                       ###
-### default: 0 = no limit.                                                 ###
+### Default: 0 = no limit.                                                 ###
 #max_find 100
 
 ##############################################################################
@@ -1056,6 +1077,7 @@
 ### Default: no lookups for IPv6.                                          ###
 #geoip6database GeoIPv6.dat
 
+
 ##############################################################################
 ##                               Network Usage                              ##
 ##############################################################################
@@ -1221,6 +1243,7 @@
 ### if you want iroffer to periodically msg some nick for indexing or some ###
 ### other purpose use periodicmsg in the form:                             ###
 ### "periodicmsg <nick> <num minutes> <message ...>                        ###
+### This setting is only per network. Multiple lines per net allowed.      ###
 #periodicmsg nick 10 index me
 
 ##############################################################################
@@ -1247,7 +1270,7 @@
 ### 3 = add and change                                                     ###
 ### 4 = remove packs                                                       ###
 ### 5 = full, may rename or removes files on disk                          ###
-### default: 5                                                             ###
+### Default: 5                                                             ###
 #adminlevel 4
 
 ##############################################################################
@@ -1267,7 +1290,7 @@
 ###                     - remote half admin level -                        ###
 ### Limit remote half admin commands to level.                             ###
 ### Values see adminlevel                                                  ###
-### default: 2                                                             ###
+### Default: 2                                                             ###
 #hadminlevel 3
 
 ##############################################################################
@@ -1325,7 +1348,7 @@
 ###                             - max upspeed -                            ###
 ### You can set a maximum KB/sec that will be uploaded over the network.   ###
 ### Default: no limit.                                                     ###
-max_upspeed 100
+max_upspeed 1000
 
 ##############################################################################
 ###                          - hide OS information -                       ###
Index: debian/changelog
===================================================================
RCS file: /usr/home/public/iroffer/debian/changelog,v
retrieving revision 1.20
retrieving revision 1.21
diff -u -r1.20 -r1.21
--- debian/changelog	30 Jan 2011 20:27:00 -0000	1.20
+++ debian/changelog	20 Feb 2011 16:34:58 -0000	1.21
@@ -1,3 +1,7 @@
+iroffer-dinoex (3.27-1) unstable; urgency=low
+
+  * Update to 3.27
+
 iroffer-dinoex (3.26~beta32-0~maverickfiras1) maverick; urgency=low
 
   * New upstream beta release.
Index: debian/copyright
===================================================================
RCS file: /usr/home/public/iroffer/debian/copyright,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- debian/copyright	30 Jan 2011 20:27:00 -0000	1.5
+++ debian/copyright	13 Jul 2011 02:47:36 -0000	1.6
@@ -12,7 +12,8 @@
 	Copyright (C) 2004-2009 Dirk Meyer <dinoex@dinoex.net>
 	Copyright (C) 1997 by Paul Kocher
 	Copyright (C) 2000 Bryan Call <bc@fodder.org>
-	Copyright (c) 2005-2007, Thomas BERNARD
+	Copyright (C) 2005-2007, Thomas BERNARD
+	Copyright (C) 2000,2004 Martin Pool
 
 License:	
 
@@ -29,21 +30,24 @@
 be found at /usr/share/common-licenses/GPL-2
 
 
-src/iroffer*.[ch], README-iroffer.txt, dynip.sh, iroffer.cron
+src/iroffer*.[ch], dynip.sh, iroffer.cron
 are copyrighted by David Johnson (PMG) under GPL2 below.
 
-Configure, Makefile.config, sample.config are written by
+Configure, sample.config are written by
 David Johnson (PMG) and where extended by Dirk Meyer.
 These files are under GPL2 below.
 
 src/plumb_md5.[ch] was written by Colin Plumb in 1993 and modified
 by Ian Jackson in 1995, this files are in the public domain.
 
-src/crc32.c is copyrighted by Bryan Call under GPL2 or later.
+src/crc32.c is written by 1986 Gary S. Brown and in the public domain.
 
 src/blowfish.[ch] are copyrighted 1997 by Paul Kocher
 and released under LGPL 2.1. On Ubuntu systems, the full text
 of the LGPL 2.1 can be found at /usr/share/common-licenses/LGPL-2.1
+ 
+src/strnatcmp.[ch] are copyrighted 2000, 2004 by Martin Pool
+and released under MIT License.
 
 src/upnp.[ch] is writen by Thomas Bernard under BSD license.
 
Index: debian/iroffer-dinoex-doc.docs
===================================================================
RCS file: /usr/home/public/iroffer/debian/iroffer-dinoex-doc.docs,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- debian/iroffer-dinoex-doc.docs	30 Jan 2011 20:27:00 -0000	1.1
+++ debian/iroffer-dinoex-doc.docs	13 Jul 2011 02:48:41 -0000	1.2
@@ -1,4 +1,4 @@
-README-iroffer.txt
+README
 THANKS
 TODO
 doc/iroffer.1.txt
Index: debian/iroffer-dinoex.docs
===================================================================
RCS file: /usr/home/public/iroffer/debian/iroffer-dinoex.docs,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- debian/iroffer-dinoex.docs	30 Jan 2011 20:27:00 -0000	1.3
+++ debian/iroffer-dinoex.docs	15 May 2011 05:53:33 -0000	1.4
@@ -1,3 +1,4 @@
 help-admin-en.txt
 README.modDinoex
 doc/INSTALL-linux-en.html
+doc/INSTALL-vhost-en.html
Index: doc/.cvsignore
===================================================================
RCS file: /usr/home/public/iroffer/doc/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- doc/.cvsignore	15 Jan 2011 13:51:26 -0000	1.2
+++ doc/.cvsignore	12 Jun 2011 07:57:25 -0000	1.3
@@ -2,3 +2,10 @@
 iroffer.1.html
 iroffer.1.ps
 iroffer.1.txt
+INSTALL-linux-de.txt
+INSTALL-linux-en.txt
+INSTALL-linux-fr.txt
+INSTALL-linux-it.txt
+INSTALL-vhost-de.txt
+INSTALL-vhost-en.txt
+INSTALL-vhost-fr.txt
Index: doc/INSTALL-vhost-de.html
===================================================================
RCS file: /usr/home/public/iroffer/doc/INSTALL-vhost-de.html,v
retrieving revision 1.10
retrieving revision 1.11
diff -u -r1.10 -r1.11
--- doc/INSTALL-vhost-de.html	25 Jan 2011 06:09:10 -0000	1.10
+++ doc/INSTALL-vhost-de.html	20 Feb 2011 17:40:01 -0000	1.11
@@ -56,7 +56,7 @@
 
 <pre class="indent">
 cd iroffer-dinoex-snap
-./Configure -curl
+./Configure -curl -geoip -ruby
 </pre>
 </li>
 
@@ -158,7 +158,7 @@
 cd httpdocs
 unzip ../iroffer-state217.zip
 touch size.data
-cp iroffer-sample.php index.php
+cp iroffer-sample-de.php index.php
 </pre>
 </li>
 
Index: doc/INSTALL-vhost-fr.html
===================================================================
RCS file: /usr/home/public/iroffer/doc/INSTALL-vhost-fr.html,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -r1.7 -r1.8
--- doc/INSTALL-vhost-fr.html	21 Jan 2011 11:39:47 -0000	1.7
+++ doc/INSTALL-vhost-fr.html	20 Feb 2011 17:40:01 -0000	1.8
@@ -51,7 +51,7 @@
 
 <pre class="indent">
 cd iroffer-dinoex-snap
-./Configure -curl
+./Configure -curl -geoip -ruby
 </pre>
 </li>
 
@@ -145,7 +145,7 @@
 cd httpdocs
 unzip ../iroffer-state217.zip
 touch size.data
-cp iroffer-sample.php index.php
+cp iroffer-sample-fr.php index.php
 </pre>
 </li>
 
Index: gentoo/iroffer-dinoex.ebuild
===================================================================
RCS file: /usr/home/public/iroffer/gentoo/iroffer-dinoex.ebuild,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- gentoo/iroffer-dinoex.ebuild	7 Dec 2010 21:06:01 -0000	1.5
+++ gentoo/iroffer-dinoex.ebuild	13 Jul 2011 03:19:24 -0000	1.6
@@ -1,6 +1,6 @@
 # Copyright 1999-2009 Gentoo Foundation
 # Distributed under the terms of the GNU General Public License v2
-# $Header: /usr/home/public/iroffer/gentoo/iroffer-dinoex.ebuild,v 1.5 2010/12/07 21:06:01 cvs Exp $
+# $Header: /usr/home/public/iroffer/gentoo/iroffer-dinoex.ebuild,v 1.6 2011/07/13 03:19:24 cvs Exp $
 
 DESCRIPTION="An improved version of iroffer - an IRC XDCC bot."
 HOMEPAGE="http://iroffer.dinoex.net"
@@ -112,7 +112,7 @@
 
     dodoc LICENSE
     dodoc LIESMICH.modDinoex
-    dodoc README-iroffer.txt
+    dodoc README
     dodoc README.modDinoex
     dodoc THANKS
     dodoc TODO
Index: htdocs/info.txt.rb
===================================================================
RCS file: /usr/home/public/iroffer/htdocs/info.txt.rb,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- htdocs/info.txt.rb	23 Jan 2011 01:31:02 -0000	1.1
+++ htdocs/info.txt.rb	8 Apr 2011 06:42:13 -0000	1.2
@@ -7,7 +7,7 @@
 now = Time.now.to_s
 
 bot = IrofferEvent.new
-version = bot.config( "version" )
+version = bot.irconfig( "version" )
 
 puts "# Generated by #{version} on #{now}\r"
 
Index: htdocs/md5.txt.rb
===================================================================
RCS file: /usr/home/public/iroffer/htdocs/md5.txt.rb,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- htdocs/md5.txt.rb	23 Jan 2011 01:31:02 -0000	1.1
+++ htdocs/md5.txt.rb	8 Apr 2011 06:42:13 -0000	1.2
@@ -7,7 +7,7 @@
 now = Time.now.to_s
 
 bot = IrofferEvent.new
-version = bot.config( "version" )
+version = bot.irconfig( "version" )
 
 puts "# Generated by #{version} on #{now}\r"
 
Index: htdocs/sfv.txt.rb
===================================================================
RCS file: /usr/home/public/iroffer/htdocs/sfv.txt.rb,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- htdocs/sfv.txt.rb	23 Jan 2011 01:31:02 -0000	1.4
+++ htdocs/sfv.txt.rb	8 Apr 2011 06:42:13 -0000	1.5
@@ -8,7 +8,7 @@
 now = Time.now.to_s
 
 bot = IrofferEvent.new
-version = bot.config( "version" )
+version = bot.irconfig( "version" )
 
 puts "; Generated by #{version} on #{now}\r"
 puts ";\r"
Index: src/dinoex_admin.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_admin.c,v
retrieving revision 1.413
retrieving revision 1.431
diff -u -r1.413 -r1.431
--- src/dinoex_admin.c	6 Feb 2011 01:28:12 -0000	1.413
+++ src/dinoex_admin.c	12 Jul 2011 19:17:53 -0000	1.431
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_admin.c,v 1.413 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_admin.c,v 1.431 2011/07/12 19:17:53 cvs Exp $
  *
  */
 
@@ -62,7 +62,7 @@
   tempstr = mymalloc(maxtextlength);
 
   llen = vsnprintf(tempstr, maxtextlength - 3, format, args);
-  if ((llen < 0) || (llen >= maxtextlength - 3)) {
+  if ((llen < 0) || (llen >= (int)maxtextlength - 3)) {
     outerror(OUTERROR_TYPE_WARN, "string too long!");
     mydelete(tempstr);
     return;
@@ -354,7 +354,7 @@
   s = a_xdl_space();
   for (xd = irlist_get_head(&gdata.xdccs);
        xd;
-       xd = irlist_get_next(xd), i++) {
+       xd = irlist_get_next(xd), ++i) {
     if (hide_locked(u, xd) == 0)
       a_xdl_pack(u, tempstr, i, l, s, xd);
   }
@@ -386,7 +386,7 @@
   xd = irlist_get_head(&gdata.xdccs);
   for (xd = irlist_get_head(&gdata.xdccs);
        xd;
-       xd = irlist_get_next(xd), i++) {
+       xd = irlist_get_next(xd), ++i) {
     if (msg3 == NULL) {
       if (xd->group != NULL)
         continue;
@@ -405,7 +405,7 @@
       continue;
 
     a_xdl_pack(u, tempstr, i, l, s, xd);
-    k++;
+    ++k;
   }
   mydelete(tempstr);
 
@@ -424,7 +424,7 @@
   unsigned int l;
   unsigned int s;
   xdcc *xd;
-  irlist_t grplist = {0, 0};
+  irlist_t grplist = {0, 0, 0};
 
   updatecontext();
 
@@ -438,7 +438,7 @@
   i = 1;
   for (xd = irlist_get_head(&gdata.xdccs);
        xd;
-       xd = irlist_get_next(xd), i++) {
+       xd = irlist_get_next(xd), ++i) {
     /* skip is group is set */
     if (xd->group == NULL) {
       if (hide_locked(u, xd) == 0)
@@ -1214,7 +1214,7 @@
   }
 }
 
-static void a_make_announce(const userinput * const u, const char *cmd, unsigned int n)
+static void a_make_announce(const char *cmd, unsigned int n)
 {
   userinput *ui;
   char *tempstr;
@@ -1224,8 +1224,8 @@
   snprintf(tempstr, maxtextlength, "%s %u", cmd, n); /* NOTRANSLATE */
   a_fillwith_msg2(ui, NULL, tempstr);
   ui->method = method_out_all;  /* just OUT_S|OUT_L|OUT_D it */
-  ui->net = u->net;
-  ui->level = u->level;
+  ui->net = 0;
+  ui->level = ADMIN_LEVEL_AUTO;
   u_parseit(ui);
   mydelete(ui);
   mydelete(tempstr);
@@ -1299,6 +1299,25 @@
   return color;
 }
 
+#ifdef USE_RUBY
+/* perform delayed announce */
+void a_autoaddann(xdcc *xd, unsigned int pack)
+#else
+/* perform delayed announce */
+void a_autoaddann(xdcc * UNUSED(xd), unsigned int pack)
+#endif /* USE_RUBY */
+{
+#ifdef USE_RUBY
+  do_myruby_added(xd->file, pack);
+#endif /* USE_RUBY */
+
+  if (gdata.autoaddann_short)
+    a_make_announce("SANNOUNCE", pack); /* NOTRANSLATE */
+
+  if (gdata.autoaddann)
+    a_make_announce("ANNOUNCE", pack); /* NOTRANSLATE */
+}
+
 static unsigned int check_for_renamed_file(const userinput * const u, xdcc *xd, struct stat *st, char *file)
 {
   char *old;
@@ -1513,17 +1532,8 @@
 
   set_support_groups();
   xd->color = a_get_color(gdata.autoadd_color);
+  ++(xd->announce);
   write_files();
-#ifdef USE_RUBY
-  do_myruby_added(xd->file, n);
-#endif /* USE_RUBY */
-
-  if (gdata.autoaddann_short)
-    a_make_announce(u, "SANNOUNCE", n); /* NOTRANSLATE */
-
-  if (gdata.autoaddann)
-    a_make_announce(u, "ANNOUNCE", n); /* NOTRANSLATE */
-
   return xd;
 }
 
@@ -1847,6 +1857,46 @@
   tr->maxspeed = val;
 }
 
+static int a_qsend_queue(const userinput * const u, irlist_t *list)
+{
+  if (irlist_size(list) == 0) {
+    a_respond(u, "No Users Queued");
+    return 1;
+  }
+
+  if (irlist_size(&gdata.trans) >= gdata.maxtrans) {
+    a_respond(u, "Too many transfers");
+    return 1;
+  }
+  return 0;
+}
+
+void a_qsend(const userinput * const u)
+{
+  unsigned int num = 0;
+
+  updatecontext();
+
+  if (a_qsend_queue(u, &gdata.mainqueue))
+    return;
+
+  if (u->arg1) num = atoi(u->arg1);
+  send_from_queue(2, num, NULL);
+}
+
+void a_iqsend(const userinput * const u)
+{
+  unsigned int num = 0;
+
+  updatecontext();
+
+  if (a_qsend_queue(u, &gdata.idlequeue))
+    return;
+
+  if (u->arg1) num = atoi(u->arg1);
+  check_idle_queue(num);
+}
+
 void a_slotsmax(const userinput * const u)
 {
   unsigned int val;
@@ -1917,6 +1967,24 @@
   a_requeue2(u, &gdata.idlequeue);
 }
 
+static userinput *irlist_add_delayed(const userinput * const u, const char *cmd)
+{
+  userinput *u2;
+
+  u2 = irlist_add(&gdata.packs_delayed, sizeof(userinput));
+  u2->method = u->method;
+  u2->fd = u->fd;
+  u2->chat = u->chat;
+  u2->cmd = mystrdup(cmd);
+  u2->net = u->net;
+  u2->level = u->level;
+
+  if (u->snick != NULL) {
+    u2->snick = mystrdup(u->snick);
+  }
+  return u2;
+}
+
 static unsigned int is_system_dir(const char *name)
 {
   if (strcmp(name, ".") == 0) /* NOTRANSLATE */
@@ -1992,21 +2060,11 @@
       continue;
     }
 
-    u2 = irlist_add(&gdata.packs_delayed, sizeof(userinput));
-    u2->method = u->method;
-    u2->fd = u->fd;
-    u2->chat = u->chat;
-    u2->cmd = mystrdup( "REMOVE" ); /* NOTRANSLATE */
-    u2->net = gnetwork->net;
-    u2->level = u->level;
+    u2 = irlist_add_delayed(u, "REMOVE"); /* NOTRANSLATE */
 
     u2->arg1 = tempstr;
     tempstr = NULL;
 
-    if (u->snick != NULL) {
-      u2->snick = mystrdup(u->snick);
-    }
-
     u2->arg2 = mycalloc(sizeof(struct stat));
     memcpy(u2->arg2, &st, sizeof(struct stat));
   }
@@ -2210,6 +2268,7 @@
   /* clean start */
   gdata.xdccs.size = 0;
   gdata.xdccs.head = NULL;
+  gdata.xdccs.tail = NULL;
 
   while (irlist_size(&old_list) > 0) {
     xdo = irlist_get_head(&old_list);
@@ -2298,7 +2357,7 @@
   struct stat st;
   struct stat *sta;
   char *thefile, *tempstr;
-  irlist_t dirlist = {0, 0};
+  irlist_t dirlist = {0, 0, 0};
 
   updatecontext();
 
@@ -2350,7 +2409,18 @@
         if (gdata.debug > 0)
           a_respond(u, "  Ignoring directory: %s", tempstr);
       } else {
-        a_adddir_sub(u, tempstr, NULL, onlynew, setgroup, match);
+        if (gdata.subdirs_delayed == 0 ) {
+          a_adddir_sub(u, tempstr, NULL, onlynew, setgroup, match);
+        } else {
+          if (setgroup != NULL) {
+            u2 = irlist_add_delayed(u, "ADDGROUP"); /* NOTRANSLATE */
+            u2->arg1 = mystrdup(setgroup);
+            u2->arg2 = mystrdup(tempstr);
+          } else {
+            u2 = irlist_add_delayed(u, "ADDNEW"); /* NOTRANSLATE */
+            u2->arg1 = mystrdup(tempstr);
+          }
+        }
       }
       mydelete(tempstr);
       continue;
@@ -2394,7 +2464,7 @@
            xd = irlist_get_next(xd)) {
         if ((xd->st_dev == st.st_dev) &&
             (xd->st_ino == st.st_ino)) {
-          foundit = 1;
+          ++(foundit);
           if (check_for_renamed_file(u, xd, &st, tempstr)) {
             tempstr = NULL;
             break;
@@ -2414,7 +2484,7 @@
         if ((strcmp(u2->cmd, "ADD") == 0) &&
             (sta->st_dev == st.st_dev) &&
             (sta->st_ino == st.st_ino)) {
-          foundit = 1;
+          ++(foundit);
           a_respond(u, "  Ignoring queued file: %s", tempstr);
           break;
         }
@@ -2446,17 +2516,7 @@
 
   thefile = irlist_get_head(&dirlist);
   while (thefile) {
-    u2 = irlist_add(&gdata.packs_delayed, sizeof(userinput));
-    u2->method = u->method;
-    u2->fd = u->fd;
-    u2->chat = u->chat;
-    u2->cmd = mystrdup( "ADD" ); /* NOTRANSLATE */
-    u2->net = gnetwork->net;
-    u2->level = u->level;
-
-    if (u2->snick != NULL) {
-      u2->snick = mystrdup(u->snick);
-    }
+    u2 = irlist_add_delayed(u, "ADD"); /* NOTRANSLATE */
 
     u2->arg1 = mystrdup(thefile);
 
@@ -4301,7 +4361,7 @@
     qu->q_time = gdata.curtime;
     a_respond(u, "GET %s started for %s on %s",
               qu->q_pack, qu->q_nick, gdata.networks[ qu->q_net ].name);
-    qu->q_state = 1;
+    ++(qu->q_state);
     start_qupload();
     return;
   }
@@ -4585,8 +4645,8 @@
   ch = irlist_add(&(gnetwork->channels), sizeof(channel_t));
   caps(u->arg1);
   ch->name = mystrdup(u->arg1);
-  ch->noannounce = 1;
-  ch->notrigger = 1;
+  ++(ch->noannounce);
+  ++(ch->notrigger);
   ch->nextjoin = gdata.curtime;
   if (u->arg3)
     ch->key = mystrdup(u->arg3);
@@ -4720,11 +4780,10 @@
 {
   if (chat == u->chat) {
     a_respond(u, "Disconnecting yourself.");
-    shutdowndccchat(chat, 1);
   } else {
     writedccchat(chat, 0, "Disconnected due to CLOSEC\n");
-    shutdowndccchat(chat, 1);
   }
+  shutdowndccchat(chat, 1);
 }
 
 void a_closec(const userinput * const u)
@@ -4831,6 +4890,65 @@
   start_sends();
 }
 
+static void a_offline_net(unsigned int net)
+{
+  gnetwork_t *backup;
+
+  backup = gnetwork;
+  gnetwork = &(gdata.networks[net]);
+  quit_server();
+  gnetwork->offline = 1;
+  gnetwork = backup;
+}
+
+void a_offline(const userinput * const u)
+{
+  int val;
+  unsigned int ss;
+
+  updatecontext();
+
+  val = get_network(u->arg1);
+  if (val >= 0) {
+    a_offline_net((unsigned int)val);
+    return;
+  }
+  for (ss=0; ss<gdata.networks_online; ++ss) {
+    a_offline_net(ss);
+  }
+}
+
+void a_online(const userinput * const u)
+{
+  int val;
+  unsigned int ss;
+
+  updatecontext();
+
+  val = get_network(u->arg1);
+  if (val >= 0) {
+    gdata.networks[val].offline = 0;
+    return;
+  }
+  for (ss=0; ss<gdata.networks_online; ++ss) {
+    gdata.networks[ss].offline = 0;
+  }
+}
+
+#ifdef USE_RUBY
+void a_ruby(const userinput * const u)
+{
+  int rc;
+
+  if (invalid_text(u, "Try Specifying a ruby method", u->arg1))
+    return;
+
+  rc = do_myruby_ruby(u);
+  if (rc != 0)
+    a_respond(u, "ruby method failed.");
+}
+#endif /* USE_RUBY */
+
 void a_dump(const userinput * const u)
 {
   dumpgdata();
@@ -4849,7 +4967,7 @@
   tostdout_disable_buffering();
   uninitscreen();
 
-  gdata.background = 1;
+  ++(gdata.background);
   gobackground();
 
   if (gdata.pidfile)
@@ -5029,8 +5147,11 @@
 
   updatecontext();
 
-  if (xd == NULL)
+  if (xd == NULL) {
     xd = irlist_get_nth(&gdata.xdccs, num - 1);
+    if (xd == NULL)
+      return 1;
+  }
 
   if (a_queue_found(u, xd, num))
     return 1;
@@ -5165,10 +5286,11 @@
   char *prefix;
   char *colordesc;
   char *datestr;
-  char *dateprefix;
   char *suffix;
   char *message;
   char *color_suffix;
+  char *sizestrstr;
+  size_t len;
   unsigned int ss;
   unsigned int color;
 
@@ -5182,22 +5304,25 @@
   prefix = mymalloc(maxtextlength);
   suffix = mymalloc(maxtextlength);
   colordesc = xd_color_description(xd);
+  if (msg == NULL) {
+    msg = gdata.autoaddann;
+    if (msg == NULL)
+      msg = "added";
+  }
+  prefix[0] = 0;
+  len = 0;
   if (gdata.show_date_added) {
-    dateprefix = mymalloc(maxtextlengthshort);
     datestr = mymalloc(maxtextlengthshort);
     user_getdatestr(datestr, xd->xtime ? xd->xtime : xd->mtime, maxtextlengthshort - 1);
-    snprintf(dateprefix, maxtextlengthshort - 1, "%s%s%s", /* NOTRANSLATE */
-             gdata.announce_seperator, datestr, gdata.announce_seperator);
+    len += snprintf(prefix + len, maxtextlength - 2 - len, "%s%s", gdata.announce_seperator, datestr); /* NOTRANSLATE */
     mydelete(datestr);
-  } else {
-    dateprefix = mystrdup(gdata.announce_seperator);
   }
-  if (msg == NULL) {
-    msg = gdata.autoaddann;
-    if (msg == NULL)
-      msg = "added";
+  if (gdata.announce_size) {
+    sizestrstr = sizestr(1, xd->st_size);
+    len += snprintf(prefix + len, maxtextlength - 2 - len, "%s[%s]", gdata.announce_seperator, sizestrstr); /* NOTRANSLATE */
+    mydelete(sizestrstr);
   }
-  snprintf(prefix, maxtextlength - 2, "\2%s\2%s%s", msg, dateprefix, colordesc);
+  snprintf(prefix + len, maxtextlength - 2 - len, "%s", gdata.announce_seperator); /* NOTRANSLATE */
   message = mymalloc(maxtextlength);
   color = a_get_color(gdata.announce_suffix_color);
 
@@ -5210,17 +5335,16 @@
     snprintf(suffix, maxtextlength - 2, "/MSG %s XDCC SEND %u",
              get_user_nick(), num);
     color_suffix = color_text(suffix, color);
-    snprintf(message, maxtextlength - 2, "%s%s%s", /* NOTRANSLATE */
-             prefix, gdata.announce_seperator, color_suffix);
+    snprintf(message, maxtextlength - 2, "\2%s\2%s%s%s%s",
+             msg, prefix, colordesc, gdata.announce_seperator, color_suffix);
     if (color_suffix != suffix)
       mydelete(color_suffix);
     a_announce_channels(message, match, xd->group);
     gnetwork = backup;
-    a_respond(u, "Announced %s%s%s%s%s", msg, dateprefix, xd->desc, gdata.announce_seperator, suffix);
+    a_respond(u, "Announced %s%s%s%s%s", msg, prefix, xd->desc, gdata.announce_seperator, suffix);
   }
   gnetwork = backup;
   mydelete(message);
-  mydelete(dateprefix);
   if (colordesc != xd->desc)
     mydelete(colordesc);
   mydelete(suffix);
@@ -5413,7 +5537,7 @@
   if (xd == NULL)
     return;
 
-  a_make_announce(u, "ANNOUNCE", number_of_pack(xd)); /* NOTRANSLATE */
+  a_make_announce("ANNOUNCE", number_of_pack(xd)); /* NOTRANSLATE */
 }
 
 void a_noannounce(const userinput * const u)
@@ -5429,8 +5553,8 @@
 
 void a_restart(const userinput * const UNUSED(u))
 {
-  gdata.needrestart = 1;
-  shutdowniroffer();
+  ++(gdata.needsshutdown);
+  ++(gdata.needrestart);
 }
 
 /* End of File */
Index: src/dinoex_admin.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_admin.h,v
retrieving revision 1.129
retrieving revision 1.133
diff -u -r1.129 -r1.133
--- src/dinoex_admin.h	22 Jan 2011 07:10:11 -0000	1.129
+++ src/dinoex_admin.h	8 Jun 2011 05:06:46 -0000	1.133
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_admin.h,v 1.129 2011/01/22 07:10:11 cvs Exp $
+ * $Id: dinoex_admin.h,v 1.133 2011/06/08 05:06:46 cvs Exp $
  *
  */
 
@@ -34,6 +34,7 @@
 unsigned int group_restricted(const userinput * const u, xdcc *xd);
 
 void a_remove_delayed(const userinput * const u);
+void a_autoaddann(xdcc *xd, unsigned int pack);
 void a_add_delayed(const userinput * const u);
 void a_xdlock(const userinput * const u);
 void a_xdtrigger(const userinput * const u);
@@ -47,6 +48,8 @@
 void a_nomax(const userinput * const u);
 void a_unlimited(const userinput * const u);
 void a_maxspeed(const userinput * const u);
+void a_qsend(const userinput * const u);
+void a_iqsend(const userinput * const u);
 void a_slotsmax(const userinput * const u);
 void a_queuesize(const userinput * const u);
 void a_requeue(const userinput * const u);
@@ -137,6 +140,11 @@
 void a_print(const userinput * const u);
 void a_identify(const userinput * const u);
 void a_holdqueue(const userinput * const u);
+void a_offline(const userinput * const u);
+void a_online(const userinput * const u);
+#ifdef USE_RUBY
+void a_ruby(const userinput * const u);
+#endif /* USE_RUBY */
 void a_dump(const userinput * const u);
 void a_backgroud(const userinput * const u);
 void a_autoadd(const userinput * const u);
Index: src/dinoex_badip.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_badip.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -r1.13 -r1.14
--- src/dinoex_badip.c	5 Feb 2011 11:05:54 -0000	1.13
+++ src/dinoex_badip.c	13 May 2011 16:16:30 -0000	1.14
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_badip.c,v 1.13 2011/02/05 11:05:54 cvs Exp $
+ * $Id: dinoex_badip.c,v 1.14 2011/05/13 16:16:30 cvs Exp $
  *
  */
 
@@ -104,7 +104,7 @@
   b->remoteip = remoteip;
   b->connecttime = gdata.curtime;
   b->lastcontact = gdata.curtime;
-  b->count = 1;
+  ++(b->count);
 }
 
 static void count_badip6(struct in6_addr *remoteip)
@@ -125,7 +125,7 @@
   b->remoteip = *remoteip;
   b->connecttime = gdata.curtime;
   b->lastcontact = gdata.curtime;
-  b->count = 1;
+  ++(b->count);
 }
 
 /* update counters for abusive ips */
Index: src/dinoex_chat.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_chat.c,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -r1.5 -r1.7
--- src/dinoex_chat.c	27 Jun 2010 08:08:14 -0000	1.5
+++ src/dinoex_chat.c	4 Jun 2011 06:45:15 -0000	1.7
@@ -1,6 +1,6 @@
 /*
  * by Dirk Meyer (dinoex)
- * Copyright (C) 2004-2010 Dirk Meyer
+ * Copyright (C) 2004-2011 Dirk Meyer
  *
  * By using this file, you agree to the terms and conditions set
  * forth in the GNU General Public License.  More information is
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_chat.c,v 1.5 2010/06/27 08:08:14 cvs Exp $
+ * $Id: dinoex_chat.c,v 1.7 2011/06/04 06:45:15 cvs Exp $
  *
  */
 
@@ -100,4 +100,92 @@
   return highests;
 }
 
+/* handle chat io events */
+void chat_perform(void)
+{
+  dccchat_t *chat;
+  char tempbuffa[INPUT_BUFFER_LENGTH];
+  int length;
+  int callval_i;
+  int connect_error;
+  int errno2;
+  SIGNEDSOCK int connect_error_len;
+  unsigned int i, j;
+
+  updatecontext();
+  /*----- see if dccchat is sending anything to us ----- */
+  for (chat = irlist_get_head(&gdata.dccchats);
+       chat;
+       chat = irlist_get_next(chat)) {
+    gnetwork = &(gdata.networks[chat->net]);
+    if (chat->status == DCCCHAT_CONNECTING) {
+      if (FD_ISSET(chat->con.clientsocket, &gdata.writeset)) {
+        connect_error_len = sizeof(connect_error);
+        callval_i = getsockopt(chat->con.clientsocket,
+                               SOL_SOCKET, SO_ERROR,
+                               &connect_error, &connect_error_len);
+        if (callval_i < 0) {
+          errno2 = errno;
+          outerror(OUTERROR_TYPE_WARN,
+                   "Couldn't determine dcc connection status on %s: %s",
+                   gnetwork->name, strerror(errno));
+          notice(chat->nick, "DCC Chat Connect Attempt Failed: %s", strerror(errno2));
+          shutdowndccchat(chat, 0);
+          continue;
+        }
+        if (connect_error) {
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+                  "DCC Chat Connect Attempt Failed on %s: %s",
+                  gnetwork->name, strerror(connect_error));
+          notice(chat->nick, "DCC Chat Connect Attempt Failed: %s", strerror(connect_error));
+          shutdowndccchat(chat, 0);
+          continue;
+        }
+        setupdccchatconnected(chat);
+      }
+      continue;
+    }
+    if (chat->status == DCCCHAT_LISTENING) {
+      if (FD_ISSET(chat->con.listensocket, &gdata.readset)) {
+        setupdccchataccept(chat);
+      }
+      continue;
+    }
+    if ((chat->status == DCCCHAT_AUTHENTICATING) ||
+        (chat->status == DCCCHAT_CONNECTED)) {
+      if (FD_ISSET(chat->con.clientsocket, &gdata.readset))  {
+        memset(tempbuffa, 0, INPUT_BUFFER_LENGTH);
+        length = recv(chat->con.clientsocket, &tempbuffa, INPUT_BUFFER_LENGTH, MSG_DONTWAIT);
+        if (length < 1) {
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+                  "DCC Chat Lost on %s: %s",
+                  gnetwork->name,
+                  (length<0) ? strerror(errno) : "Closed");
+           notice(chat->nick, "DCC Chat Lost: %s", (length<0) ? strerror(errno) : "Closed");
+           shutdowndccchat(chat, 0);
+           /* deleted later */
+           continue;
+        }
+        j = strlen(chat->dcc_input_line);
+        for (i=0; i<(unsigned int)length; i++) {
+          if ((tempbuffa[i] == '\n') || (j == (INPUT_BUFFER_LENGTH-1))) {
+            if (j && (chat->dcc_input_line[j-1] == 0x0D)) {
+              j--;
+            }
+            chat->dcc_input_line[j] = '\0';
+            parsedccchat(chat, chat->dcc_input_line);
+            j = 0;
+          } else {
+            chat->dcc_input_line[j] = tempbuffa[i];
+            j++;
+          }
+        }
+        chat->dcc_input_line[j] = '\0';
+      }
+      continue;
+    }
+  }
+  gnetwork = NULL;
+}
+
 /* End of File */
Index: src/dinoex_chat.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_chat.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- src/dinoex_chat.h	27 Jun 2010 08:08:14 -0000	1.4
+++ src/dinoex_chat.h	4 Jun 2011 06:43:34 -0000	1.5
@@ -1,6 +1,6 @@
 /*
  * by Dirk Meyer (dinoex)
- * Copyright (C) 2004-2010 Dirk Meyer
+ * Copyright (C) 2004-2011 Dirk Meyer
  *
  * By using this file, you agree to the terms and conditions set
  * forth in the GNU General Public License.  More information is
@@ -9,12 +9,13 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_chat.h,v 1.4 2010/06/27 08:08:14 cvs Exp $
+ * $Id: dinoex_chat.h,v 1.5 2011/06/04 06:43:34 cvs Exp $
  *
  */
 
 unsigned int dcc_host_password(dccchat_t *chat, char *passwd);
 void chat_writestatus(void);
 int chat_select_fdset(int highests);
+void chat_perform(void);
 
 /* End of File */
Index: src/dinoex_config.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_config.c,v
retrieving revision 1.197
retrieving revision 1.219
diff -u -r1.197 -r1.219
--- src/dinoex_config.c	10 Feb 2011 18:31:33 -0000	1.197
+++ src/dinoex_config.c	21 Jul 2011 10:43:01 -0000	1.219
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_config.c,v 1.197 2011/02/10 18:31:33 cvs Exp $
+ * $Id: dinoex_config.c,v 1.219 2011/07/21 10:43:01 cvs Exp $
  *
  */
 
@@ -34,6 +34,7 @@
   const char *name;
   unsigned int *ivar;
   unsigned int reset;
+  unsigned int dummy;
 } config_bool_typ;
 
 typedef struct {
@@ -49,12 +50,14 @@
   const char *name;
   char **svar;
   unsigned int flags;
+  unsigned int dummy;
 } config_string_typ;
 
 typedef struct {
   const char *name;
   irlist_t *list;
   unsigned int flags;
+  unsigned int dummy;
 } config_list_typ;
 
 typedef struct {
@@ -184,7 +187,34 @@
   return text;
 }
 
-static unsigned int config_sorted_check(config_name_t config_name_f)
+/* validate config and warn if password is not encrypted */
+static void checkadminpass2(const char *key, const char *masterpass)
+{
+#ifndef NO_CRYPT
+  unsigned int err=0;
+  unsigned int i;
+
+  updatecontext();
+
+  if (!masterpass || strlen(masterpass) < 13U) ++err;
+
+  for (i=0; !err && i<strlen(masterpass); ++i) {
+    if (!((masterpass[i] >= 'a' && masterpass[i] <= 'z') ||
+          (masterpass[i] >= 'A' && masterpass[i] <= 'Z') ||
+          (masterpass[i] >= '0' && masterpass[i] <= '9') ||
+          (masterpass[i] == '.') ||
+          (masterpass[i] == '$') ||
+          (masterpass[i] == '/')))
+      ++err;
+  }
+
+  if (err) outerror(OUTERROR_TYPE_CRASH,
+                    "%s:%ld %s is not encrypted!",
+                    current_config, current_line, key);
+#endif /* NO_CRYPT */
+}
+
+static int config_sorted_check(config_name_t config_name_f)
 {
   const char *name1;
   const char *name2;
@@ -212,6 +242,10 @@
   int bin_mid;
   int bin_low;
 
+  if (bin_high == 0)
+    return -1;
+
+  bin_high -= 1;
   bin_low = 0;
   while (bin_low <= bin_high) {
     bin_mid = (bin_low + bin_high) / 2;
@@ -227,8 +261,9 @@
 }
 
 
-static unsigned int config_bool_anzahl = 0;
+static int config_bool_anzahl = 0;
 static config_bool_typ config_parse_bool[] = {
+{"announce_size",          &gdata.announce_size,           0 }, /* NOTRANSLATE */
 {"auto_crc_check",         &gdata.auto_crc_check,          0 }, /* NOTRANSLATE */
 {"auto_default_group",     &gdata.auto_default_group,      0 }, /* NOTRANSLATE */
 {"auto_path_group",        &gdata.auto_path_group,         0 }, /* NOTRANSLATE */
@@ -301,7 +336,12 @@
 {"show_group_of_pack",     &gdata.show_group_of_pack,      0 }, /* NOTRANSLATE */
 {"show_list_all",          &gdata.show_list_all,           0 }, /* NOTRANSLATE */
 {"spaces_in_filenames",    &gdata.spaces_in_filenames,     0 }, /* NOTRANSLATE */
+{"subdirs_delayed",        &gdata.subdirs_delayed,         0 }, /* NOTRANSLATE */
+#if defined(_OS_CYGWIN)
+{"tcp_nodelay",            &gdata.tcp_nodelay,             1 }, /* NOTRANSLATE */
+#else /* _OS_CYGWIN */
 {"tcp_nodelay",            &gdata.tcp_nodelay,             0 }, /* NOTRANSLATE */
+#endif /* _OS_CYGWIN */
 {"timestampconsole",       &gdata.timestampconsole,        0 }, /* NOTRANSLATE */
 #ifdef USE_UPNP
 {"upnp_router",            &gdata.upnp_router,             0 }, /* NOTRANSLATE */
@@ -319,10 +359,7 @@
 
 static int config_find_bool(const char *key)
 {
-  if (config_bool_anzahl > 0) {
-    return config_find_typ(config_name_bool, key, config_bool_anzahl - 1);
-  }
-  return -1;
+  return config_find_typ(config_name_bool, key, config_bool_anzahl);
 }
 
 static int parse_bool_val(const char *key, const char *text)
@@ -394,7 +431,7 @@
 }
 
 
-static unsigned int config_int_anzahl = 0;
+static int config_int_anzahl = 0;
 static config_int_typ config_parse_int[] = {
 {"adddir_min_size",         &gdata.adddir_min_size,         0, 1024, 65000, 0 }, /* NOTRANSLATE */
 {"adminlevel",              &gdata.adminlevel,              1, 5, 1, ADMIN_LEVEL_FULL }, /* NOTRANSLATE */
@@ -438,7 +475,11 @@
 {"smallfilebypass",         &gdata.smallfilebypass,         0, 1024*1024, 1024, 0 }, /* NOTRANSLATE */
 {"start_of_month",          &gdata.start_of_month,          1, 31, 1, 1 }, /* NOTRANSLATE */
 {"status_time_dcc_chat",    &gdata.status_time_dcc_chat,    10, 2000, 1, 120 }, /* NOTRANSLATE */
+#if defined(_OS_CYGWIN)
+{"tcp_buffer_size",         &gdata.tcp_buffer_size,         0, 1024*1024, 1024, 372*1024 }, /* NOTRANSLATE */
+#else /* _OS_CYGWIN */
 {"tcp_buffer_size",         &gdata.tcp_buffer_size,         0, 1024*1024, 1024, 0 }, /* NOTRANSLATE */
+#endif /* _OS_CYGWIN */
 {"tcprangelimit",           &gdata.tcprangelimit,           1024, 65535, 1, 65535 }, /* NOTRANSLATE */
 {"tcprangestart",           &gdata.tcprangestart,           1024, 65530, 1, 0 }, /* NOTRANSLATE */
 #ifndef WITHOUT_TELNET
@@ -454,10 +495,7 @@
 
 static int config_find_int(const char *key)
 {
-  if (config_int_anzahl > 0L) {
-    return config_find_typ(config_name_int, key, config_int_anzahl - 1);
-  }
-  return -1;
+  return config_find_typ(config_name_int, key, config_int_anzahl);
 }
 
 static unsigned int report_no_arg(const char *key, const char *text)
@@ -545,6 +583,7 @@
 static void dump_config_int(void)
 {
   unsigned int i;
+  unsigned int rawval;
 
   for (i = 0; config_parse_int[i].name != NULL; ++i) {
     if (gdata.dump_all == 0) {
@@ -553,7 +592,8 @@
       if (*(config_parse_int[i].ivar) == config_parse_int[i].reset)
         continue;
     }
-    dump_config_int2(config_parse_int[i].name, *(config_parse_int[i].ivar));
+    rawval = *(config_parse_int[i].ivar) / config_parse_int[i].mult;
+    dump_config_int2(config_parse_int[i].name, rawval);
   }
 }
 
@@ -574,7 +614,7 @@
  4 -> adminpass
  */
 
-static unsigned int config_string_anzahl = 0;
+static int config_string_anzahl = 0;
 static config_string_typ config_parse_string[] = {
 {"admin_job_file",          &gdata.admin_job_file,          1 }, /* NOTRANSLATE */
 {"adminpass",               &gdata.adminpass,               4 }, /* NOTRANSLATE */
@@ -648,10 +688,7 @@
 
 static int config_find_string(const char *key)
 {
-  if (config_string_anzahl > 0L) {
-    return config_find_typ(config_name_string, key, config_string_anzahl - 1);
-  }
-  return -1;
+  return config_find_typ(config_name_string, key, config_string_anzahl);
 }
 
 static unsigned int set_config_string(const char *key, char *text)
@@ -675,7 +712,7 @@
                 current_config, current_line, key, text);
        return 0;
      }
-     checkadminpass2(text);
+     checkadminpass2(key, text);
   case 1:
      convert_to_unix_slash(text);
      break;
@@ -776,10 +813,7 @@
 
 static int config_find_list(const char *key)
 {
-  if (config_list_anzahl > 0L) {
-    return config_find_typ(config_name_list, key, config_list_anzahl - 1);
-  }
-  return -1;
+  return config_find_typ(config_name_list, key, config_list_anzahl);
 }
 
 static int get_netmask(char *text, int init)
@@ -1117,7 +1151,11 @@
     autoqueue_t *aq;
     aq = irlist_add(&gdata.autoqueue, sizeof(autoqueue_t));
     rawval = atoi(part[0]);
-    aq->pack = between(0, rawval, 100000);
+    if (rawval == XDCC_SEND_LIST) {
+      aq->pack = XDCC_SEND_LIST;
+    } else {
+      aq->pack = between(0, rawval, 100000);
+    }
     aq->word = part[1];
     aq->message = part[2];
   } else {
@@ -1138,6 +1176,20 @@
   }
 }
 
+static char *p_bandmax(void)
+{
+  char *text;
+
+  text = mymalloc(maxtextlengthshort);
+  snprintf(text, maxtextlengthshort, "%u.0kB/s", gdata.maxb / 4); /* NOTRANSLATE */
+  return text;
+}
+
+static char *p_banduse(void)
+{
+  return get_current_bandwidth();
+}
+
 static void c_channel(const char * UNUSED(key), char *var)
 {
   char *part[2];
@@ -1258,6 +1310,33 @@
   return print_config_long2(gdata.disk_quota);
 }
 
+static off_t get_toffered(void)
+{
+  xdcc *xd;
+  off_t toffered;
+
+  toffered = 0;
+  for (xd = irlist_get_head(&gdata.xdccs);
+       xd;
+       xd = irlist_get_next(xd)) {
+    if (hide_pack(xd))
+      continue;
+
+    toffered += xd->st_size;
+  }
+  return toffered;
+}
+
+static char *p_disk_space(void)
+{
+  return print_config_long2(get_toffered());
+}
+
+static char *p_disk_space_text(void)
+{
+  return sizestr(0, get_toffered());
+}
+
 static void d_disk_quota(const char *key)
 {
   dump_config_mega2(key, gdata.disk_quota);
@@ -1349,6 +1428,11 @@
   }
 }
 
+static char *p_idlequeueused(void)
+{
+  return print_config_long2((ir_int64)(irlist_size(&gdata.idlequeue)));
+}
+
 static void c_ignoreduplicateip(const char * key, char *var)
 {
   int val;
@@ -1436,6 +1520,11 @@
   return mystrdup(gnetwork->login_name);
 }
 
+static char *p_mainqueueused(void)
+{
+  return print_config_long2((ir_int64)(irlist_size(&gdata.mainqueue)));
+}
+
 static void c_mime_type(const char *key, char *var)
 {
   char *split;
@@ -1450,7 +1539,7 @@
   *(split++) = 0;
   mime = irlist_add(&(gdata.mime_type), sizeof(http_magic_t));
   mime->m_ext = mystrdup(var);
-  mime->m_mime = split;
+  mime->m_mime = mystrdup(split);
 }
 
 static void d_mime_type(const char *key)
@@ -1490,7 +1579,7 @@
     if (bracket != NULL) {
       *(bracket++) = 0;
       if (strchr(bracket, '{') != NULL)
-        current_bracket = 1;
+        ++(current_bracket);
     }
     /* check if the given network does exist */
     for (ss=0; ss < MAX_NETWORKS; ++ss) {
@@ -1664,36 +1753,49 @@
             key, gdata.overallmaxspeeddaytimestart, gdata.overallmaxspeeddaytimeend);
 }
 
+static char *p_packsum(void)
+{
+  return print_config_long2((ir_int64)(irlist_size(&gdata.xdccs)));
+}
+
 static void c_periodicmsg(const char *key, char *var)
 {
   char *part[4];
-  unsigned int tnum;
+  periodicmsg_t *pm;
+  unsigned int rawval;
   unsigned int m;
 
-  mydelete(gdata.periodicmsg_nick);
-  mydelete(gdata.periodicmsg_msg);
   m = get_argv(part, var, 3);
-  if (m != 3) {
+  if (m >= 3) {
+    pm = irlist_add(&gdata.periodicmsg, sizeof(periodicmsg_t));
+    rawval = atoi(part[1]);
+    if (rawval < 1)
+      rawval = 1;
+    pm->pm_time = rawval;
+    pm->pm_time = atoi(part[1]);
+    pm->pm_net = current_network;
+    pm->pm_nick = part[0];
+    pm->pm_msg = part[2];
+  } else {
     invalid_args(key, var);
-    mydelete(part[0]);
-    mydelete(part[1]);
     mydelete(part[2]);
-    return;
+    mydelete(part[0]);
   }
-  gdata.periodicmsg_nick = part[0];
-  tnum = atoi(part[1]);
   mydelete(part[1]);
-  gdata.periodicmsg_msg = part[2];
-  gdata.periodicmsg_time = max2(1, tnum);
 }
 
-static void d_periodicmsg(const char *key)
+static void d_periodicmsg(const char *key, unsigned int net)
 {
-  if ((gdata.dump_all == 0) && (gdata.periodicmsg_nick == NULL))
-    return;
+  periodicmsg_t *pm;
 
-  dump_line("%s %s %u \"%s\"", /* NOTRANSLATE */
-            key, gdata.periodicmsg_nick, gdata.periodicmsg_time, gdata.periodicmsg_msg);
+  for (pm = irlist_get_head(&gdata.periodicmsg);
+       pm;
+       pm = irlist_get_next(pm)) {
+    if (pm->pm_net != net)
+      continue;
+    dump_line("%s %s %u \"%s\"", /* NOTRANSLATE */
+              key, pm->pm_nick, pm->pm_time, pm->pm_msg);
+  }
 }
 
 static void c_plaintext(const char *key, char *var)
@@ -1721,6 +1823,36 @@
   irlist_add_string(&gdata.networks[current_network].proxyinfo, var);
 }
 
+static void c_respondtochannellist(const char *key, char *var)
+{
+  int val;
+
+  val = parse_bool_val(key, var);
+  if (val >= 0) {
+    gdata.networks[current_network].respondtochannellist = val;
+  }
+}
+
+static char *p_respondtochannellist(void)
+{
+  return print_config_long2((ir_int64)(gnetwork->respondtochannellist));
+}
+
+static void c_respondtochannelxdcc(const char *key, char *var)
+{
+  int val;
+
+  val = parse_bool_val(key, var);
+  if (val >= 0) {
+    gdata.networks[current_network].respondtochannelxdcc = val;
+  }
+}
+
+static char *p_respondtochannelxdcc(void)
+{
+  return print_config_long2((ir_int64)(gnetwork->respondtochannelxdcc));
+}
+
 static void c_restrictlist(const char *key, char *var)
 {
   int val;
@@ -1790,6 +1922,15 @@
   }
 }
 
+static void c_server_connect_timeout(const char *key, char *var)
+{
+  int rawval;
+
+  if (check_range(key, var, &rawval, CTIMEOUT, 2000) == 0) {
+    gdata.networks[current_network].server_connect_timeout = rawval;
+  }
+}
+
 static void c_server_connected_raw(const char *key, char *var)
 {
   if (var == NULL) {
@@ -1810,6 +1951,17 @@
   irlist_add_string(&gdata.networks[current_network].server_join_raw, var);
 }
 
+static char *p_slotsfree(void)
+{
+  unsigned int slots = 0;
+  unsigned int trans;
+
+  trans = irlist_size(&gdata.trans);
+  if (trans < gdata.slotsmax)
+    slots = gdata.slotsmax - trans;
+  return print_config_long2((ir_int64)slots);
+}
+
 static void c_slotsmax(const char * UNUSED(key), char *var)
 {
   unsigned int ival;
@@ -1833,6 +1985,11 @@
   dump_config_int3(key, gdata.slotsmax, 0);
 }
 
+static char *p_slotsused(void)
+{
+  return print_config_long2((ir_int64)(irlist_size(&gdata.trans)));
+}
+
 static void c_slow_privmsg(const char *key, char *var)
 {
   int rawval;
@@ -1871,6 +2028,14 @@
   dump_config_string3(key, gdata.statefile);
 }
 
+static char *p_totaluptime(void)
+{
+  char *text;
+
+  text = mymalloc(maxtextlengthshort);
+  return getuptime(text, 0, gdata.curtime-gdata.totaluptime, maxtextlengthshort);
+}
+
 static void c_transferlimits(const char * UNUSED(key), char *var)
 {
   char *part[NUMBER_TRANSFERLIMITS];
@@ -1926,6 +2091,31 @@
   dump_config_float2(key, gdata.transferminspeed);
 }
 
+static char *p_transfereddaily(void)
+{
+  return sizestr(0, gdata.transferlimits[TRANSFERLIMIT_DAILY].used);
+}
+
+static char *p_transferedweekly(void)
+{
+  return sizestr(0, gdata.transferlimits[TRANSFERLIMIT_WEEKLY].used);
+}
+
+static char *p_transferedmonthly(void)
+{
+  return sizestr(0, gdata.transferlimits[TRANSFERLIMIT_MONTHLY].used);
+}
+
+static char *p_transferedtotal(void)
+{
+  return sizestr(0, gdata.totalsent);
+}
+
+static char *p_transferedtotalbytes(void)
+{
+  return print_config_long2(gdata.totalsent);
+}
+
 static void c_uploadmaxsize(const char * UNUSED(key), char *var)
 {
   gdata.uploadmaxsize = atoull(var)*1024*1024;
@@ -1956,6 +2146,14 @@
   dump_config_mega2(key, gdata.uploadminspace);
 }
 
+static char *p_uptime(void)
+{
+  char *text;
+
+  text = mymalloc(maxtextlengthshort);
+  return getuptime(text, 1, gdata.startuptime, maxtextlengthshort);
+}
+
 static void c_usenatip(const char * UNUSED(key), char *var)
 {
   gnetwork_t *backup;
@@ -1970,6 +2168,8 @@
 
 static char *p_usenatip(void)
 {
+  if (gnetwork->natip == NULL)
+    return NULL;
   return mystrdup(gnetwork->natip);
 }
 
@@ -2036,10 +2236,13 @@
 {"periodicmsg",            c_periodicmsg }, /* NOTRANSLATE */
 {"plaintext",              c_plaintext }, /* NOTRANSLATE */
 {"proxyinfo",              c_proxyinfo }, /* NOTRANSLATE */
+{"respondtochannellist",   c_respondtochannellist }, /* NOTRANSLATE */
+{"respondtochannelxdcc",   c_respondtochannelxdcc }, /* NOTRANSLATE */
 {"restrictlist",           c_restrictlist }, /* NOTRANSLATE */
 {"restrictsend",           c_restrictsend }, /* NOTRANSLATE */
 {"send_listfile",          c_send_listfile }, /* NOTRANSLATE */
 {"server",                 c_server }, /* NOTRANSLATE */
+{"server_connect_timeout", c_server_connect_timeout }, /* NOTRANSLATE */
 {"server_connected_raw",   c_server_connected_raw }, /* NOTRANSLATE */
 {"server_join_raw",        c_server_join_raw }, /* NOTRANSLATE */
 {"slotsmax",               c_slotsmax }, /* NOTRANSLATE */
@@ -2064,10 +2267,7 @@
 
 static int config_find_func(const char *key)
 {
-  if (config_func_anzahl > 0L) {
-    return config_find_typ(config_name_func, key, config_func_anzahl - 1);
-  }
-  return -1;
+  return config_find_typ(config_name_func, key, config_func_anzahl);
 }
 
 static int set_config_func(const char *key, char *text)
@@ -2087,26 +2287,44 @@
 static int config_fprint_anzahl = 0;
 static config_fprint_typ config_parse_fprint[] = {
 {"auth_name",              p_auth_name }, /* NOTRANSLATE */
+{"bandmax",                p_bandmax }, /* NOTRANSLATE */
+{"banduse",                p_banduse }, /* NOTRANSLATE */
 {"disk_quota",             p_disk_quota }, /* NOTRANSLATE */
+{"disk_space",             p_disk_space }, /* NOTRANSLATE */
+{"disk_space_text",        p_disk_space_text }, /* NOTRANSLATE */
 {"getip_network",          p_getip_network }, /* NOTRANSLATE */
+{"idlequeueused",          p_idlequeueused }, /* NOTRANSLATE */
 {"ignoreduplicateip",      p_ignoreduplicateip }, /* NOTRANSLATE */
 {"local_vhost",            p_local_vhost }, /* NOTRANSLATE */
 {"login_name",             p_login_name }, /* NOTRANSLATE */
 {"logrotate",              p_logrotate }, /* NOTRANSLATE */
+{"mainqueueused",          p_mainqueueused }, /* NOTRANSLATE */
 {"need_level",             p_need_level }, /* NOTRANSLATE */
 {"nickserv_pass",          p_nickserv_pass }, /* NOTRANSLATE */
 {"noannounce",             p_noannounce }, /* NOTRANSLATE */
 {"offline",                p_offline }, /* NOTRANSLATE */
 {"overallmaxspeeddaydays", p_overallmaxspeeddaydays }, /* NOTRANSLATE */
+{"packsum",                p_packsum }, /* NOTRANSLATE */
 {"plaintext",              p_plaintext }, /* NOTRANSLATE */
+{"respondtochannellist",   p_respondtochannellist }, /* NOTRANSLATE */
+{"respondtochannelxdcc",   p_respondtochannelxdcc }, /* NOTRANSLATE */
 {"restrictlist",           p_restrictlist }, /* NOTRANSLATE */
 {"restrictsend",           p_restrictsend }, /* NOTRANSLATE */
 {"send_listfile",          p_send_listfile }, /* NOTRANSLATE */
+{"slotsfree",              p_slotsfree }, /* NOTRANSLATE */
 {"slotsmax",               p_slotsmax }, /* NOTRANSLATE */
+{"slotsused",              p_slotsused }, /* NOTRANSLATE */
 {"slow_privmsg",           p_slow_privmsg }, /* NOTRANSLATE */
 {"statefile",              p_statefile }, /* NOTRANSLATE */
+{"totaluptime",            p_totaluptime }, /* NOTRANSLATE */
+{"transfereddaily",        p_transfereddaily }, /* NOTRANSLATE */
+{"transferedmonthly",      p_transferedmonthly }, /* NOTRANSLATE */
+{"transferedtotal",        p_transferedtotal }, /* NOTRANSLATE */
+{"transferedtotalbytes",   p_transferedtotalbytes }, /* NOTRANSLATE */
+{"transferedweekly",       p_transferedweekly }, /* NOTRANSLATE */
 {"uploadmaxsize",          p_uploadmaxsize }, /* NOTRANSLATE */
 {"uploadminspace",         p_uploadminspace }, /* NOTRANSLATE */
+{"uptime",                 p_uptime }, /* NOTRANSLATE */
 {"usenatip",               p_usenatip }, /* NOTRANSLATE */
 {"user_modes",             p_user_modes }, /* NOTRANSLATE */
 {"user_nick",              p_user_nick }, /* NOTRANSLATE */
@@ -2120,10 +2338,7 @@
 
 static int config_find_fprint(const char *key)
 {
-  if (config_fprint_anzahl > 0L) {
-    return config_find_typ(config_name_fprint, key, config_fprint_anzahl - 1);
-  }
-  return -1;
+  return config_find_typ(config_name_fprint, key, config_fprint_anzahl);
 }
 
 static char *print_config_fprint(const char *key)
@@ -2150,7 +2365,6 @@
 {"mime_type",              d_mime_type }, /* NOTRANSLATE */
 {"overallmaxspeeddaydays", d_overallmaxspeeddaydays }, /* NOTRANSLATE */
 {"overallmaxspeeddaytime", d_overallmaxspeeddaytime }, /* NOTRANSLATE */
-{"periodicmsg",            d_periodicmsg }, /* NOTRANSLATE */
 {"slotsmax",               d_slotsmax }, /* NOTRANSLATE */
 {"statefile",              d_statefile }, /* NOTRANSLATE */
 {"transferlimits",         d_transferlimits }, /* NOTRANSLATE */
@@ -2217,7 +2431,8 @@
     dump_config_list2("channel_join_raw", &gdata.networks[si].channel_join_raw); /* NOTRANSLATE */
     dump_config_string3("local_vhost", gdata.networks[si].local_vhost); /* NOTRANSLATE */
     if (gnetwork->usenatip != 0) {
-      dump_config_string2("usenatip", gdata.networks[si].natip); /* NOTRANSLATE */
+      if (gdata.networks[si].natip != NULL)
+        dump_config_string2("usenatip", gdata.networks[si].natip); /* NOTRANSLATE */
     }
     dump_config_string3("nickserv_pass", gdata.networks[si].nickserv_pass); /* NOTRANSLATE */
     dump_config_string3("auth_name", gdata.networks[si].auth_name); /* NOTRANSLATE */
@@ -2225,6 +2440,8 @@
     dump_config_string3("user_nick", gdata.networks[si].config_nick); /* NOTRANSLATE */
     dump_config_string3("user_modes", gdata.networks[si].user_modes); /* NOTRANSLATE */
 
+    d_periodicmsg("periodicmsg", si); /* NOTRANSLATE */
+
     for (ss = irlist_get_head(&gdata.networks[si].servers);
          ss;
          ss = irlist_get_next(ss)) {
@@ -2284,6 +2501,7 @@
     dump_config_int3("need_level", gdata.networks[si].need_level, 10); /* NOTRANSLATE */
     dump_config_int3("getip_network", gdata.networks[si].getip_net, si); /* NOTRANSLATE */
     dump_config_int3("slow_privmsg", gdata.networks[si].slow_privmsg, 1); /* NOTRANSLATE */
+    dump_config_int3("server_connect_timeout", gdata.networks[si].server_connect_timeout, CTIMEOUT); /* NOTRANSLATE */
     dump_config_bool3("noannounce", gdata.networks[si].noannounce, 0); /* NOTRANSLATE */
     dump_config_bool3("offline", gdata.networks[si].offline, 0); /* NOTRANSLATE */
     dump_config_bool3("plaintext", gdata.networks[si].plaintext, 0); /* NOTRANSLATE */
@@ -2301,10 +2519,13 @@
   group_admin_t *ga;
   http_magic_t *mime;
   autoadd_group_t *ag;
+  periodicmsg_t *pm;
   server_t *ss;
   unsigned int si;
   unsigned int ii;
 
+  updatecontext();
+
   for (si=0; si<MAX_NETWORKS; ++si) {
     for (ss = irlist_get_head(&gdata.networks[si].servers);
          ss;
@@ -2329,9 +2550,12 @@
     gdata.networks[si].slow_privmsg = 1;
     gdata.networks[si].restrictsend = 2;
     gdata.networks[si].restrictlist = 2;
+    gdata.networks[si].respondtochannellist = 2;
+    gdata.networks[si].respondtochannelxdcc = 2;
     gdata.networks[si].need_voice = 2;
     gdata.networks[si].need_level = 10;
     gdata.networks[si].getip_net = si;
+    gdata.networks[si].server_connect_timeout = CTIMEOUT;
     gdata.networks[si].noannounce = 0;
     gdata.networks[si].offline = 0;
     gdata.networks[si].plaintext = 0;
@@ -2367,6 +2591,7 @@
        mime;
        mime = irlist_delete(&gdata.mime_type, mime)) {
     mydelete(mime->m_ext);
+    mydelete(mime->m_mime);
   }
   for (ag = irlist_get_head(&gdata.autoadd_group_match);
        ag;
@@ -2374,16 +2599,19 @@
     mydelete(ag->a_group);
     mydelete(ag->a_pattern);
   }
+  for (pm = irlist_get_head(&gdata.periodicmsg);
+       pm;
+       pm = irlist_delete(&gdata.periodicmsg, pm)) {
+    mydelete(pm->pm_nick);
+    mydelete(pm->pm_msg);
+  }
   for (ii=0; ii<NUMBER_TRANSFERLIMITS; ++ii) {
     gdata.transferlimits[ii].limit = 0;
   }
-  mydelete(gdata.periodicmsg_nick);
-  mydelete(gdata.periodicmsg_msg);
   mydelete(gdata.statefile);
   /* int */
   gdata.overallmaxspeeddaydays = 0x7F; /* all days */
   gdata.logrotate = 0;
-  gdata.periodicmsg_time = 0;
   gdata.slotsmax = 0;
   gdata.overallmaxspeeddaytimestart = 0;
   gdata.overallmaxspeeddaytimeend = 0;
@@ -2472,11 +2700,13 @@
 /* reset config to default values */
 void config_reset(void)
 {
+  updatecontext();
+
+  reset_config_func();
   reset_config_bool();
   reset_config_int();
   reset_config_string();
   reset_config_list();
-  reset_config_func();
 }
 
 static size_t config_expand_search_typ(config_name_t config_name_f, const char *key, size_t len, const char **first)
@@ -2492,7 +2722,7 @@
     if (strncmp(name, key, len))
       continue;
 
-    found++;
+    ++found;
     if (*first == NULL) *first = name;
   }
   return found;
Index: src/dinoex_defines.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_defines.h,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -r1.3 -r1.6
--- src/dinoex_defines.h	5 Feb 2011 11:05:54 -0000	1.3
+++ src/dinoex_defines.h	20 Apr 2011 19:20:37 -0000	1.6
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_defines.h,v 1.3 2011/02/05 11:05:54 cvs Exp $
+ * $Id: dinoex_defines.h,v 1.6 2011/04/20 19:20:37 cvs Exp $
  *
  */
 
@@ -19,6 +19,9 @@
 /*       max number of vhosts */
 #define  MAX_VHOSTS    2U
 
+#define  MAX_WAKEUP_WARN	2
+#define  MAX_WAKEUP_ERR		10
+
 #ifdef UNUSED
 #elif defined(__GNUC__)
 # define UNUSED(x) UNUSED_ ## x __attribute__((unused))
@@ -48,4 +51,22 @@
 #define IRVT_COLOR_YELLOW       "\x1b[1;33m"
 #define IRVT_COLOR_SET1         "\x1b[%u;%um"
 
+/* IRC text color chars */
+#define IRCCTCP		'\1'
+#define IRCBOLD		0x02
+#define IRCCOLOR	0x03
+#define IRCNORMAL	0x0F
+#define IRCINVERSE	0x16
+#define IRCITALIC	0x1D
+#define IRCUNDERLINE	0x1F
+
+/* IRC text color strings */
+#define IRC_CTCP	"\1"
+#define IRC_BOLD	"\x02"
+#define IRC_COLOR	"\x03"
+#define IRC_NORMAL	"\x0F"
+#define IRC_INVERSE	"\x16"
+#define IRC_ITALIC	"\x1D"
+#define IRC_UNDERLINE	"\x1F"
+
 /* EOF */
Index: src/dinoex_geoip.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_geoip.c,v
retrieving revision 1.22
retrieving revision 1.24
diff -u -r1.22 -r1.24
--- src/dinoex_geoip.c	5 Feb 2011 11:05:54 -0000	1.22
+++ src/dinoex_geoip.c	10 Jun 2011 07:30:45 -0000	1.24
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_geoip.c,v 1.22 2011/02/05 11:05:54 cvs Exp $
+ * $Id: dinoex_geoip.c,v 1.24 2011/06/10 07:30:45 cvs Exp $
  *
  */
 
@@ -152,6 +152,7 @@
             "GeoIP [%02i:%s on %s]: Info %s -> %s)",
             tr->id, tr->nick, gdata.networks[ tr->net ].name,
             tr->con.remoteaddr, country);
+  tr->country = mystrdup(country);
   if (irlist_size(&gdata.geoipexcludegroup)) {
     for (group = (char *)irlist_get_head(&gdata.geoipexcludegroup);
          group;
Index: src/dinoex_globals.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_globals.h,v
retrieving revision 1.36
retrieving revision 1.39
diff -u -r1.36 -r1.39
--- src/dinoex_globals.h	5 Feb 2011 11:05:54 -0000	1.36
+++ src/dinoex_globals.h	10 Jun 2011 06:27:29 -0000	1.39
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_globals.h,v 1.36 2011/02/05 11:05:54 cvs Exp $
+ * $Id: dinoex_globals.h,v 1.39 2011/06/10 06:27:29 cvs Exp $
  *
  */
 
@@ -61,6 +61,15 @@
   unsigned int dummy;
 } channel_announce_t;
 
+typedef struct
+{
+  char *pm_nick;
+  char *pm_msg;
+  time_t pm_next_time;
+  unsigned int pm_net;
+  unsigned int pm_time;
+} periodicmsg_t;
+
 typedef struct {
   char *nick;
   char *msg;
@@ -122,43 +131,31 @@
 
 typedef struct {
   connectionmethod_t connectionmethod;
-  irlist_t proxyinfo;
 
-  /* raw on join */
+  irlist_t proxyinfo;
   irlist_t server_join_raw;
   irlist_t server_connected_raw;
+  irlist_t serverq_fast;
+  irlist_t serverq_normal;
+  irlist_t serverq_slow;
+  irlist_t serverq_channel;
+  irlist_t xlistqueue;
   irlist_t channel_join_raw;
-
-  /* channel */
   irlist_t channels;
   irlist_t r_channels;
-
-  /* server */
   irlist_t servers;
-  server_t curserver;
-  char *curserveractualname;
-  unsigned int nocon;
-  unsigned int servertime;
 
+  server_t curserver;
   serv_resolv_t serv_resolv;
-  serverstatus_e serverstatus;
-  botstatus_e botstatus;
 
   time_t connecttime;
   time_t lastservercontact;
   time_t lastnotify;
   time_t lastping;
   time_t lastslow;
-  unsigned long lag;
-  irlist_t serverq_fast;
-  irlist_t serverq_normal;
-  irlist_t serverq_slow;
-  irlist_t serverq_channel;
-  irlist_t xlistqueue;
-  int ircserver;
-  int serverbucket;
-  unsigned int serverconnectbackoff;
-  unsigned int dummy;
+  time_t next_identify;
+  time_t next_restrict;
+
 #ifdef USE_OPENSSL
   SSL_CTX *ssl_ctx;
   SSL *ssl;
@@ -173,6 +170,7 @@
   char chanmodes[MAX_CHANMODES];
   char server_input_line[INPUT_BUFFER_LENGTH];
 
+  char *curserveractualname;
   char *user_nick;
   char *caps_nick;
   char *name;
@@ -185,7 +183,13 @@
   char *r_local_vhost;
   char *user_modes;
   char *natip;
+
+  unsigned long lag;
+
   unsigned int net;
+  unsigned int serverconnectbackoff;
+  unsigned int nocon;
+  unsigned int servertime;
   unsigned int recentsent;
   unsigned int nick_number;
   unsigned int inamnt[INAMNT_SIZE];
@@ -199,12 +203,18 @@
   unsigned int need_voice;
   unsigned int restrictsend;
   unsigned int restrictlist;
+  unsigned int respondtochannellist;
+  unsigned int respondtochannelxdcc;
+  unsigned int server_connect_timeout;
+
+  int ircserver;
+  int serverbucket;
   int need_level;
+  serverstatus_e serverstatus;
+  botstatus_e botstatus;
   how_e r_connectionmethod;
   userinput_method_e lag_method;
 
-  time_t next_identify;
-  time_t next_restrict;
   ir_uint32 ourip;
   ir_uint32 r_ourip;
 
Index: src/dinoex_http.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_http.c,v
retrieving revision 1.143
retrieving revision 1.156
diff -u -r1.143 -r1.156
--- src/dinoex_http.c	6 Feb 2011 11:16:34 -0000	1.143
+++ src/dinoex_http.c	22 Jun 2011 04:38:44 -0000	1.156
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_http.c,v 1.143 2011/02/06 11:16:34 cvs Exp $
+ * $Id: dinoex_http.c,v 1.156 2011/06/22 04:38:44 cvs Exp $
  *
  */
 
@@ -33,6 +33,8 @@
 
 #define MAX_WEBLIST_SIZE	(2 * 1024 * 1024)
 
+#define HTTP_DATE_LINE		"%a, %d %b %Y %T GMT"	/* NOTRANSLATE */
+
 typedef struct {
   const char *hg_group;
   const char *hg_desc;
@@ -54,19 +56,7 @@
 "Server: iroffer-dinoex/" VERSIONLONG "\r\n" /* NOTRANSLATE */
 "Content-Type: %s\r\n" /* NOTRANSLATE */
 "Connection: close\r\n" /* NOTRANSLATE */
-"Content-Length: %" LLPRINTFMT "u\r\n" /* NOTRANSLATE */
-"\r\n"; /* NOTRANSLATE */
-
-static const char *http_header_attachment =
-"HTTP/1.1 %u OK\r\n" /* NOTRANSLATE */
-"Date: %s\r\n" /* NOTRANSLATE */
-"Last-Modified: %s\r\n" /* NOTRANSLATE */
-"Server: iroffer-dinoex/" VERSIONLONG "\r\n" /* NOTRANSLATE */
-"Content-Type: %s\r\n" /* NOTRANSLATE */
-"Connection: close\r\n" /* NOTRANSLATE */
-"Content-Length: %" LLPRINTFMT "u\r\n" /* NOTRANSLATE */
-"Content-Disposition: attachment; filename=\"%s\"\r\n" /* NOTRANSLATE */
-"\r\n"; /* NOTRANSLATE */
+"Content-Length: %" LLPRINTFMT "u\r\n" /* NOTRANSLATE */;
 
 static const char *http_header_notfound =
 "HTTP/1.1 404 Not Found\r\n" /* NOTRANSLATE */
@@ -219,8 +209,8 @@
 
   for (mime = irlist_get_head(&gdata.mime_type);
        mime;
-       mime = irlist_delete(&gdata.mime_type, mime)) {
-    if (strcasecmp(mime->m_ext, ext) != 0)
+       mime = irlist_get_next(mime)) {
+    if (strcasecmp(mime->m_ext, ext) == 0)
       return mime->m_mime;
   }
 
@@ -259,7 +249,7 @@
     if (http_special[i].s_ch != 0)
       continue;
     switch (ch) {
-    case 0x03: /* color */
+    case IRCCOLOR: /* color */
       if (!isdigit(*src)) break;
       ++src;
       if (isdigit(*src)) ++src;
@@ -268,11 +258,11 @@
       if (isdigit(*src)) ++src;
       if (isdigit(*src)) ++src;
       break;
-    case 0x02: /* bold */
-    case 0x0F: /* end formatting */
-    case 0x16: /* inverse */
-    case 0x1D: /* italic */
-    case 0x1F: /* underline */
+    case IRCBOLD: /* bold */
+    case IRCNORMAL: /* end formatting */
+    case IRCINVERSE: /* inverse */
+    case IRCITALIC: /* italic */
+    case IRCUNDERLINE: /* underline */
       break;
     default:
       *(dest++) = ch;
@@ -305,7 +295,7 @@
     if (http_special[i].s_ch != 0)
       continue;
     switch (ch) {
-    case 0x03: /* color */
+    case IRCCOLOR: /* color */
       if (!isdigit(*src)) break;
       ++src;
       if (isdigit(*src)) ++src;
@@ -314,11 +304,11 @@
       if (isdigit(*src)) ++src;
       if (isdigit(*src)) ++src;
       break;
-    case 0x02: /* bold */
-    case 0x0F: /* end formatting */
-    case 0x16: /* inverse */
-    case 0x1D: /* italic */
-    case 0x1F: /* underline */
+    case IRCBOLD: /* bold */
+    case IRCNORMAL: /* end formatting */
+    case IRCINVERSE: /* inverse */
+    case IRCITALIC: /* italic */
+    case IRCUNDERLINE: /* underline */
       break;
     default:
       ++len;
@@ -363,7 +353,7 @@
       break;
     case '%': /* html */
       hex = 32;
-      sscanf(src, "%2x", &hex);
+      sscanf(src, "%2x", &hex); /* NOTRANSLATE */
       *(dest++) = hex;
       ++src;
       ++src;
@@ -392,7 +382,7 @@
     if (ch == 0)
       break;
     switch (ch) {
-    case 0x03: /* color */
+    case IRCCOLOR: /* color */
       if (!isdigit(*src)) break;
       ++src;
       if (isdigit(*src)) ++src;
@@ -401,11 +391,11 @@
       if (isdigit(*src)) ++src;
       if (isdigit(*src)) ++src;
       break;
-    case 0x02: /* bold */
-    case 0x0F: /* end formatting */
-    case 0x16: /* inverse */
-    case 0x1D: /* italic */
-    case 0x1F: /* underline */
+    case IRCBOLD: /* bold */
+    case IRCNORMAL: /* end formatting */
+    case IRCINVERSE: /* inverse */
+    case IRCITALIC: /* italic */
+    case IRCUNDERLINE: /* underline */
       break;
     case '%':
     case '&':
@@ -546,6 +536,8 @@
 int h_select_fdset(int highests)
 {
   http *h;
+  unsigned long sum;
+  unsigned int overlimit;
   unsigned int i;
 
   for (i=0; i<MAX_VHOSTS; ++i) {
@@ -555,6 +547,11 @@
     }
   }
 
+  sum = gdata.xdccsent[(gdata.curtime)%XDCC_SENT_SIZE]
+      + gdata.xdccsent[(gdata.curtime - 1)%XDCC_SENT_SIZE]
+      + gdata.xdccsent[(gdata.curtime - 2)%XDCC_SENT_SIZE]
+      + gdata.xdccsent[(gdata.curtime - 3)%XDCC_SENT_SIZE];
+  overlimit = (gdata.maxb && (sum >= gdata.maxb*1024));
   for (h = irlist_get_head(&gdata.https);
        h;
        h = irlist_get_next(h)) {
@@ -567,8 +564,10 @@
       highests = max2(highests, h->con.clientsocket);
     }
     if (h->status == HTTP_STATUS_SENDING) {
-      FD_SET(h->con.clientsocket, &gdata.writeset);
-      highests = max2(highests, h->con.clientsocket);
+      if (!overlimit && !h->overlimit) {
+        FD_SET(h->con.clientsocket, &gdata.writeset);
+        highests = max2(highests, h->con.clientsocket);
+      }
     }
   }
   return highests;
@@ -615,7 +614,7 @@
   localt = localtime(&gdata.curtime);
   tempstr = mymalloc(maxtextlength);
   date = mymalloc(maxtextlengthshort);
-  strftime(date, maxtextlengthshort - 1, "%d/%b/%Y:%T %Z", localt);
+  strftime(date, maxtextlengthshort - 1, HTTP_DATE_LINE, localt);
   bytes = h->bytesgot + h->bytessent;
   len = snprintf(tempstr, maxtextlength, "%s - - [%s] \"%s\" %u %ld\n",
                  get_host(h), date, h->log_url, h->status_code, bytes);
@@ -664,6 +663,7 @@
   mydelete(h->search);
   mydelete(h->pattern);
   mydelete(h->modified);
+  mydelete(h->range);
   mydelete(h->buffer_out);
   mydelete(h->con.remoteaddr);
   h->status = HTTP_STATUS_DONE;
@@ -679,7 +679,7 @@
   localt = gmtime(&gdata.curtime);
   tempstr = mymalloc(maxtextlength);
   date = mymalloc(maxtextlengthshort);
-  strftime(date, maxtextlengthshort - 1, "%a, %d %b %Y %T %Z", localt);
+  strftime(date, maxtextlengthshort - 1, HTTP_DATE_LINE, localt); /* NOTRANSLATE */
   len = snprintf(tempstr, maxtextlength, header, date);
   mydelete(date);
   send(h->con.clientsocket, tempstr, len, MSG_NOSIGNAL);
@@ -736,14 +736,14 @@
   h->status = HTTP_STATUS_SENDING;
   if (gdata.debug > 1)
     ioutput(OUT_S|OUT_H, COLOR_MAGENTA,
-            "HTTP '%s' response %ld bytes", h->url, (long)(h->totalsize));
+            "HTTP '%s' response %ld bytes", h->url, (long)(h->range_end - h->range_start));
 }
 
 static void h_error(http * const h, const char *header)
 {
   updatecontext();
 
-  h->totalsize = 0;
+  h->range_end = 0;
   h_write_header(h, header);
   h_start_sending(h);
 }
@@ -755,6 +755,43 @@
   h_error(h, http_header_notfound);
 }
 
+static int h_parse_range(http * const h)
+{
+  char *work;
+  char *base;
+
+  if (h->range == NULL)
+    return 0;
+
+  base = h->range;
+  work = strchr(base, '=');
+  if (work == NULL)
+    return 0;
+
+  *work = 0;
+  if (strcmp(h->range, "bytes") != 0 ) /* NOTRANSLATE */
+    return 0;
+
+  base = ++work;
+  work = strchr(base, '-');
+  if (work == NULL)
+    return 0;
+
+  *work = 0;
+  ++work;
+  h->range_start = atoull(base);
+  h->range_end = atoull(work);
+  if (h->range_end != 0) {
+    /* include last byte */
+    h->range_end += 1;
+    if (h->range_end >= h->totalsize)
+      h->range_end = h->totalsize;
+  } else {
+    h->range_end = h->totalsize;
+  }
+  return 1;
+}
+
 static void h_write_status(http * const h, const char *mime, time_t *now)
 {
   char *tempstr;
@@ -766,28 +803,42 @@
   tempstr = mymalloc(maxtextlength);
   localt = gmtime(&gdata.curtime);
   date = mymalloc(maxtextlengthshort);
-  strftime(date, maxtextlengthshort - 1, "%a, %d %b %Y %T %Z", localt); /* NOTRANSLATE */
-  if (now && (h->status_code == 200)) {
-    last = mymalloc(maxtextlengthshort);
-    localt = gmtime(now);
-    strftime(last, maxtextlengthshort - 1, "%a, %d %b %Y %T %Z", localt); /* NOTRANSLATE */
-    if (h->modified) {
-      if (strcmp(last, h->modified) == 0) {
-        h->status_code = 304;
-        h->head = 1;
+  strftime(date, maxtextlengthshort - 1, HTTP_DATE_LINE, localt); /* NOTRANSLATE */
+  if (h->status_code == 200) {
+    if (h_parse_range(h)) {
+      h->status_code = 206;
+    }
+    if (now) {
+      last = mymalloc(maxtextlengthshort);
+      localt = gmtime(now);
+      strftime(last, maxtextlengthshort - 1, HTTP_DATE_LINE, localt); /* NOTRANSLATE */
+      if (h->modified) {
+        if (strcmp(last, h->modified) == 0) {
+          h->status_code = 304;
+          h->head = 1;
+        }
       }
     }
   }
-  if (h->attachment)
-    len = snprintf(tempstr, maxtextlength, http_header_attachment, h->status_code, date, last ? last : date, html_mime(mime), h->totalsize, h->attachment);
-  else
-    len = snprintf(tempstr, maxtextlength, http_header_status, h->status_code, date, last ? last : date, html_mime(mime), h->totalsize);
+  len = snprintf(tempstr, maxtextlength, http_header_status, h->status_code, date, last ? last : date, html_mime(mime), h->range_end - h->range_start);
+  if (h->attachment) {
+    len += snprintf(tempstr + len, maxtextlength - len,
+                    "Content-Disposition: attachment; filename=\"%s\"\r\n", /* NOTRANSLATE */
+                    h->attachment);
+    len += snprintf(tempstr + len, maxtextlength - len,
+                    "Accept-Ranges: bytes\r\n" ); /* NOTRANSLATE */
+    if (h->range != NULL)
+      len += snprintf(tempstr + len, maxtextlength - len,
+                      "Content-Range: bytes %" LLPRINTFMT "u-%" LLPRINTFMT "u/%" LLPRINTFMT "u\r\n", /* NOTRANSLATE */
+                      h->range_start, h->range_end - 1, h->totalsize);
+  }
+  len += snprintf(tempstr + len, maxtextlength - len, "\r\n" ); /* NOTRANSLATE */
   mydelete(last);
   mydelete(date);
   send(h->con.clientsocket, tempstr, len, MSG_NOSIGNAL);
   mydelete(tempstr);
   if (h->head)
-    h->totalsize = 0;
+    h->range_end = 0;
 }
 
 static void h_readfile(http * const h, const char *file)
@@ -796,7 +847,6 @@
 
   updatecontext();
 
-  h->bytessent = 0;
   if (file == NULL) {
     h_herror_404(h);
     return;
@@ -827,9 +877,10 @@
     return;
   }
 
-  h->bytessent = 0;
+  h->range_start = 0;
   h->filepos = 0;
   h->totalsize = st.st_size;
+  h->range_end = h->totalsize;
   h_write_status(h, h->file, &st.st_mtime);
   h_start_sending(h);
 }
@@ -838,12 +889,12 @@
 {
   char *tempstr;
 
-  ioutput(OUT_S|OUT_H, COLOR_MAGENTA, "%s", msg);
+  ioutput(OUT_S|OUT_H, COLOR_MAGENTA, "%s", msg); /* NOTRANSLATE */
   h->filedescriptor = FD_UNUSED;
   h->status_code = 403;
   if (!gdata.http_forbidden) {
-    h->url = mystrdup("-");
-    h->log_url = mystrdup("-");
+    h->url = mystrdup("-"); /* NOTRANSLATE */
+    h->log_url = mystrdup("-"); /* NOTRANSLATE */
     h_error(h, http_header_forbidden);
     return;
   }
@@ -851,7 +902,7 @@
   h->log_url = mymalloc(maxtextlength);
   snprintf(h->log_url, maxtextlength, "GET %s HTTP/1.1", gdata.http_forbidden); /* NOTRANSLATE */
   tempstr = mymalloc(maxtextlength);
-  snprintf(tempstr, maxtextlength, "%s%s", gdata.http_dir, h->url);
+  snprintf(tempstr, maxtextlength, "%s%s", gdata.http_dir, h->url); /* NOTRANSLATE */
   h_readfile(h, tempstr);
   mydelete(tempstr);
   return;
@@ -935,8 +986,8 @@
 {
   updatecontext();
 
-  h->bytessent = 0;
-  h->totalsize = strlen(h->buffer_out);
+  h->range_start = 0;
+  h->range_end = strlen(h->buffer_out);
   h_write_status(h, "html", (h->search) ? NULL : &gdata.last_update); /* NOTRANSLATE */
   h_start_sending(h);
 }
@@ -1102,11 +1153,11 @@
 
   size_t len = 0;
   if (html_link_start++ > 0) {
-    len = snprintf(str, size, ";");
+    len = snprintf(str, size, ";"); /* NOTRANSLATE */
   }
   tempstr = mymalloc(maxtextlength);
   url_encode(tempstr, maxtextlength, val);
-  len += snprintf(str + len, size - len, "%s=%s", option, tempstr);
+  len += snprintf(str + len, size - len, "%s=%s", option, tempstr); /* NOTRANSLATE */
   mydelete(tempstr);
   return len;
 }
@@ -1121,11 +1172,11 @@
   len = snprintf(tempstr, maxtextlength, "<a%s title=\"%s\" href=\"/?", css, caption);
   html_link_start = 0;
   if (group)
-    len += html_link_option(tempstr + len, maxtextlength - len, "group", group);
+    len += html_link_option(tempstr + len, maxtextlength - len, "g", group); /* NOTRANSLATE */
   if (traffic)
-    len += html_link_option(tempstr + len, maxtextlength - len, "traffic", "1");
+    len += html_link_option(tempstr + len, maxtextlength - len, "t", "1"); /* NOTRANSLATE */
   if (order)
-    len += html_link_option(tempstr + len, maxtextlength - len, "order", order);
+    len += html_link_option(tempstr + len, maxtextlength - len, "o", order); /* NOTRANSLATE */
   len += snprintf(tempstr + len, maxtextlength - len, "\">%s</a>", text);
   return tempstr;
 }
@@ -1213,7 +1264,7 @@
 
   h_respond(h, "<form action=\"\" method=\"post\">\n");
   h_respond(h, "%s&nbsp;\n", "Search");
-  h_respond(h, "<input type=\"text\" name=\"search\" value=\"%s\" size=30>&nbsp;\n", (h->search) ? h->search : "");
+  h_respond(h, "<input type=\"text\" name=\"s\" value=\"%s\" size=30>&nbsp;\n", (h->search) ? h->search : "");
   h_respond(h, "<input type=\"submit\" name=\"submit\" value=\" %s \">\n", "Search");
   h_respond(h, "</form>\n" );
 }
@@ -1221,7 +1272,7 @@
 static void h_html_main(http * const h)
 {
   xdcc *xd;
-  irlist_t grplist = {0, 0};
+  irlist_t grplist = {0, 0, 0};
   char *tempstr;
   char *tlink;
   char *savegroup;
@@ -1746,10 +1797,10 @@
   updatecontext();
 
   if (body)
-    h->search = get_url_param(body, "search=");
-  h->group = get_url_param(h->log_url, "group=");
-  h->order = get_url_param(h->log_url, "order=");
-  h->traffic = get_url_number(h->log_url, "traffic=");
+    h->search = get_url_param(body, "s="); /* NOTRANSLATE */
+  h->group = get_url_param(h->log_url, "g="); /* NOTRANSLATE */
+  h->order = get_url_param(h->log_url, "o="); /* NOTRANSLATE */
+  h->traffic = get_url_number(h->log_url, "t="); /* NOTRANSLATE */
   guess = 2048;
   guess += h_guess_weblist(h);
   h_prepare_header(h, guess);
@@ -1762,7 +1813,7 @@
 }
 
 #ifndef WITHOUT_HTTP_ADMIN
-static void h_admin(http * const h, unsigned int UNUSED(level), const char *UNUSED(body))
+static void h_admin(http * const h, unsigned int UNUSED(level), const char * UNUSED(body))
 {
   char *tempstr;
   char *tmp;
@@ -1792,7 +1843,11 @@
       xd = get_xdcc_pack(pack);
       if (xd != NULL) {
         h->attachment = getfilename(xd->file);
+        ++(h->unlimited);
+        h->maxspeed = xd->maxspeed;
         h_readfile(h, xd->file);
+        /* force download in browser */
+        h->attachment = getfilename(h->file);
         return;
       }
     }
@@ -1842,11 +1897,11 @@
     return header;
   }
   if (strcasecmp(request, "POST" ) == 0) { /* NOTRANSLATE */
-    h->post = 1;
+    ++(h->post);
     return header;
   }
   if (strcasecmp(request, "HEAD" ) == 0) { /* NOTRANSLATE */
-    h->head = 1;
+    ++(h->head);
     return header;
   }
   return NULL;
@@ -1860,6 +1915,7 @@
   updatecontext();
 
   h->bytesgot = 0;
+  h->bytessent = 0;
   gdata.sendbuff[0] = 0;
   howmuch2 = BUFFERSIZE;
   for (i=0; i<MAXTXPERLOOP; ++i) {
@@ -2047,6 +2103,10 @@
       h->modified = mystrdup(hval);
       continue;
     }
+    if (strcmp(data, "Range") == 0) { /* NOTRANSLATE */
+      h->range = mystrdup(hval);
+      continue;
+    }
     if (strcmp(data, "Authorization") == 0) { /* NOTRANSLATE */
       h->authorization = mystrdup(hval);
       continue;
@@ -2077,13 +2137,37 @@
   h_parse(h, data);
 }
 
+static int h_bandwith(http * const h)
+{
+  unsigned int j;
+
+  /* max bandwidth start.... */
+  if (h->maxspeed > 0) {
+    if (h->tx_bucket < TXSIZE) {
+      h->overlimit = 1;
+      return 1; /* over transfer limit */
+    }
+  } else {
+    h->tx_bucket = TXSIZE * MAXTXPERLOOP;
+  }
+  j = gdata.xdccsent[(gdata.curtime)%XDCC_SENT_SIZE]
+    + gdata.xdccsent[(gdata.curtime-1)%XDCC_SENT_SIZE]
+    + gdata.xdccsent[(gdata.curtime-2)%XDCC_SENT_SIZE]
+    + gdata.xdccsent[(gdata.curtime-3)%XDCC_SENT_SIZE];
+  if ( gdata.maxb && (j >= gdata.maxb*1024)) {
+    if (h->unlimited == 0)
+      return 1; /* over overall limit */
+  }
+  h->overlimit = 0;
+  return 0;
+}
+
 static void h_send(http * const h)
 {
   off_t offset;
   char *data;
   size_t attempt;
   ssize_t howmuch, howmuch2;
-  long bucket;
   int errno2;
 
   updatecontext();
@@ -2095,23 +2179,36 @@
     }
   }
 
-  bucket = TXSIZE * MAXTXPERLOOP;
+  /* close on HTTP HEAD */
+  if (h->range_end == 0) {
+    if (h->filedescriptor == FD_UNUSED) {
+      mydelete(h->buffer_out);
+    } else {
+      close(h->filedescriptor);
+      h->filedescriptor = FD_UNUSED;
+    }
+    return;
+  }
+
+  if (h_bandwith(h))
+    return;
+
   do {
-    attempt = min2(bucket - (bucket % TXSIZE), BUFFERSIZE);
+    attempt = min2(h->tx_bucket - (h->tx_bucket % TXSIZE), BUFFERSIZE);
     if (h->filedescriptor == FD_UNUSED) {
-      howmuch = h->totalsize - h->bytessent;
-      data = h->buffer_out + h->bytessent;
+      howmuch = h->range_end - h->range_start;
+      data = h->buffer_out + h->range_start;
     } else {
-      if (h->filepos != h->bytessent) {
-        offset = lseek(h->filedescriptor, h->bytessent, SEEK_SET);
-        if (offset != h->bytessent) {
+      if (h->filepos != h->range_start) {
+        offset = lseek(h->filedescriptor, h->range_start, SEEK_SET);
+        if (offset != h->range_start) {
           errno2 = errno;
           outerror(OUTERROR_TYPE_WARN, "Can't seek location in file '%s': %s",
                    h->file, strerror(errno));
           h_closeconn(h, "Unable to locate data in file", errno2);
           return;
         }
-        h->filepos = h->bytessent;
+        h->filepos = h->range_start;
       }
       howmuch = read(h->filedescriptor, gdata.sendbuff, attempt);
       data = (char *)gdata.sendbuff;
@@ -2139,13 +2236,17 @@
     }
 
     h->bytessent += howmuch2;
-    bucket -= howmuch2;
+    h->range_start += howmuch2;
+    gdata.xdccsum[gdata.curtime%XDCC_SENT_SIZE] += howmuch2;
+    if (h->unlimited == 0)
+      gdata.xdccsent[gdata.curtime%XDCC_SENT_SIZE] += howmuch2;
+    h->tx_bucket -= howmuch2;
     if (gdata.debug > 4)
       ioutput(OUT_S, COLOR_BLUE, "File %ld Write %ld", (long)howmuch, (long)howmuch2);
 
-  } while ((bucket >= TXSIZE) && (howmuch2 > 0));
+  } while ((h->tx_bucket >= TXSIZE) && (howmuch2 > 0));
 
-  if (h->bytessent >= h->totalsize) {
+  if (h->range_start >= h->range_end) {
     if (h->filedescriptor == FD_UNUSED) {
       mydelete(h->buffer_out);
     } else {
@@ -2166,7 +2267,7 @@
 }
 
 /* process all HTTP connections */
-void h_perform(int changesec)
+void h_perform(int changesec, int changequartersec)
 {
   http *h;
   unsigned int i;
@@ -2178,6 +2279,17 @@
       }
     }
   }
+  if (changequartersec) {
+    for (h = irlist_get_head(&gdata.https);
+         h;
+         h = irlist_get_next(h)) {
+       if (h->maxspeed <= 0)
+         continue;
+
+       h->tx_bucket += h->maxspeed * (1024 / 4);
+       h->tx_bucket = min2(h->tx_bucket, MAX_TRANSFER_TX_BURST_SIZE * h->maxspeed * 1024);
+    }
+  }
   h = irlist_get_head(&gdata.https);
   while (h) {
     if (h->status == HTTP_STATUS_GETTING) {
Index: src/dinoex_http.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_http.h,v
retrieving revision 1.19
retrieving revision 1.23
diff -u -r1.19 -r1.23
--- src/dinoex_http.h	30 Jan 2011 18:56:34 -0000	1.19
+++ src/dinoex_http.h	9 Jun 2011 14:19:46 -0000	1.23
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_http.h,v 1.19 2011/01/30 18:56:34 cvs Exp $
+ * $Id: dinoex_http.h,v 1.23 2011/06/09 14:19:46 cvs Exp $
  *
  */
 
@@ -24,18 +24,18 @@
 
 typedef struct
 {
+  ir_connection_t con;
   off_t bytesgot;
   off_t bytessent;
   off_t filepos;
   off_t totalsize;
-  ir_connection_t con;
-  int filedescriptor;
-  http_status_e status;
+  off_t range_start;
+  off_t range_end;
+  const char *nick;
+  const char *attachment;
   char *file;
   char *buffer_out;
   char *end;
-  const char *nick;
-  const char *attachment;
   char *log_url;
   char *url;
   char *authorization;
@@ -44,6 +44,8 @@
   char *search;
   char *pattern;
   char *modified;
+  char *range;
+  long tx_bucket;
   ssize_t left;
   unsigned int traffic;
   unsigned int status_code;
@@ -51,11 +53,18 @@
   unsigned int post;
   unsigned int head;
   unsigned int idummy;
+  float maxspeed;
+  http_status_e status;
+  int filedescriptor;
+  char overlimit;
+  char unlimited;
+  char cdummy2;
+  char cdummy1;
 } http;
 
 typedef struct {
   char *m_ext;
-  const char *m_mime;
+  char *m_mime;
 } http_magic_t;
 
 #ifndef WITHOUT_HTTP
@@ -68,6 +77,6 @@
 unsigned int h_setup_listen(void);
 void h_reash_listen(void);
 int h_select_fdset(int highests);
-void h_perform(int changesec);
+void h_perform(int changesec, int changequartersec);
 
 /* End of File */
Index: src/dinoex_irc.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_irc.c,v
retrieving revision 1.67
retrieving revision 1.79
diff -u -r1.67 -r1.79
--- src/dinoex_irc.c	10 Feb 2011 18:31:34 -0000	1.67
+++ src/dinoex_irc.c	11 Jun 2011 06:13:50 -0000	1.79
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_irc.c,v 1.67 2011/02/10 18:31:34 cvs Exp $
+ * $Id: dinoex_irc.c,v 1.79 2011/06/11 06:13:50 cvs Exp $
  *
  */
 
@@ -19,6 +19,11 @@
 #include "iroffer_headers.h"
 #include "iroffer_globals.h"
 #include "dinoex_utilities.h"
+#include "dinoex_queue.h"
+#include "dinoex_ssl.h"
+#include "dinoex_ruby.h"
+#include "dinoex_jobs.h"
+#include "dinoex_user.h"
 #include "dinoex_misc.h"
 #include "dinoex_irc.h"
 
@@ -28,6 +33,13 @@
 
 #include <netinet/tcp.h>
 
+#define MAX_IRCMSG_PARTS 6
+
+typedef struct {
+  char *line;
+  char *part[MAX_IRCMSG_PARTS];
+} ir_parseline_t;
+
 /* writes IP address and port as text into the buffer */
 int my_getnameinfo(char *buffer, size_t len, const struct sockaddr *sa)
 {
@@ -176,7 +188,7 @@
 }
 
 /* check the welcome message from the server for an IP address or hostname to set external DCC IP */
-void update_server_welcome(char *line)
+static void update_server_welcome(char *line)
 {
   const char *tptr;
 
@@ -573,6 +585,66 @@
   }
 }
 
+#ifndef NO_HOSTCODES
+static  const char *irc_resolved_errormsg[] = {
+  "host not found",
+  "no ip address",
+  "non-recoverable name server",
+  "try again later",
+};
+#endif
+
+/* collect the the DNS resolution from the child process */
+void irc_resolved(void)
+{
+  pid_t child;
+  unsigned int ss;
+  int status;
+
+  while ((child = waitpid(-1, &status, WNOHANG)) > 0) {
+    for (ss=0; ss<gdata.networks_online; ++ss) {
+      if (child != gdata.networks[ss].serv_resolv.child_pid)
+        continue;
+
+      if (gdata.networks[ss].serverstatus == SERVERSTATUS_RESOLVING) {
+        /* lookup failed */
+#ifdef NO_WSTATUS_CODES
+        ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
+                "Unable to resolve server %s on %s " "(status=0x%.8X)",
+                gdata.networks[ss].curserver.hostname, gdata.networks[ss].name,
+                status);
+#else
+        int hasexited = WIFEXITED(status);
+        int ecode = WEXITSTATUS(status);
+#ifndef NO_HOSTCODES
+        if (hasexited && (ecode >= 20) && (ecode <= 23)) {
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
+                  "Unable to resolve server %s on %s " "(%s)",
+                  gdata.networks[ss].curserver.hostname, gdata.networks[ss].name,
+                  irc_resolved_errormsg[ecode - 20]);
+        } else
+#endif
+        {
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
+                  "Unable to resolve server %s on %s " "(status=0x%.8X, %s: %d)",
+                  gdata.networks[ss].curserver.hostname, gdata.networks[ss].name,
+                  status,
+                  hasexited ? "exit" : WIFSIGNALED(status) ? "signaled" : "??",
+                  hasexited ? ecode : WIFSIGNALED(status) ? WTERMSIG(status) : 0);
+        }
+#endif
+        gdata.networks[ss].serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
+      }
+
+      /* cleanup */
+      close(gdata.networks[ss].serv_resolv.sp_fd[0]);
+      FD_CLR(gdata.networks[ss].serv_resolv.sp_fd[0], &gdata.readset);
+      gdata.networks[ss].serv_resolv.sp_fd[0] = 0;
+      gdata.networks[ss].serv_resolv.child_pid = 0;
+    }
+  }
+}
+
 /* returns a text with the external IP address of the bot */
 const char *my_dcc_ip_show(char *buffer, size_t len, ir_sockaddr_union_t *sa, unsigned int net)
 {
@@ -591,7 +663,7 @@
 }
 
 /* complete the connection to the IRC server */
-unsigned int connectirc2(res_addrinfo_t *remote)
+static unsigned int connectirc2(res_addrinfo_t *remote)
 {
   int retval;
   int family;
@@ -779,6 +851,30 @@
   return highests;
 }
 
+static int irc_server_is_timeout(void)
+{
+  int timeout;
+  timeout = CTIMEOUT + (gnetwork->serverconnectbackoff * CBKTIMEOUT);
+
+  if (gnetwork->lastservercontact + timeout < gdata.curtime)
+    return timeout;
+
+  return 0;
+}
+
+static void irc_server_timeout(void)
+{
+  int timeout;
+
+  timeout = irc_server_is_timeout();
+  if (timeout > 0) {
+    ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+            "Server Connection Timed Out (%u seconds) on %s", timeout, gnetwork->name);
+    close_server();
+  }
+}
+
+
 /* try to identify at Nickserv */
 void identify_needed(unsigned int force)
 {
@@ -814,7 +910,7 @@
 }
 
 /* check line from server to see if the bots need to identify again */
-void identify_check(const char *line)
+static void identify_check(const char *line)
 {
   char *pwd;
 
@@ -836,4 +932,752 @@
   }
 }
 
+static void irc_001(ir_parseline_t *ipl)
+{
+  char *tptr;
+
+  ioutput(OUT_S|OUT_L, COLOR_NO_COLOR, "Server welcome: %s", ipl->line);
+  update_server_welcome(ipl->line);
+
+  /* update server name */
+  mydelete(gnetwork->curserveractualname);
+  gnetwork->curserveractualname = getpart(ipl->line + 1, 1);
+
+  /* update nick */
+  mydelete(gnetwork->user_nick);
+  mydelete(gnetwork->caps_nick);
+  gnetwork->user_nick = mystrdup(ipl->part[2]);
+  gnetwork->caps_nick = mystrdup(ipl->part[2]);
+  caps(gnetwork->caps_nick);
+  gnetwork->nick_number = 0;
+  gnetwork->next_restrict = gdata.curtime + gdata.restrictsend_delay;
+  ++(gdata.needsclear);
+
+  tptr = get_user_modes();
+  if (tptr && tptr[0]) {
+    writeserver(WRITESERVER_NOW, "MODE %s %s",
+                gnetwork->user_nick, tptr);
+  }
+
+  /* server connected raw command */
+  for (tptr = irlist_get_head(&(gnetwork->server_connected_raw));
+       tptr;
+       tptr = irlist_get_next(tptr)) {
+    writeserver(WRITESERVER_NORMAL, "%s", tptr);
+  }
+
+  /* nickserv */
+  identify_needed(0);
+}
+
+static void irc_005(ir_parseline_t *ipl)
+{
+  unsigned int ii = 3;
+  char *item;
+
+  while((item = getpart(ipl->line, ++ii))) {
+    if (item[0] == ':') {
+      mydelete(item);
+      break;
+    }
+
+    if (!strncmp("PREFIX=(", item, 8)) {
+      char *ptr = item+8;
+      unsigned int pi;
+
+      memset(&(gnetwork->prefixes), 0, sizeof(gnetwork->prefixes));
+      for (pi = 0; (ptr[pi] && (ptr[pi] != ')') && (pi < MAX_PREFIX)); ++pi) {
+        gnetwork->prefixes[pi].p_mode = ptr[pi];
+      }
+      if (ptr[pi] == ')') {
+        ptr += pi + 1;
+        for (pi = 0; (ptr[pi] && (pi < MAX_PREFIX)); ++pi) {
+          gnetwork->prefixes[pi].p_symbol = ptr[pi];
+        }
+      }
+      for (pi = 0; pi < MAX_PREFIX; ++pi) {
+        if ((gnetwork->prefixes[pi].p_mode && !gnetwork->prefixes[pi].p_symbol) ||
+           (!gnetwork->prefixes[pi].p_mode && gnetwork->prefixes[pi].p_symbol)) {
+          outerror(OUTERROR_TYPE_WARN,
+                   "Server prefix list on %s doesn't make sense, using defaults: %s",
+                   gnetwork->name, item);
+          initprefixes();
+        }
+      }
+    }
+
+    if (!strncmp("CHANMODES=", item, 10)) {
+      char *ptr = item+10;
+      unsigned int ci;
+      unsigned int cm;
+
+      memset(&(gnetwork->chanmodes), 0, sizeof(gnetwork->chanmodes));
+      for (ci = cm = 0; (ptr[ci] && (cm < MAX_CHANMODES)); ++ci) {
+        if (ptr[ci+1] == ',')
+                     {
+                       /* we only care about ones with arguments */
+                       gnetwork->chanmodes[cm++] = ptr[ci++];
+                     }
+      }
+    }
+
+    mydelete(item);
+  }
+}
+
+static char *ir_get_nickarg(const char *line)
+{
+  char* nick;
+  size_t len;
+  unsigned int j;
+
+  len = strlen(line);
+  nick = mymalloc(len + 1);
+  for (j=1; line[j] != '!' && j<len; ++j) {
+    nick[j-1] = line[j];
+  }
+  nick[j-1]='\0';
+  return nick;
+}
+
+static void ir_unknown_channel(const char *chname)
+{
+  ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+          "%s is not a known channel on %s!",
+          chname, gnetwork->name);
+}
+
+static void ir_parseline2(ir_parseline_t *ipl)
+{
+  channel_t *ch;
+  char *nick;
+  char *part3a;
+  char *t;
+  unsigned int i;
+
+  caps(ipl->part[1]);
+
+  /* NOTICE nick */
+  if (!strcmp(ipl->part[1], "NOTICE")) {
+    if (gnetwork->caps_nick && ipl->part[2]) {
+      if (!strcmp(caps(ipl->part[2]), gnetwork->caps_nick)) {
+        /* nickserv */
+        identify_check(ipl->line);
+#ifdef USE_RUBY
+        if (do_myruby_notice(ipl->line) == 0)
+#endif /* USE_RUBY */
+          privmsgparse(0, 0, ipl->line);
+      }
+    }
+  }
+
+  /* PRIVMSG */
+  if (!strcmp(ipl->part[1], "PRIVMSG")) {
+#ifndef WITHOUT_BLOWFISH
+    char *line2;
+
+    line2 = test_fish_message(ipl->line, ipl->part[2], ipl->part[3], ipl->part[4]);
+    if (line2) {
+#ifdef USE_RUBY
+      if (do_myruby_privmsg(line2) == 0)
+#endif /* USE_RUBY */
+        privmsgparse(1, 1, line2);
+      mydelete(line2);
+    } else {
+#endif /* WITHOUT_BLOWFISH */
+#ifdef USE_RUBY
+      if (do_myruby_privmsg(ipl->line) == 0)
+#endif /* USE_RUBY */
+        privmsgparse(1, 0, ipl->line);
+#ifndef WITHOUT_BLOWFISH
+    }
+#endif /* WITHOUT_BLOWFISH */
+  }
+
+  /* :server 001  xxxx :welcome.... */
+  if ( !strcmp(ipl->part[1], "001") ) {
+    irc_001(ipl);
+    return;
+  }
+
+  /* :server 005 xxxx aaa bbb=x ccc=y :are supported... */
+  if ( !strcmp(ipl->part[1], "005") ) {
+    irc_005(ipl);
+    return;
+  }
+
+  /* :server 401 botnick usernick :No such nick/channel */
+  if ( !strcmp(ipl->part[1], "401") ) {
+    if (ipl->part[2] && ipl->part[3]) {
+      if (!strcmp(ipl->part[2], "*")) {
+        lost_nick(ipl->part[3]);
+      }
+    }
+    return;
+  }
+
+  /* :server 433 old new :Nickname is already in use. */
+  if ( !strcmp(ipl->part[1], "433") ) {
+    if (ipl->part[2] && ipl->part[3]) {
+      if (!strcmp(ipl->part[2], "*")) {
+        ioutput(OUT_S, COLOR_NO_COLOR,
+                "Nickname %s already in use on %s, trying %s%u",
+                ipl->part[3],
+                gnetwork->name,
+                get_config_nick(),
+                gnetwork->nick_number);
+
+        /* generate new nick and retry */
+        writeserver(WRITESERVER_NORMAL, "NICK %s%u",
+                    get_config_nick(),
+                    (gnetwork->nick_number)++);
+      }
+    }
+    return;
+  }
+
+  /* :server 470 botnick #channel :(you are banned) transfering you to #newchannel */
+  if ( !strcmp(ipl->part[1], "470") ) {
+    if (ipl->part[2] && ipl->part[3]) {
+      outerror(OUTERROR_TYPE_WARN_LOUD,
+               "channel on %s: %s", gnetwork->name, strstr(ipl->line, "470"));
+      for (ch = irlist_get_head(&(gnetwork->channels));
+           ch;
+           ch = irlist_get_next(ch)) {
+        if (strcmp(caps(ipl->part[2]), gnetwork->caps_nick))
+             continue;
+        if (strcmp(caps(ipl->part[3]), ch->name))
+             continue;
+        ch->flags |= CHAN_KICKED;
+      }
+    }
+    return;
+  }
+
+  /* names list for a channel */
+  /* :server 353 our_nick = #channel :nick @nick +nick nick */
+  if ( !strcmp(ipl->part[1], "353") ) {
+    if (ipl->part[2] && ipl->part[3] && ipl->part[5]) {
+      caps(ipl->part[4]);
+
+      for (ch = irlist_get_head(&(gnetwork->channels));
+           ch;
+           ch = irlist_get_next(ch)) {
+        if (strcmp(ipl->part[4], ch->name) != 0)
+          continue;
+        for (i=0; (t = getpart(ipl->line, 6+i)); ++i) {
+          addtomemberlist(ch, i == 0 ? t+1 : t);
+          mydelete(t);
+        }
+        return;
+      }
+      ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+              "Got name data for %s which is not a known channel on %s!",
+              ipl->part[4], gnetwork->name);
+      writeserver(WRITESERVER_NORMAL, "PART %s", ipl->part[4]);
+    }
+    return;
+  }
+
+  if (gnetwork->lastping != 0) {
+    if (strcmp(ipl->part[1], "PONG") == 0) {
+      lag_message();
+      return;
+    }
+  }
+
+#if PING_SRVR
+  /* server ping */
+  if (strncmp(ipl->line, "PING :", 6) == 0) {
+    if (gdata.debug > 0)
+      ioutput(OUT_S, COLOR_NO_COLOR,
+              "Server Ping on %s: %s",
+              gnetwork->name, ipl->line);
+    writeserver(WRITESERVER_NOW, "PO%s", ipl->line+2);
+    return;
+  }
+#endif
+
+  /* QUIT */
+  if (strcmp(ipl->part[1], "QUIT") == 0) {
+    if (gnetwork->caps_nick) {
+      nick = ir_get_nickarg(ipl->line);
+      if (!strcmp(caps(nick), gnetwork->caps_nick)) {
+        /* we quit? */
+        outerror(OUTERROR_TYPE_WARN_LOUD,
+                 "Forced quit on %s: %s", gnetwork->name, ipl->line);
+        close_server();
+        clean_send_buffers();
+        /* do not reconnect */
+        gnetwork->serverstatus = SERVERSTATUS_EXIT;
+      } else {
+        /* someone else quit */
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          removefrommemberlist(ch, nick);
+        }
+        reverify_restrictsend();
+      }
+      mydelete(nick);
+    }
+    return;
+  }
+
+  /* MODE #channel +x ... */
+  if (strcmp(ipl->part[1], "MODE") == 0) {
+    if (ipl->part[2] && ipl->part[3]) {
+      /* find channel */
+      for (ch = irlist_get_head(&(gnetwork->channels)); ch; ch = irlist_get_next(ch)) {
+        char *ptr;
+        unsigned int plus;
+        unsigned int part;
+        unsigned int ii;
+
+        if (strcasecmp(ch->name, ipl->part[2]) != 0)
+          continue;
+
+        plus = 0;
+        part = 4;
+        for (ptr = ipl->part[3]; *ptr; ++ptr) {
+          if (*ptr == '+') {
+            plus = 1;
+          } else if (*ptr == '-') {
+            plus = 0;
+          } else {
+            for (ii = 0; (ii < MAX_PREFIX && gnetwork->prefixes[ii].p_mode); ++ii) {
+              if (*ptr == gnetwork->prefixes[ii].p_mode) {
+                /* found a nick mode */
+                nick = getpart(ipl->line, ++part);
+                if (nick) {
+                  if (nick[strlen(nick)-1] == IRCCTCP) {
+                    nick[strlen(nick)-1] = '\0';
+                  }
+                  if (plus == 0) {
+                    if (strcasecmp(nick, get_config_nick()) == 0) {
+                      identify_needed(0);
+                    }
+                  }
+                  changeinmemberlist_mode(ch, nick,
+                                          gnetwork->prefixes[ii].p_symbol,
+                                          plus);
+                  mydelete(nick);
+                }
+                break;
+              }
+            }
+            for (ii = 0; (ii < MAX_CHANMODES && gnetwork->chanmodes[ii]); ++ii) {
+              if (*ptr == gnetwork->chanmodes[ii]) {
+                /* found a channel mode that has an argument */
+                ++part;
+                break;
+              }
+            }
+          }
+        }
+        return;
+      }
+      if (strcasecmp(ipl->part[2], get_config_nick()) == 0) {
+        if (ipl->part[3][0] == '-') {
+          identify_needed(0);
+        }
+      }
+    }
+    return;
+  }
+
+  if (ipl->part[2] && ipl->part[2][0] == ':') {
+    part3a = ipl->part[2] + 1;
+  } else {
+    part3a = ipl->part[2];
+  }
+
+  /* JOIN */
+  if (strcmp(ipl->part[1], "JOIN") == 0) {
+    if (gnetwork->caps_nick && part3a) {
+      caps(part3a);
+      nick = ir_get_nickarg(ipl->line);
+      if (!strcmp(caps(nick), gnetwork->caps_nick)) {
+        /* we joined */
+        /* clear now, we have succesfully logged in */
+        gnetwork->serverconnectbackoff = 0;
+        ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+                "Joined %s on %s", part3a, gnetwork->name);
+
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          if (strcmp(part3a, ch->name) != 0)
+            continue;
+
+          ch->flags |= CHAN_ONCHAN;
+          ch->lastjoin = gdata.curtime;
+          ch->nextann = gdata.curtime + gdata.waitafterjoin;
+          if (ch->joinmsg) {
+            writeserver(WRITESERVER_NOW, "PRIVMSG %s :%s", ch->name, ch->joinmsg);
+          }
+          gnetwork->botstatus = BOTSTATUS_JOINED;
+          start_sends();
+          mydelete(nick);
+          return;
+        }
+      } else {
+        /* someone else joined */
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          if (strcmp(part3a, ch->name) != 0)
+            continue;
+
+          addtomemberlist(ch, nick);
+          mydelete(nick);
+          return;
+        }
+      }
+      ir_unknown_channel(part3a);
+      mydelete(nick);
+    }
+    return;
+  }
+
+  /* PART */
+  if (strcmp(ipl->part[1], "PART") == 0) {
+    if (gnetwork->caps_nick && part3a) {
+      nick = ir_get_nickarg(ipl->line);
+      if (!strcmp(caps(nick), gnetwork->caps_nick)) {
+        /* we left? */
+        mydelete(nick);
+        return;
+      } else {
+        /* someone else left */
+        caps(part3a);
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          if (strcmp(part3a, ch->name) != 0)
+            continue;
+
+          removefrommemberlist(ch, nick);
+          mydelete(nick);
+          reverify_restrictsend();
+          return;
+        }
+      }
+      ir_unknown_channel(part3a);
+      mydelete(nick);
+    }
+    return;
+  }
+
+  /* NICK */
+  if (strcmp(ipl->part[1], "NICK") == 0) {
+    if (gnetwork->caps_nick && part3a) {
+      nick = ir_get_nickarg(ipl->line);
+      if (!strcmp(caps(nick), gnetwork->caps_nick)) {
+        /* we changed, update nick */
+        mydelete(gnetwork->user_nick);
+        mydelete(gnetwork->caps_nick);
+        gnetwork->user_nick = mystrdup(part3a);
+        gnetwork->caps_nick = mystrdup(part3a);
+        caps(gnetwork->caps_nick);
+        gnetwork->nick_number = 0;
+        ++(gdata.needsclear);
+        identify_needed(0);
+      } else {
+        /* someone else has a new nick */
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          changeinmemberlist_nick(ch, nick, part3a);
+        }
+        user_changed_nick(nick, part3a);
+      }
+      mydelete(nick);
+    }
+    return;
+  }
+
+  /* KICK */
+  if (strcmp(ipl->part[1], "KICK") == 0) {
+    if (gnetwork->caps_nick && part3a && ipl->part[3]) {
+      caps(part3a);
+      if (!strcmp(caps(ipl->part[3]), gnetwork->caps_nick)) {
+        /* we were kicked */
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          if (strcmp(part3a, ch->name) != 0)
+            continue;
+
+          if (gdata.noautorejoin) {
+            outerror(OUTERROR_TYPE_WARN_LOUD,
+                     "Kicked on %s: %s", gnetwork->name, ipl->line);
+            ch->flags |= CHAN_KICKED;
+            clearmemberlist(ch);
+            reverify_restrictsend();
+          } else {
+            outerror(OUTERROR_TYPE_WARN_LOUD,
+                     "Kicked on %s, Rejoining: %s", gnetwork->name, ipl->line);
+            ch->flags &= ~CHAN_ONCHAN;
+            joinchannel(ch);
+          }
+        }
+      } else {
+        /* someone else was kicked */
+        for (ch = irlist_get_head(&(gnetwork->channels));
+             ch;
+             ch = irlist_get_next(ch)) {
+          if (strcmp(part3a, ch->name) != 0)
+            continue;
+
+          removefrommemberlist(ch, ipl->part[3]);
+          reverify_restrictsend();
+          return;
+        }
+      }
+    }
+    return;
+  }
+
+  /* ERROR :Closing Link */
+  if (strncmp(ipl->line, "ERROR :Closing Link", strlen("ERROR :Closing Link")) == 0) {
+    if (gdata.exiting) {
+      gnetwork->recentsent = 0;
+      return;
+    }
+    ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
+            "Server Closed Connection on %s: %s",
+            gnetwork->name, ipl->line);
+    close_server();
+    return;
+  }
+}
+
+/* handle message from irc server */
+static void ir_parseline(char *line)
+{
+  ir_parseline_t ipl;
+  unsigned int m;
+
+  updatecontext();
+
+  removenonprintable(line);
+#ifdef USE_RUBY
+  if (do_myruby_server(line))
+    return;
+#endif /* USE_RUBY */
+
+  /* we only support lines upto maxtextlength, truncate line */
+  line[maxtextlength-1] = '\0';
+
+  if (gdata.debug > 0)
+    ioutput(OUT_S, COLOR_CYAN, ">IRC>: %u, %s", gnetwork->net + 1, line);
+
+  bzero((char *)&ipl, sizeof(ipl));
+  ipl.line = line;
+  m = get_argv(ipl.part, line, MAX_IRCMSG_PARTS);
+
+  if (ipl.part[1] != NULL)
+    ir_parseline2(&ipl);
+
+  for (m = 0; m < MAX_IRCMSG_PARTS; ++m)
+    mydelete(ipl.part[m]);
+}
+
+/* handle irc server connectipn */
+void irc_perform(int changesec)
+{
+  channel_t *ch;
+  unsigned int ss;
+  unsigned int i;
+  unsigned int j;
+  int length;
+  int timeout;
+
+  updatecontext();
+
+  for (ss=0; ss<gdata.networks_online; ++ss) {
+    gnetwork = &(gdata.networks[ss]);
+
+    if (gdata.needsswitch) {
+      switchserver(-1);
+      continue;
+    }
+
+    /*----- see if gdata.ircserver is sending anything to us ----- */
+    if (gnetwork->serverstatus == SERVERSTATUS_CONNECTED) {
+      if (FD_ISSET(gnetwork->ircserver, &gdata.readset)) {
+        char tempbuffa[INPUT_BUFFER_LENGTH];
+        gnetwork->lastservercontact = gdata.curtime;
+        gnetwork->servertime = 0;
+        memset(&tempbuffa, 0, INPUT_BUFFER_LENGTH);
+        length = readserver_ssl(&tempbuffa, INPUT_BUFFER_LENGTH);
+
+        if (length < 1) {
+          if (errno != EAGAIN) {
+            ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
+                    "Closing Server Connection on %s: %s",
+                    gnetwork->name, (length<0) ? strerror(errno) : "Closed");
+            if (gdata.exiting) {
+              gnetwork->recentsent = 0;
+            }
+            close_server();
+            mydelete(gnetwork->curserveractualname);
+          }
+          continue;
+        }
+
+        j = strlen(gnetwork->server_input_line);
+        for (i=0; i<(unsigned int)length; ++i) {
+          if ((tempbuffa[i] == '\n') || (j == (INPUT_BUFFER_LENGTH-1))) {
+            if (j && (gnetwork->server_input_line[j-1] == 0x0D)) {
+              --j;
+            }
+            gnetwork->server_input_line[j] = '\0';
+            ir_parseline(gnetwork->server_input_line);
+            j = 0;
+          } else {
+            gnetwork->server_input_line[j] = tempbuffa[i];
+            ++j;
+          }
+        }
+        gnetwork->server_input_line[j] = '\0';
+      }
+      continue;
+    }
+
+    if (gnetwork->serverstatus == SERVERSTATUS_SSL_HANDSHAKE) {
+      if ((FD_ISSET(gnetwork->ircserver, &gdata.writeset)) || (FD_ISSET(gnetwork->ircserver, &gdata.readset))) {
+        handshake_ssl();
+      }
+      if (changesec)
+        irc_server_timeout();
+      continue;
+    }
+
+    if (gnetwork->serverstatus == SERVERSTATUS_TRYING) {
+      if (FD_ISSET(gnetwork->ircserver, &gdata.writeset)) {
+        int callval_i;
+        int connect_error;
+        SIGNEDSOCK int connect_error_len = sizeof(connect_error);
+        SIGNEDSOCK int addrlen;
+
+        callval_i = getsockopt(gnetwork->ircserver,
+                               SOL_SOCKET, SO_ERROR,
+                               &connect_error, &connect_error_len);
+
+        if (callval_i < 0) {
+          outerror(OUTERROR_TYPE_WARN,
+                   "Couldn't determine connection status: %s on %s",
+                   strerror(errno), gnetwork->name);
+          close_server();
+          continue;
+        }
+        if (connect_error) {
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+                  "Server Connection Failed: %s on %s", strerror(connect_error), gnetwork->name);
+          close_server();
+          continue;
+        }
+
+        ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+                "Server Connection to %s Established, Logging In",  gnetwork->name);
+        gnetwork->serverstatus = SERVERSTATUS_CONNECTED;
+        gnetwork->connecttime = gdata.curtime;
+        gnetwork->botstatus = BOTSTATUS_LOGIN;
+        ch = irlist_get_head(&(gnetwork->channels));
+        if (ch == NULL) {
+          gnetwork->botstatus = BOTSTATUS_JOINED;
+          start_sends();
+        }
+        FD_CLR(gnetwork->ircserver, &gdata.writeset);
+
+        addrlen = sizeof(gnetwork->myip);
+        bzero((char *) &(gnetwork->myip), sizeof(gnetwork->myip));
+        if (getsockname(gnetwork->ircserver, &(gnetwork->myip.sa), &addrlen) >= 0) {
+          if (gdata.debug > 0) {
+            char *msg;
+            msg = mymalloc(maxtextlength);
+            my_getnameinfo(msg, maxtextlength -1, &(gnetwork->myip.sa));
+            ioutput(OUT_S, COLOR_YELLOW, "using %s", msg);
+            mydelete(msg);
+          }
+          if (!gnetwork->usenatip) {
+            gnetwork->ourip = ntohl(gnetwork->myip.sin.sin_addr.s_addr);
+            if (gdata.debug > 0) {
+              ioutput(OUT_S, COLOR_YELLOW, "ourip = " IPV4_PRINT_FMT,
+                      IPV4_PRINT_DATA(gnetwork->ourip));
+            }
+          }
+        } else {
+          outerror(OUTERROR_TYPE_WARN, "couldn't get ourip on %s", gnetwork->name);
+        }
+
+        handshake_ssl();
+      }
+      if (changesec)
+        irc_server_timeout();
+      continue;
+    }
+
+    if (gnetwork->serverstatus == SERVERSTATUS_RESOLVING) {
+      if (FD_ISSET(gnetwork->serv_resolv.sp_fd[0], &gdata.readset)) {
+        res_addrinfo_t remote;
+        length = read(gnetwork->serv_resolv.sp_fd[0],
+                      &remote, sizeof(res_addrinfo_t));
+
+        kill(gnetwork->serv_resolv.child_pid, SIGKILL);
+        FD_CLR(gnetwork->serv_resolv.sp_fd[0], &gdata.readset);
+
+        if (length != sizeof(res_addrinfo_t)) {
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
+                  "Error resolving server %s on %s",
+                  gnetwork->curserver.hostname, gnetwork->name);
+          gnetwork->serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
+        } else {
+          /* continue with connect */
+          if (connectirc2(&remote)) {
+            /* failed */
+            gnetwork->serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
+          }
+        }
+      }
+      if (changesec) {
+        timeout = irc_server_is_timeout();
+        if (timeout > 0) {
+          kill(gnetwork->serv_resolv.child_pid, SIGKILL);
+          ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
+                  "Server Resolve Timed Out (%u seconds) on %s", timeout, gnetwork->name);
+          gnetwork->serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
+        }
+      }
+      continue;
+    }
+
+    if (gnetwork->offline)
+      continue;
+
+    if (gnetwork->serverstatus == SERVERSTATUS_NEED_TO_CONNECT) {
+      if (changesec) {
+        timeout = irc_server_is_timeout();
+        if (timeout > 0) {
+          if (gdata.debug > 0) {
+            ioutput(OUT_S, COLOR_YELLOW,
+                    "Reconnecting to server (%u seconds) on %s",
+                    timeout, gnetwork->name);
+          }
+          switchserver(-1);
+        }
+      }
+      continue;
+    }
+
+  } /* networks */
+  gnetwork = NULL;
+
+  /* reset after done on all networks */
+  if (gdata.needsswitch)
+    gdata.needsswitch = 0;
+}
+
 /* End of File */
Index: src/dinoex_irc.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_irc.h,v
retrieving revision 1.23
retrieving revision 1.26
diff -u -r1.23 -r1.26
--- src/dinoex_irc.h	6 Feb 2011 13:23:15 -0000	1.23
+++ src/dinoex_irc.h	12 Apr 2011 22:46:52 -0000	1.26
@@ -9,21 +9,20 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_irc.h,v 1.23 2011/02/06 13:23:15 cvs Exp $
+ * $Id: dinoex_irc.h,v 1.26 2011/04/12 22:46:52 cvs Exp $
  *
  */
 
 int my_getnameinfo(char *buffer, size_t len, const struct sockaddr *sa);
 void update_natip (const char *var);
-void update_server_welcome(char *line);
 unsigned int bind_irc_vhost(int family, int clientsocket);
 unsigned int open_listen(int family, ir_sockaddr_union_t *listenaddr, int *listen_socket, unsigned int port, unsigned int reuse, unsigned int search, const char *vhost);
 unsigned int irc_open_listen(ir_connection_t *con);
 void ir_setsockopt(int clientsocket);
 char *setup_dcc_local(ir_sockaddr_union_t *listenaddr);
 void child_resolver(int family);
+void irc_resolved(void);
 const char *my_dcc_ip_show(char *buffer, size_t len, ir_sockaddr_union_t *sa, unsigned int net);
-unsigned int connectirc2(res_addrinfo_t *remote);
 
 char *get_local_vhost(void);
 char *get_config_nick(void);
@@ -35,8 +34,8 @@
 unsigned int check_ignore(const char *nick, const char *hostmask);
 
 int irc_select(int highests);
+void irc_perform(int changesec);
 
 void identify_needed(unsigned int force);
-void identify_check(const char *line);
 
 /* End of File */
Index: src/dinoex_jobs.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_jobs.c,v
retrieving revision 1.167
retrieving revision 1.177
diff -u -r1.167 -r1.177
--- src/dinoex_jobs.c	6 Feb 2011 01:28:12 -0000	1.167
+++ src/dinoex_jobs.c	12 Jul 2011 19:17:54 -0000	1.177
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_jobs.c,v 1.167 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_jobs.c,v 1.177 2011/07/12 19:17:54 cvs Exp $
  *
  */
 
@@ -290,7 +290,7 @@
 
   len = vsnprintf(msg, maxtextlength, format, ap);
 
-  if ((len < 0) || (len >= maxtextlength)) {
+  if ((len < 0) || (len >= (int)maxtextlength)) {
     outerror(OUTERROR_TYPE_WARN, "WRITESERVER: Output too large, ignoring!");
     mydelete(msg);
     return;
@@ -349,7 +349,7 @@
 
   len = vsnprintf(tempstr, maxtextlength, format, ap);
 
-  if ((len < 0) || (len >= maxtextlength)) {
+  if ((len < 0) || (len >= (int)maxtextlength)) {
     outerror(OUTERROR_TYPE_WARN, "PRVMSG-CHAN: Output too large, ignoring!");
     return;
   }
@@ -778,13 +778,11 @@
   else
     snprintf(line, maxtextlength, "ADDNEW \"%s\"", dir); /* NOTRANSLATE */
 
-  uxdl = mycalloc(sizeof(userinput));
+  uxdl = irlist_add(&gdata.packs_delayed, sizeof(userinput));
   a_fillwith_msg2(uxdl, NULL, line);
   uxdl->method = method_out_all;
   uxdl->net = 0;
   uxdl->level = ADMIN_LEVEL_AUTO;
-  u_parseit(uxdl);
-  mydelete(uxdl);
   mydelete(line);
 }
 
@@ -828,6 +826,20 @@
       /* process only one file */
       return;
     }
+    if (strcmp(u->cmd, "ADDGROUP") == 0) { /* NOTRANSLATE */
+      a_addgroup(u);
+      free_userinput(u);
+      u = irlist_delete(&gdata.packs_delayed, u);
+      /* process only one file */
+      return;
+    }
+    if (strcmp(u->cmd, "ADDNEW") == 0) { /* NOTRANSLATE */
+      a_addnew(u);
+      free_userinput(u);
+      u = irlist_delete(&gdata.packs_delayed, u);
+      /* process only one file */
+      return;
+    }
     /* ignore */
     outerror(OUTERROR_TYPE_WARN, "Unknown cmd %s in packs_delayed", u->cmd);
     u = irlist_delete(&gdata.packs_delayed, u);
@@ -1030,7 +1042,7 @@
   xd->mtime    = st.st_mtime;
 }
 
-void import_xdccfile(void)
+unsigned int import_xdccfile(void)
 {
   char *templine;
   char *word;
@@ -1043,8 +1055,9 @@
   char *xx_trno = NULL;
   FILE *fin;
   float val;
+  unsigned int found = 0;
   unsigned int part;
-  unsigned int err;
+  unsigned int err = 0;
   unsigned int step = 0;
   unsigned int xx_gets = 0;
   float xx_mins = 0.0;
@@ -1053,16 +1066,15 @@
   updatecontext();
 
   if (gdata.import == NULL)
-    return;
+    return found;
 
   fin = fopen(gdata.import, "r" ); /* NOTRANSLATE */
   if (fin == NULL) {
     outerror(OUTERROR_TYPE_WARN_LOUD, "Cant Access XDCC File '%s': %s", gdata.import, strerror(errno));
-    return;
+    return found;
   }
 
   templine = mymalloc(maxtextlength);
-  err = 0;
   while (!feof(fin)) {
     r = fgets(templine, maxtextlength - 1, fin);
     if (r == NULL )
@@ -1109,6 +1121,7 @@
         xx_gets = 0;
         xx_mins = 0.0;
         xx_maxs = 0.0;
+        ++found;
       }
       continue;
     }
@@ -1175,13 +1188,13 @@
   if (err > 0) {
     outerror(OUTERROR_TYPE_CRASH, "Error in XDCC File: %s", templine);
     mydelete(templine);
-    return;
+    return found;
   }
   mydelete(templine)
 
   if (step == 0) {
     outerror(OUTERROR_TYPE_WARN_LOUD, "Empty XDCC File");
-    return;
+    return found;
   }
   if (xx_file != NULL) {
     import_pack(xx_file, xx_desc, xx_note, xx_gets, xx_mins, xx_maxs, xx_data, xx_trno);
@@ -1190,7 +1203,9 @@
     mydelete(xx_note);
     mydelete(xx_data);
     mydelete(xx_trno);
+    ++found;
   }
+  return found;
 }
 
 void autotrigger_add(xdcc *xd)
@@ -1780,6 +1795,28 @@
     mydelete(u);
 }
 
+void send_periodicmsg(void)
+{
+  periodicmsg_t *pm;
+
+  updatecontext();
+
+  for (pm = irlist_get_head(&gdata.periodicmsg);
+       pm;
+       pm = irlist_get_next(pm)) {
+    gnetwork = &(gdata.networks[pm->pm_net]);
+    if (gnetwork->serverstatus != SERVERSTATUS_CONNECTED)
+      continue;
+
+    if ((unsigned)gdata.curtime <= pm->pm_next_time)
+      continue;
+
+    pm->pm_next_time = gdata.curtime + (pm->pm_time * 60);
+    privmsg(pm->pm_nick, "%s", pm->pm_msg);
+  }
+  gnetwork = NULL;
+}
+
 static char *r_local_vhost;
 static char *r_config_nick;
 
@@ -1788,6 +1825,7 @@
   *dest = *src;
   src->size = 0;
   src->head = NULL;
+  src->tail = NULL;
 }
 
 void a_rehash_prepare(void)
@@ -1989,29 +2027,22 @@
 
   if (!gdata.config_nick) {
     a_respond(u, "user_nick missing! keeping old nick!");
-    gdata.config_nick = r_config_nick;
-    r_config_nick = NULL;
-    for (ss=0; ss<gdata.networks_online; ++ss) {
-      mydelete(gnetwork->config_nick);
-      gnetwork->config_nick = gnetwork->r_config_nick;
-      mydelete(gnetwork->r_local_vhost);
-    }
-  } else {
-    backup = gnetwork;
-    for (ss=0; ss<gdata.networks_online; ++ss) {
-      gnetwork = &(gdata.networks[ss]);
-      old_nick = (gnetwork->r_config_nick) ? gnetwork->r_config_nick : r_config_nick;
-      new_nick = get_config_nick();
-      if (strcmp(new_nick, old_nick)) {
-        a_respond(u, "user_nick changed, renaming nick to %s", new_nick);
-        writeserver(WRITESERVER_NOW, "NICK %s", new_nick); /* NOTRANSLATE */
-      }
-      mydelete(gnetwork->r_config_nick);
-      mydelete(gnetwork->r_local_vhost);
+    gdata.config_nick = mystrdup(r_config_nick);
+  }
+  backup = gnetwork;
+  for (ss=0; ss<gdata.networks_online; ++ss) {
+    gnetwork = &(gdata.networks[ss]);
+    old_nick = (gnetwork->r_config_nick) ? gnetwork->r_config_nick : r_config_nick;
+    new_nick = get_config_nick();
+    if (strcmp(new_nick, old_nick)) {
+      a_respond(u, "user_nick changed, renaming nick to %s", new_nick);
+      writeserver(WRITESERVER_NOW, "NICK %s", new_nick); /* NOTRANSLATE */
     }
-    gnetwork = backup;
-    mydelete(r_config_nick);
+    mydelete(gnetwork->r_config_nick);
+    mydelete(gnetwork->r_local_vhost);
   }
+  gnetwork = backup;
+  mydelete(r_config_nick);
   mydelete(r_local_vhost);
   if (gdata.xdcclist_grouponly != gdata.r_xdcclist_grouponly)
     write_files();
@@ -2241,6 +2272,48 @@
   return 1;
 }
 
+/* delayed_announce */
+void delayed_announce(void)
+{
+  xdcc *xd;
+  unsigned int packnum;
+
+  /* stop here if more to add/remove prending */
+  if (irlist_size(&gdata.packs_delayed) > 0)
+    return;
+
+  if (gdata.nomd5sum == 0) {
+    if (gdata.md5build.xpack) {
+      /* checsum in progress */
+      return;
+    }
+  }
+
+  packnum = 1;
+  for (xd = irlist_get_head(&gdata.xdccs);
+       xd;
+       xd = irlist_get_next(xd), ++packnum) {
+    if (xd->announce == 0)
+      continue;
+
+    if (gdata.nomd5sum == 0) {
+      if (xd->has_md5sum == 0)
+        continue;
+    }
+    if (gdata.nocrc32 == 0) {
+      if (xd->has_crc32 == 0)
+        continue;
+    }
+
+    /* wait for pack to be unlocked */
+    if (xd->lock != NULL)
+      continue;
+
+    xd->announce = 0;
+    a_autoaddann(xd, packnum);
+  }
+}
+
 static magic_crc_t magic_crc_table[] = {
   { 0x24, 7, { 0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00, 0} },
   { 0x0E, 4, { 0x50, 0x4b, 0x03, 0x04, 0, 0, 0, 0 } },
@@ -2276,7 +2349,7 @@
   ir_uint32 zipcrc32;
   unsigned int i;
 
-  for (i=0; magic_crc_table[i].len > 0; i++) {
+  for (i=0; magic_crc_table[i].len > 0; ++i) {
     if (memcmp(buffer, magic_crc_table[i].magic, magic_crc_table[i].len) != 0)
       continue;
     zipcrc32 = 0;
Index: src/dinoex_jobs.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_jobs.h,v
retrieving revision 1.41
retrieving revision 1.44
diff -u -r1.41 -r1.44
--- src/dinoex_jobs.h	5 Feb 2011 11:05:54 -0000	1.41
+++ src/dinoex_jobs.h	9 Jun 2011 09:46:46 -0000	1.44
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_jobs.h,v 1.41 2011/02/05 11:05:54 cvs Exp $
+ * $Id: dinoex_jobs.h,v 1.44 2011/06/09 09:46:46 cvs Exp $
  *
  */
 
@@ -54,7 +54,7 @@
 void run_delayed_jobs(void);
 const char *find_groupdesc(const char *group);
 void write_removed_xdcc(xdcc *xd);
-void import_xdccfile(void);
+unsigned int import_xdccfile(void);
 void autotrigger_add(xdcc *xd);
 void autotrigger_rebuild(void);
 void start_md5_hash(xdcc *xd, unsigned int packnum);
@@ -66,6 +66,7 @@
 void start_qupload(void);
 int close_qupload(unsigned int net, const char *nick);
 void lag_message(void);
+void send_periodicmsg(void);
 
 void a_rehash_prepare(void);
 void a_rehash_needtojump(const userinput *u);
@@ -77,6 +78,7 @@
 char *new_logfilename(const char *logfile);
 void expire_logfiles(const char *logfile);
 int rotatelog(const char *logfile);
+void delayed_announce(void);
 
 ir_uint32 get_zip_crc32_pack(xdcc *xd);
 
Index: src/dinoex_main.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_main.c,v
retrieving revision 1.29
retrieving revision 1.34
diff -u -r1.29 -r1.34
--- src/dinoex_main.c	6 Feb 2011 01:28:12 -0000	1.29
+++ src/dinoex_main.c	10 Jun 2011 05:43:05 -0000	1.34
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_main.c,v 1.29 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_main.c,v 1.34 2011/06/10 05:43:05 cvs Exp $
  *
  */
 
@@ -132,13 +132,13 @@
         gdata.import = cptr;
         break;
       case 'k': /* adjust core */
-        gdata.adjustcore = 1;
+        ++(gdata.adjustcore);
         break;
       case 'n': /* no color */
-        gdata.nocolor = 1;
+        ++(gdata.nocolor);
         break;
       case 's': /* no screen */
-        gdata.noscreen = 1;
+        ++(gdata.noscreen);
         break;
 #if !defined(NO_CHROOT)
       case 't': /* chroot dir */
@@ -275,7 +275,7 @@
      mydelete(xd->trigger);
   }
 
-  for (ss=0; ss<gdata.networks_online; ++ss) {
+  for (ss = gdata.networks_online; ss--; ) {
     gnetwork = &(gdata.networks[ss]);
     mydelete(gnetwork->curserveractualname);
     mydelete(gnetwork->user_nick);
@@ -312,6 +312,7 @@
      mydelete(tr->hostname);
      mydelete(tr->con.localaddr);
      mydelete(tr->con.remoteaddr);
+     mydelete(tr->country);
   }
 
   for (up = irlist_get_head(&gdata.uploads);
@@ -365,6 +366,7 @@
        mime;
        mime = irlist_delete(&gdata.mime_type, mime)) {
      mydelete(mime->m_ext);
+     mydelete(mime->m_mime);
   }
   for (ag = irlist_get_head(&gdata.autoadd_group_match);
        ag;
@@ -410,7 +412,7 @@
   unsigned int j;
   unsigned int leak = 0;
 
-  gdata.crashing = 1; /* stop traceback */
+  ++(gdata.crashing); /* stop traceback */
   signal(SIGSEGV, SIG_DFL);
   free_state();
   free_config();
Index: src/dinoex_misc.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_misc.c,v
retrieving revision 1.329
retrieving revision 1.338
diff -u -r1.329 -r1.338
--- src/dinoex_misc.c	6 Feb 2011 01:28:12 -0000	1.329
+++ src/dinoex_misc.c	12 Jul 2011 19:17:54 -0000	1.338
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_misc.c,v 1.329 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_misc.c,v 1.338 2011/07/12 19:17:54 cvs Exp $
  *
  */
 
@@ -151,7 +151,7 @@
        xd;
        xd = irlist_get_next(xd)) {
     if (xd->group != NULL) {
-      gdata.support_groups = 1;
+      ++(gdata.support_groups);
       return;
     }
   }
@@ -901,7 +901,7 @@
 }
 
 /* select a transfer to start with */
-int select_starting_transfer(unsigned int max)
+unsigned int select_starting_transfer(unsigned int max)
 {
   unsigned int t;
 
@@ -913,22 +913,22 @@
 }
 
 static const char *style_on[ 16 ] = {
-  /* 0 = none */ "", /* NOTRANSLATE */
-  /* 1 = bold */ "\x02", /* NOTRANSLATE */
-  /* 2 = underline */ "\x1F", /* NOTRANSLATE */
-  /* 3 = bold, underline */ "\x02\x1F", /* NOTRANSLATE */
-  /* 4 = italic */ "\x1D", /* NOTRANSLATE */
-  /* 5 = bold, italic */ "\x02\x1D", /* NOTRANSLATE */
-  /* 6 = underline, italic */ "\x1F\x1D", /* NOTRANSLATE */
-  /* 7 = bold, underline, italic */ "\x02\x1F\x1D", /* NOTRANSLATE */
-  /* 8 = inverse */ "\x16", /* NOTRANSLATE */
-  /* 9 = bold, inverse */ "\x02\x16", /* NOTRANSLATE */
-  /* 10 = underline, inverse */ "\x1F\x16", /* NOTRANSLATE */
-  /* 11 = bold, underline, inverse */ "\x02\x1F\x16", /* NOTRANSLATE */
-  /* 12 = italic, inverse */ "\x1D\x16", /* NOTRANSLATE */
-  /* 13 = bold, italic, inverse */ "\x02\x1D\x16", /* NOTRANSLATE */
-  /* 14 = underline, italic, inverse */ "\x1F\x1D\x16", /* NOTRANSLATE */
-  /* 15 = bold, underline, italic, inverse */ "\x02\x1F\x1D\x16", /* NOTRANSLATE */
+  /* 0 =*/ "", /* NOTRANSLATE */
+  /* 1 =*/ IRC_BOLD,
+  /* 2 =*/           IRC_UNDERLINE,
+  /* 3 =*/ IRC_BOLD  IRC_UNDERLINE,
+  /* 4 =*/                          IRC_ITALIC,
+  /* 5 =*/ IRC_BOLD                 IRC_ITALIC,
+  /* 6 =*/           IRC_UNDERLINE  IRC_ITALIC,
+  /* 7 =*/ IRC_BOLD  IRC_UNDERLINE  IRC_ITALIC,
+  /* 8 =*/                                      IRC_INVERSE,
+  /* 9 =*/ IRC_BOLD                             IRC_INVERSE,
+  /* 10 */           IRC_UNDERLINE              IRC_INVERSE,
+  /* 11 */ IRC_BOLD  IRC_UNDERLINE              IRC_INVERSE,
+  /* 12 */                          IRC_ITALIC  IRC_INVERSE,
+  /* 13 */ IRC_BOLD                 IRC_ITALIC  IRC_INVERSE,
+  /* 14 */           IRC_UNDERLINE  IRC_ITALIC  IRC_INVERSE,
+  /* 15 */ IRC_BOLD  IRC_UNDERLINE  IRC_ITALIC  IRC_INVERSE
 };
 
 /* colored text */
@@ -950,14 +950,14 @@
    background = (color >> 8) & 0xFF;
    style = (color >> 16 ) & 0x0F;
    if (background != 0) {
-     snprintf(colordesc, maxtextlength, "%s\003%02u,%02u%s\003\017", style_on[ style ], foreground, background, desc); /* NOTRANSLATE */
+     snprintf(colordesc, maxtextlength, "%s" IRC_COLOR "%02u,%02u%s" IRC_COLOR IRC_NORMAL, style_on[ style ], foreground, background, desc); /* NOTRANSLATE */
      return colordesc;
    }
    if (foreground != 0) {
-     snprintf(colordesc, maxtextlength, "%s\003%02u%s\003\017", style_on[ style ], foreground, desc); /* NOTRANSLATE */
+     snprintf(colordesc, maxtextlength, "%s" IRC_COLOR "%02u%s" IRC_COLOR IRC_NORMAL, style_on[ style ], foreground, desc); /* NOTRANSLATE */
      return colordesc;
    }
-   snprintf(colordesc, maxtextlength, "%s%s\017", style_on[ style ], desc); /* NOTRANSLATE */
+   snprintf(colordesc, maxtextlength, "%s%s" IRC_NORMAL, style_on[ style ], desc); /* NOTRANSLATE */
    return colordesc;
 }
 
@@ -1016,6 +1016,20 @@
   return "full"; /* NOTRANSLATE */
 }
 
+/* free all strings from userinput*/
+void free_userinput(userinput * const u)
+{
+  mydelete(u->snick);
+  mydelete(u->hostmask);
+  mydelete(u->cmd);
+  mydelete(u->arg1e);
+  mydelete(u->arg2e);
+  mydelete(u->arg3e);
+  mydelete(u->arg1);
+  mydelete(u->arg2);
+  mydelete(u->arg3);
+}
+
 /* drop all delayed actions */
 void free_delayed(void)
 {
@@ -1024,9 +1038,7 @@
   for (u = irlist_get_head(&gdata.packs_delayed);
        u;
        u = irlist_delete(&gdata.packs_delayed, u)) {
-     mydelete(u->cmd);
-     mydelete(u->arg1);
-     mydelete(u->arg2);
+     free_userinput(u);
   }
 }
 
@@ -1077,7 +1089,7 @@
     outerror(OUTERROR_TYPE_WARN_LOUD,
              "File '%s' has changed",
              gdata.configfile[h]);
-    gdata.needsrehash = 1;
+    ++(gdata.needsrehash);
   }
 }
 
@@ -1104,7 +1116,7 @@
 
   for (;;) {
     len = 0;
-    for (j=0; j<16; j++) {
+    for (j=0; j<16; ++j) {
       if (j >= max) {
         len += snprintf(buffer + len, maxtextlength - len, "   "); /* NOTRANSLATE */
       } else {
@@ -1112,7 +1124,7 @@
       }
     }
     len += snprintf(buffer + len, maxtextlength - len, " \""); /* NOTRANSLATE */
-    for (j=0; j<16; j++) {
+    for (j=0; j<16; ++j) {
       if (j >= max)
         break;
       len += snprintf(buffer + len, maxtextlength - len, "%c", onlyprintable(ut[j])); /* NOTRANSLATE */
@@ -1188,4 +1200,46 @@
   return atoi(a);
 }
 
+/* dump slow functions */
+void dump_slow_context(void)
+{
+  char *lastline;
+  context_t *c;
+  context_t *last;
+  ir_uint64 offset;
+  unsigned int i;
+  unsigned int show;
+
+  last = NULL;
+  lastline = mymalloc(maxtextlength);
+  lastline[0] = 0;
+  for (i=0; i<MAXCONTEXTS; ++i) {
+    c = &gdata.context_log[(gdata.context_cur_ptr + 1 + i) % MAXCONTEXTS];
+    if (c->file == NULL)
+      continue;
+    show = 0;
+    if (last != NULL) {
+      offset = c->tv.tv_sec - last->tv.tv_sec;
+      offset *= 1000000;
+      offset += c->tv.tv_usec - last->tv.tv_usec;
+      if (offset > 171000) {
+        ioutput(OUT_S|OUT_L, COLOR_NO_COLOR, "%s", lastline);
+        show = 1;
+      }
+    }
+    snprintf(lastline, maxtextlength,
+            "Trace %3i  %-20s %-16s:%5i  %lu.%06lu",
+            i-MAXCONTEXTS+1,
+            c->func ? c->func : "UNKNOWN",
+            c->file ? c->file : "UNKNOWN",
+            c->line,
+            (unsigned long)c->tv.tv_sec,
+            (unsigned long)c->tv.tv_usec);
+    last = c;
+    if (show)
+      ioutput(OUT_S|OUT_L, COLOR_NO_COLOR, "%s", lastline);
+  }
+  mydelete(lastline);
+}
+
 /* End of File */
Index: src/dinoex_misc.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_misc.h,v
retrieving revision 1.129
retrieving revision 1.133
diff -u -r1.129 -r1.133
--- src/dinoex_misc.h	5 Feb 2011 11:05:55 -0000	1.129
+++ src/dinoex_misc.h	12 Jul 2011 19:17:54 -0000	1.133
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_misc.h,v 1.129 2011/02/05 11:05:55 cvs Exp $
+ * $Id: dinoex_misc.h,v 1.133 2011/07/12 19:17:54 cvs Exp $
  *
  */
 
@@ -34,7 +34,6 @@
 
 unsigned int init_xdcc_file(xdcc *xd, char *file) ;
 void update_hour_dinoex(unsigned int minute);
-void check_new_connection(transfer *const tr);
 unsigned int fnmatch_xdcc(const char *match, xdcc *xd);
 
 unsigned int disk_full(const char *path);
@@ -58,7 +57,7 @@
 
 void add_newest_xdcc(irlist_t *list, const char *grouplist);
 
-int select_starting_transfer(unsigned int max);
+unsigned int select_starting_transfer(unsigned int max);
 
 char *color_text(char *desc, unsigned int color);
 char *xd_color_description(const xdcc *xd);
@@ -68,6 +67,7 @@
 const char *text_connectionmethod(how_e how);
 const char *text_pformat(unsigned int val);
 
+void free_userinput(userinput * const u);
 void free_delayed(void);
 void free_channel_data(channel_t *ch);
 
@@ -77,4 +77,6 @@
 
 int packnumtonum(const char *a);
 
+void dump_slow_context(void);
+
 /* End of File */
Index: src/dinoex_queue.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_queue.c,v
retrieving revision 1.32
retrieving revision 1.38
diff -u -r1.32 -r1.38
--- src/dinoex_queue.c	6 Feb 2011 01:28:12 -0000	1.32
+++ src/dinoex_queue.c	17 Jul 2011 20:14:43 -0000	1.38
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_queue.c,v 1.32 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_queue.c,v 1.38 2011/07/17 20:14:43 cvs Exp $
  *
  */
 
@@ -112,8 +112,8 @@
   }
 }
 
-/* remove all packs a user has because of his slowness */
-void queue_punishslowusers(irlist_t *list, unsigned int network, const char *nick)
+/* remove all packs a user has */
+static void queue_punish_user(irlist_t *list, const char *msg, unsigned int network, const char *nick)
 {
   gnetwork_t *backup;
   ir_pqueue *pq;
@@ -130,7 +130,7 @@
 
     backup = gnetwork;
     gnetwork = &(gdata.networks[pq->net]);
-    notice(nick, "** Removed From Queue: You are being punished for your slowness");
+    notice(nick, "** Removed From Queue: %s", msg );
     gnetwork = backup;
     mydelete(pq->nick);
     mydelete(pq->hostname);
@@ -138,6 +138,13 @@
   }
 }
 
+/* remove all packs a user has because he has abused the bot */
+void queue_punish_abuse(const char *msg, unsigned int network, const char *nick)
+{
+  queue_punish_user(&gdata.mainqueue, msg, network, nick);
+  queue_punish_user(&gdata.idlequeue, msg, network, nick);
+}
+
 /* remove all packs a user has because he send us XDCC REMOVE */
 unsigned int queue_xdcc_remove(irlist_t *list, unsigned int network, const char *nick, unsigned int number)
 {
@@ -229,6 +236,9 @@
   for (pq = irlist_get_head(list);
        pq;
        pq = irlist_get_next(pq)) {
+    if (pq->net != gnetwork->net)
+      continue;
+
     if (strcmp(pq->hostname, hostname))
       continue;
 
@@ -285,10 +295,10 @@
 
   snprintf(tempstr, maxtextlength,
            "Added you to the idle queue for pack %u (\"%s\") in position %u. To Remove yourself at "
-           "a later time type \"/MSG %s XDCC REMOVE\".",
+           "a later time type \"/MSG %s XDCC REMOVE %u\".",
            pack, xd->desc,
            irlist_size(&gdata.idlequeue),
-           get_user_nick());
+           get_user_nick(), pack);
   *msg = "Queued (idle slot)";
   return 0;
 }
@@ -310,12 +320,12 @@
 
   tempx = get_xdcc_pack(pack);
 
+  man = 0;
   if (hostname != NULL) {
     hostname2 = hostname;
-    man = 0;
   } else {
     hostname2 = "man"; /* NOTRANSLATE */
-    man = 1;
+    ++man;
   }
 
   inq = 0;
@@ -331,7 +341,7 @@
   }
 
   if (hostname != NULL) {
-    if (inq >= gdata.maxqueueditemsperperson) {
+    if ((inq >= gdata.maxqueueditemsperperson) || (inq2 > 0 )) {
       fatal = addtoidlequeue(msg, tempstr, nick, hostname, tempx, pack, inq2);
       if (*msg != NULL)
         return fatal;
@@ -367,26 +377,25 @@
 
   snprintf(tempstr, maxtextlength,
            "Added you to the main queue for pack %u (\"%s\") in position %u. To Remove yourself at "
-           "a later time type \"/MSG %s XDCC REMOVE\".",
+           "a later time type \"/MSG %s XDCC REMOVE %u\".",
            pack, tempx->desc,
            irlist_size(&gdata.mainqueue),
-           save_nick(gnetwork->user_nick));
+           save_nick(gnetwork->user_nick), pack);
 
   *msg = "Queued (slot)";
   return 0;
 }
 
-
 static const char *send_queue_msg[] = { "", " (low bandwidth)", " (manual)" };
 
 /* send the next item form the queue */
 void send_from_queue(unsigned int type, unsigned int pos, char *lastnick)
 {
-  unsigned int usertrans;
-  unsigned int pack;
   ir_pqueue *pq;
   transfer *tr;
   gnetwork_t *backup;
+  unsigned int usertrans;
+  unsigned int pack;
 
   updatecontext();
 
@@ -396,86 +405,86 @@
   if (!gdata.balanced_queue)
     lastnick = NULL;
 
-  if (irlist_size(&gdata.mainqueue)) {
-    /*
-     * first determine what the first queue position is that is eligable
-     * for a transfer find the first person who has not already maxed out
-     * his sends if noone, do nothing and let execution continue to pack
-     * queue check
-     */
-
-    if (pos > 0) {
-      /* get specific entry */
-      pq = irlist_get_nth(&gdata.mainqueue, pos - 1);
-    } else {
-      for (pq = irlist_get_head(&gdata.mainqueue); pq; pq = irlist_get_next(pq)) {
-        if (gdata.networks[pq->net].serverstatus != SERVERSTATUS_CONNECTED)
-          continue;
-
-        if (gdata.networks[pq->net].botstatus != BOTSTATUS_JOINED)
-          continue;
+  if (irlist_size(&gdata.mainqueue) == 0)
+    return;
 
-        /* timeout for restart must be less then Transfer Timeout 180s */
-        if (gdata.curtime - gdata.networks[pq->net].lastservercontact > 150)
-          continue;
+  /*
+   * first determine what the first queue position is that is eligable
+   * for a transfer find the first person who has not already maxed out
+   * his sends if noone, do nothing and let execution continue to pack
+   * queue check
+   */
+
+  if (pos > 0) {
+    /* get specific entry */
+    pq = irlist_get_nth(&gdata.mainqueue, pos - 1);
+  } else {
+    for (pq = irlist_get_head(&gdata.mainqueue); pq; pq = irlist_get_next(pq)) {
+      if (gdata.networks[pq->net].serverstatus != SERVERSTATUS_CONNECTED)
+        continue;
 
-        usertrans = 0;
-        for (tr = irlist_get_head(&gdata.trans); tr; tr = irlist_get_next(tr)) {
-          if ((!strcmp(tr->hostname, pq->hostname)) || (!strcasecmp(tr->nick, pq->nick))) {
-            ++usertrans;
-          }
-        }
+      if (gdata.networks[pq->net].botstatus != BOTSTATUS_JOINED)
+        continue;
 
-       /* usertrans is the number of transfers a user has in progress */
-        if (usertrans >= gdata.maxtransfersperperson)
-          continue;
+      /* timeout for restart must be less then Transfer Timeout 180s */
+      if (gdata.curtime - gdata.networks[pq->net].lastservercontact > 150)
+        continue;
 
-        /* skip last trasfering user */
-        if (lastnick != NULL) {
-          if (!strcasecmp(pq->nick, lastnick))
-            continue;
+      usertrans = 0;
+      for (tr = irlist_get_head(&gdata.trans); tr; tr = irlist_get_next(tr)) {
+        if ((!strcmp(tr->hostname, pq->hostname)) || (!strcasecmp(tr->nick, pq->nick))) {
+          ++usertrans;
         }
-
-        /* found the person that will get the send */
-        break;
       }
-    }
 
-    if (!pq) {
+     /* usertrans is the number of transfers a user has in progress */
+      if (usertrans >= gdata.maxtransfersperperson)
+        continue;
+
+      /* skip last trasfering user */
       if (lastnick != NULL) {
-        /* try again */
-        send_from_queue(type, pos, NULL);
+        if (!strcasecmp(pq->nick, lastnick))
+          continue;
       }
-      return;
+
+      /* found the person that will get the send */
+      break;
     }
+  }
 
-    if (type > 2) type = 0;
-    pack = number_of_pack(pq->xpack);
-    ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
-            "QUEUED SEND%s: %s (%s on %s), Pack #%u",
-            send_queue_msg[ type ],
-            pq->nick, pq->hostname, gdata.networks[ pq->net ].name, pack);
-
-    if (pack == XDCC_SEND_LIST)
-      init_xdcc_file(pq->xpack, gdata.xdcclistfile);
-    look_for_file_changes(pq->xpack);
+  if (!pq) {
+    if (lastnick != NULL) {
+      /* try again */
+      send_from_queue(type, pos, NULL);
+    }
+    return;
+  }
 
-    backup = gnetwork;
-    gnetwork = &(gdata.networks[pq->net]);
+  if (type > 2) type = 0;
+  pack = number_of_pack(pq->xpack);
+  ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
+          "QUEUED SEND%s: %s (%s on %s), Pack #%u",
+          send_queue_msg[ type ],
+          pq->nick, pq->hostname, gdata.networks[ pq->net ].name, pack);
+
+  if (pack == XDCC_SEND_LIST)
+    init_xdcc_file(pq->xpack, gdata.xdcclistfile);
+  look_for_file_changes(pq->xpack);
 
-    tr = create_transfer(pq->xpack, pq->nick, pq->hostname);
-    mydelete(pq->nick);
-    mydelete(pq->hostname);
-    irlist_delete(&gdata.mainqueue, pq);
+  backup = gnetwork;
+  gnetwork = &(gdata.networks[pq->net]);
 
-    t_notice_transfer(tr, NULL, pack, 1);
-    t_unlmited(tr, NULL);
-    t_setup_dcc(tr);
+  tr = create_transfer(pq->xpack, pq->nick, pq->hostname);
+  mydelete(pq->nick);
+  mydelete(pq->hostname);
+  irlist_delete(&gdata.mainqueue, pq);
+
+  t_notice_transfer(tr, NULL, pack, 1);
+  t_unlmited(tr, NULL);
+  t_setup_dcc(tr);
 
-    gnetwork = backup;
-    check_idle_queue();
-    return;
-  }
+  gnetwork = backup;
+  check_idle_queue(0);
 }
 
 /* start sending one queued pack */
@@ -498,29 +507,14 @@
   }
 }
 
-/* check idle queue and move one entry into the main queue */
-void check_idle_queue(void)
+static ir_pqueue *find_in_idle_queue(void)
 {
   ir_pqueue *pq;
   ir_pqueue *mq;
-  ir_pqueue *tempq;
   transfer *tr;
   unsigned int usertrans;
   unsigned int pass;
 
-  updatecontext();
-  if (gdata.exiting)
-    return;
-
-  if (gdata.holdqueue)
-    return;
-
-  if (irlist_size(&gdata.idlequeue) == 0)
-    return;
-
-  if (irlist_size(&gdata.mainqueue) >= gdata.queuesize)
-    return;
-
   pq = NULL;
   for (pass = 0; pass < 2; ++pass) {
     for (pq = irlist_get_head(&gdata.idlequeue);
@@ -565,6 +559,33 @@
       break; /* found the person that will get the send */
     }
   }
+  return pq;
+}
+
+/* check idle queue and move one entry into the main queue */
+void check_idle_queue(unsigned int pos)
+{
+  ir_pqueue *pq;
+  ir_pqueue *tempq;
+
+  updatecontext();
+  if (gdata.exiting)
+    return;
+
+  if (gdata.holdqueue)
+    return;
+
+  if (irlist_size(&gdata.idlequeue) == 0)
+    return;
+
+  if (irlist_size(&gdata.mainqueue) >= gdata.queuesize)
+    return;
+
+  if (pos == 0) {
+    pq = find_in_idle_queue();
+  } else {
+    pq = irlist_get_nth(&gdata.idlequeue, pos - 1);
+  }
   if (pq == NULL)
     return;
 
@@ -581,7 +602,7 @@
   unsigned int i;
 
   for (i=0; i<gdata.queuesize; ++i) {
-    check_idle_queue();
+    check_idle_queue(0);
   }
 }
 
Index: src/dinoex_queue.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_queue.h,v
retrieving revision 1.13
retrieving revision 1.17
diff -u -r1.13 -r1.17
--- src/dinoex_queue.h	6 Jul 2010 17:08:17 -0000	1.13
+++ src/dinoex_queue.h	1 Jul 2011 09:52:56 -0000	1.17
@@ -1,6 +1,6 @@
 /*
  * by Dirk Meyer (dinoex)
- * Copyright (C) 2004-2010 Dirk Meyer
+ * Copyright (C) 2004-2011 Dirk Meyer
  *
  * By using this file, you agree to the terms and conditions set
  * forth in the GNU General Public License.  More information is
@@ -9,13 +9,13 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_queue.h,v 1.13 2010/07/06 17:08:17 cvs Exp $
+ * $Id: dinoex_queue.h,v 1.17 2011/07/01 09:52:56 cvs Exp $
  *
  */
 
 void queue_update_nick(irlist_t *list, const char *oldnick, const char *newnick);
 void queue_reverify_restrictsend(irlist_t *list);
-void queue_punishslowusers(irlist_t *list, unsigned int network, const char *nick);
+void queue_punish_abuse(const char *msg, unsigned int network, const char *nick);
 unsigned int queue_xdcc_remove(irlist_t *list, unsigned int network, const char *nick, unsigned int number);
 void queue_pack_limit(irlist_t *list, xdcc *xd);
 void queue_pack_remove(irlist_t *list, xdcc *xd);
@@ -26,7 +26,7 @@
 void send_from_queue(unsigned int type, unsigned int pos, char *lastnick);
 void start_one_send(void);
 void start_sends(void);
-void check_idle_queue(void);
+void check_idle_queue(unsigned int pos);
 void start_main_queue(void);
 ir_pqueue *requeue(transfer *tr, ir_pqueue *old);
 
Index: src/dinoex_ruby.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_ruby.c,v
retrieving revision 1.42
retrieving revision 1.46
diff -u -r1.42 -r1.46
--- src/dinoex_ruby.c	6 Feb 2011 14:24:50 -0000	1.42
+++ src/dinoex_ruby.c	21 Jul 2011 02:34:22 -0000	1.46
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_ruby.c,v 1.42 2011/02/06 14:24:50 cvs Exp $
+ * $Id: dinoex_ruby.c,v 1.46 2011/07/21 02:34:22 cvs Exp $
  *
  * See also:
  * http://www.ruby-doc.org/docs/ProgrammingRuby/html/ext_ruby.html
@@ -35,10 +35,23 @@
 #pragma GCC diagnostic ignored "-Wredundant-decls"
 #include "ruby.h"
 #if USE_RUBYVERSION < 19
+#ifndef RSTRING_PTR
+#define RSTRING_PTR(s) (RSTRING(s)->ptr)
+#endif
+#ifndef RARRAY_LEN
+#define RARRAY_LEN(s) (RARRAY(s)->len)
+#endif
+#ifndef RARRAY_PTR
+#define RARRAY_PTR(s) (RARRAY(s)->ptr)
+#endif
+#ifndef RUBY_INIT_STACK
+#define RUBY_INIT_STACK ;
+#endif
 #else
 #include <ruby/encoding.h>
 #endif
 
+
 typedef struct protect_call_arg {
   VALUE *argv;
   VALUE recvobj;
@@ -193,6 +206,14 @@
   return copy;
 }
 
+static VALUE cie_mynick(void)
+{
+  const char *mynick;
+
+  mynick = get_user_nick();
+  return rb_str_new(mynick, strlen(mynick));
+}
+
 static VALUE cie_nick(void)
 {
   VALUE copy;
@@ -529,8 +550,10 @@
   rb_define_method(cIrofferEvent, "inputline", cie_inputline, 0); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "hostmask", cie_hostmask, 0); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "nick", cie_nick, 0); /* NOTRANSLATE */
+  rb_define_method(cIrofferEvent, "mynick", cie_mynick, 0); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "channel", cie_channel, 0); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "message", cie_message, 0); /* NOTRANSLATE */
+  rb_define_method(cIrofferEvent, "irconfig", cie_config, 1); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "config", cie_config, 1); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "added_file", cie_added_file, 0); /* NOTRANSLATE */
   rb_define_method(cIrofferEvent, "added_pack", cie_added_pack, 0); /* NOTRANSLATE */
@@ -650,6 +673,54 @@
   return do_on_event(oIrofferEvent, "on_added"); /* NOTRANSLATE */
 }
 
+#define MAX_RUBYCMD_PARTS 10
+
+/* call the ruby class from admin chat */
+int do_myruby_ruby(const userinput * const u)
+{
+  protect_call_arg_t arg;
+  char *part[MAX_RUBYCMD_PARTS];
+  VALUE *argv;
+  ID method;
+  VALUE userobject;
+  unsigned int argc;
+  unsigned int i;
+  int state = 0;
+
+  if (myruby_loaded == 0)
+    return 0;
+
+  userobject = oIrofferEvent;
+  if (NIL_P(userobject))
+    return 0;
+
+  method = rb_intern(u->arg1);
+  if (! rb_respond_to(userobject, method))
+    return 0;
+
+  if (u->arg2e != NULL) {
+    argc = get_argv(part, u->arg2e, MAX_RUBYCMD_PARTS);
+    argv = ALLOCA_N(VALUE, argc);
+    for (i = 0; i < argc; ++i) {
+      argv[i] = rb_str_new(part[i], strlen(part[i]));;
+      mydelete(part[i]);
+    }
+  } else {
+    argc = 0;
+    argv = 0;
+  }
+  arg.recvobj = userobject;
+  arg.mid = method;
+  arg.argc = argc;
+  arg.argv = argv;
+  rb_protect(protect_funcall0, (VALUE) &arg, &state);
+  if (state != 0) {
+    iroffer_ruby_errro(state);
+    return 1;
+  }
+  return 0;
+}
+
 /* reload the scrip on rehash */
 void rehash_myruby(int check)
 {
Index: src/dinoex_ruby.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_ruby.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -r1.7 -r1.8
--- src/dinoex_ruby.h	24 Jun 2010 13:00:26 -0000	1.7
+++ src/dinoex_ruby.h	7 Apr 2011 04:27:41 -0000	1.8
@@ -1,6 +1,6 @@
 /*
  * by Dirk Meyer (dinoex)
- * Copyright (C) 2007-2010 Dirk Meyer
+ * Copyright (C) 2007-2011 Dirk Meyer
  *
  * By using this file, you agree to the terms and conditions set
  * forth in the GNU General Public License.  More information is
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_ruby.h,v 1.7 2010/06/24 13:00:26 cvs Exp $
+ * $Id: dinoex_ruby.h,v 1.8 2011/04/07 04:27:41 cvs Exp $
  *
  */
 
@@ -18,6 +18,7 @@
 int do_myruby_notice(char *line);
 int do_myruby_privmsg(char *line);
 int do_myruby_added(char *filename, unsigned int pack);
+int do_myruby_ruby(const userinput * const u);
 void rehash_myruby(int check);
 void startup_myruby(void);
 void shutdown_myruby(void);
Index: src/dinoex_statefile.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_statefile.c,v
retrieving revision 1.32
retrieving revision 1.33
diff -u -r1.32 -r1.33
--- src/dinoex_statefile.c	5 Feb 2011 11:05:55 -0000	1.32
+++ src/dinoex_statefile.c	13 May 2011 16:16:31 -0000	1.33
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_statefile.c,v 1.32 2011/02/05 11:05:55 cvs Exp $
+ * $Id: dinoex_statefile.c,v 1.33 2011/05/13 16:16:31 cvs Exp $
  *
  */
 
@@ -163,7 +163,7 @@
     statefile_item_md5sum_info32_t *md5sum_info = (statefile_item_md5sum_info32_t*)hdr;
     ir_uint32 netval = 0;
 
-    xd->has_md5sum = 1;
+    ++(xd->has_md5sum);
     xd->st_size = (off_t)((((ir_uint64)ntohl(md5sum_info->st_size.upper)) << 32) | ((ir_uint64)ntohl(md5sum_info->st_size.lower)));
     xd->st_dev  = (dev_t)((((ir_uint64)ntohl(md5sum_info->st_dev.upper)) << 32) | ((ir_uint64)ntohl(md5sum_info->st_dev.lower)));
     xd->st_ino  = (ino_t)((((ir_uint64)ntohl(md5sum_info->st_ino.upper)) << 32) | ((ir_uint64)ntohl(md5sum_info->st_ino.lower)));
@@ -175,7 +175,7 @@
   if (hdr->length == sizeof(statefile_item_md5sum_info64_t)) {
     statefile_item_md5sum_info64_t *md5sum_info = (statefile_item_md5sum_info64_t*)hdr;
 
-    xd->has_md5sum = 1;
+    ++(xd->has_md5sum);
     xd->st_size = (off_t)((((ir_uint64)ntohl(md5sum_info->st_size.upper)) << 32) | ((ir_uint64)ntohl(md5sum_info->st_size.lower)));
     xd->st_dev  = (dev_t)((((ir_uint64)ntohl(md5sum_info->st_dev.upper)) << 32) | ((ir_uint64)ntohl(md5sum_info->st_dev.lower)));
     xd->st_ino  = (ino_t)((((ir_uint64)ntohl(md5sum_info->st_ino.upper)) << 32) | ((ir_uint64)ntohl(md5sum_info->st_ino.lower)));
Index: src/dinoex_transfer.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_transfer.c,v
retrieving revision 1.50
retrieving revision 1.60
diff -u -r1.50 -r1.60
--- src/dinoex_transfer.c	6 Feb 2011 01:28:12 -0000	1.50
+++ src/dinoex_transfer.c	10 Jun 2011 05:43:05 -0000	1.60
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_transfer.c,v 1.50 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_transfer.c,v 1.60 2011/06/10 05:43:05 cvs Exp $
  *
  */
 
@@ -22,6 +22,7 @@
 #include "dinoex_transfer.h"
 #include "dinoex_irc.h"
 #include "dinoex_geoip.h"
+#include "dinoex_queue.h"
 #include "dinoex_misc.h"
 
 /* send DCC command to start download */
@@ -36,12 +37,12 @@
   dccdata = setup_dcc_local(&tr->con.local);
   if (gdata.passive_dcc) {
     bzero((char *) &(tr->con.local), sizeof(tr->con.local));
-    privmsg_fast(tr->nick, "\1DCC SEND %s %s %" LLPRINTFMT "d %u\1", /* NOTRANSLATE */
+    privmsg_fast(tr->nick, IRC_CTCP "DCC SEND %s %s %" LLPRINTFMT "d %u" IRC_CTCP, /* NOTRANSLATE */
                  sendnamestr, dccdata,
                  tr->xpack->st_size,
                  tr->id);
   } else {
-    privmsg_fast(tr->nick, "\1DCC SEND %s %s %" LLPRINTFMT "d\1", /* NOTRANSLATE */
+    privmsg_fast(tr->nick, IRC_CTCP "DCC SEND %s %s %" LLPRINTFMT "d" IRC_CTCP, /* NOTRANSLATE */
                  sendnamestr, dccdata,
                  tr->xpack->st_size);
 
@@ -157,9 +158,12 @@
   if (gdata.quietmode)
      return;
 
+  if (pack == XDCC_SEND_LIST)
+     return;
+
   if (msg != NULL) {
     notice_transfer(tr->nick, tr->xpack, msg);
-     return;
+    return;
   }
 
   tempstr = mymalloc(maxtextlength);
@@ -363,9 +367,9 @@
   t_setresume(tr, bytes);
   sendnamestr = getsendname(filename);
   if ((tr->tr_status == TRANSFER_STATUS_RESUME) && (token != NULL)) {
-    privmsg_fast(nick, "\1DCC ACCEPT %s %s %s %s\1", sendnamestr, localport, bytes, token); /* NOTRANSLATE */
+    privmsg_fast(nick, IRC_CTCP "DCC ACCEPT %s %s %s %s" IRC_CTCP, sendnamestr, localport, bytes, token); /* NOTRANSLATE */
   } else {
-    privmsg_fast(nick, "\1DCC ACCEPT %s %s %s\1", sendnamestr, localport, bytes); /* NOTRANSLATE */
+    privmsg_fast(nick, IRC_CTCP "DCC ACCEPT %s %s %s" IRC_CTCP, sendnamestr, localport, bytes); /* NOTRANSLATE */
   }
   mydelete(sendnamestr);
   ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
@@ -375,7 +379,7 @@
 }
 
 /* process successful connection */
-void t_connected(transfer *tr)
+static void t_connected(transfer *tr)
 {
   int callval_i;
   int connect_error;
@@ -455,6 +459,8 @@
       continue;
 
     t_closeconn(tr, "You are being punished for parallel downloads", 0);
+    queue_punish_abuse( "You are being punished for parallel downloads", tr->net, tr->nick);
+
     bhostmask = to_hostmask( "*", tr->hostname); /* NOTRANSLATE */
     ignore = get_ignore(bhostmask);
     ignore->flags |= IGN_IGNORING;
@@ -471,8 +477,9 @@
 }
 
 /* check a new transfer */
-void t_check_new_connection(transfer *const tr)
+static void t_check_new_connection(transfer *const tr)
 {
+  t_establishcon(tr);
 #ifdef USE_GEOIP
   updatecontext();
   geoip_new_connection(tr);
@@ -592,4 +599,135 @@
   return highests;
 }
 
+/* handle transfer ip events */
+void t_perform(int changesec, int changequartersec)
+{
+  transfer *tr;
+  unsigned int i, j;
+
+  updatecontext();
+
+  if (changequartersec) {
+    for (tr = irlist_get_head(&gdata.trans);
+         tr;
+         tr = irlist_get_next(tr)) {
+      if (tr->nomax)
+        continue;
+
+      if (tr->maxspeed <= 0)
+        continue;
+
+      tr->tx_bucket += tr->maxspeed * (1024 / 4);
+      tr->tx_bucket = min2(tr->tx_bucket, MAX_TRANSFER_TX_BURST_SIZE * tr->maxspeed * 1024);
+    }
+  }
+
+  i = j = select_starting_transfer(irlist_size(&gdata.trans));
+
+  /* first: do from cur to end */
+  for (tr = irlist_get_nth(&gdata.trans, i);
+       tr;
+       tr = irlist_get_next(tr)) {
+    if (tr->tr_status != TRANSFER_STATUS_SENDING)
+      continue;
+
+    /*----- look for transfer some -----  send at least once a second, or more if necessary */
+    if (changequartersec || FD_ISSET(tr->con.clientsocket, &gdata.writeset)) {
+      gnetwork = &(gdata.networks[tr->net]);
+      t_transfersome(tr);
+    }
+  }
+
+  /* second: do from begin to cur-1 */
+  for (tr = irlist_get_head(&gdata.trans);
+       tr && j;
+       tr = irlist_get_next(tr), --j) {
+    if (tr->tr_status != TRANSFER_STATUS_SENDING)
+      continue;
+
+    /*----- look for transfer some -----  send at least once a second, or more if necessary */
+    if (changequartersec || FD_ISSET(tr->con.clientsocket, &gdata.writeset)) {
+      gnetwork = &(gdata.networks[tr->net]);
+      t_transfersome(tr);
+    }
+  }
+
+  tr = irlist_get_head(&gdata.trans);
+  while(tr) {
+    gnetwork = &(gdata.networks[tr->net]);
+
+    /*----- look for listen->connected ----- */
+    if (tr->tr_status == TRANSFER_STATUS_LISTENING) {
+      if (FD_ISSET(tr->con.listensocket, &gdata.readset)) {
+        t_check_new_connection(tr);
+        tr = irlist_get_next(tr);
+        continue;
+      }
+      /*----- look for listen reminders ----- */
+      if (changesec) {
+        if (tr->reminded == 0) {
+          if ((gdata.curtime - tr->con.lastcontact) >= 30)
+            t_remind(tr);
+        }
+        if (tr->reminded == 1) {
+          if ((gdata.curtime - tr->con.lastcontact) >= 90)
+            t_remind(tr);
+        }
+        if (tr->reminded == 2) {
+          if ((gdata.curtime - tr->con.lastcontact) >= 150)
+            t_remind(tr);
+        }
+      }
+    }
+
+    if (tr->tr_status == TRANSFER_STATUS_CONNECTING) {
+      if (FD_ISSET(tr->con.clientsocket, &gdata.writeset))
+        t_connected(tr);
+    }
+
+    /*----- look for junk to read ----- */
+    if ((tr->tr_status == TRANSFER_STATUS_SENDING) ||
+        (tr->tr_status == TRANSFER_STATUS_WAITING)) {
+      if (FD_ISSET(tr->con.clientsocket, &gdata.readset))
+        t_readjunk(tr);
+    }
+
+    /*----- look for done flushed status ----- */
+    if (tr->tr_status == TRANSFER_STATUS_WAITING) {
+      t_flushed(tr);
+    }
+
+    if (changesec) {
+      /*----- look for lost transfers ----- */
+      if (tr->tr_status != TRANSFER_STATUS_DONE) {
+        t_istimeout(tr);
+      }
+
+      /*----- look for finished transfers ----- */
+      if (tr->tr_status == TRANSFER_STATUS_DONE) {
+        char *trnick;
+
+        trnick = tr->nick;
+        mydelete(tr->caps_nick);
+        mydelete(tr->hostname);
+        mydelete(tr->con.localaddr);
+        mydelete(tr->con.remoteaddr);
+        mydelete(tr->country);
+        tr = irlist_delete(&gdata.trans, tr);
+
+        if (!gdata.exiting &&
+            irlist_size(&gdata.mainqueue) &&
+            (irlist_size(&gdata.trans) < gdata.slotsmax)) {
+          check_idle_queue(0);
+          send_from_queue(0, 0, trnick);
+        }
+        mydelete(trnick);
+        continue;
+      }
+    }
+    tr = irlist_get_next(tr);
+  }
+  gnetwork = NULL;
+}
+
 /* End of File */
Index: src/dinoex_transfer.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_transfer.h,v
retrieving revision 1.14
retrieving revision 1.16
diff -u -r1.14 -r1.16
--- src/dinoex_transfer.h	24 Jun 2010 13:00:26 -0000	1.14
+++ src/dinoex_transfer.h	25 Apr 2011 07:45:29 -0000	1.16
@@ -1,6 +1,6 @@
 /*
  * by Dirk Meyer (dinoex)
- * Copyright (C) 2004-2010 Dirk Meyer
+ * Copyright (C) 2004-2011 Dirk Meyer
  *
  * By using this file, you agree to the terms and conditions set
  * forth in the GNU General Public License.  More information is
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_transfer.h,v 1.14 2010/06/24 13:00:26 cvs Exp $
+ * $Id: dinoex_transfer.h,v 1.16 2011/04/25 07:45:29 cvs Exp $
  *
  */
 
@@ -21,10 +21,9 @@
 unsigned int t_check_ip_access(transfer *const tr);
 unsigned int t_find_transfer(const char *nick, const char *filename, const char *remoteip, const char *remoteport, const char *token);
 unsigned int t_find_resume(const char *nick, const char *filename, const char *localport, const char *bytes, char *token);
-void t_connected(transfer *tr);
-void t_check_new_connection(transfer *const tr);
 unsigned int verify_acknowlede(transfer *tr);
 const char *t_print_state(transfer *const tr);
 int t_select_fdset(int highests, int changequartersec);
+void t_perform(int changesec, int changequartersec);
 
 /* End of File */
Index: src/dinoex_upload.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_upload.c,v
retrieving revision 1.46
retrieving revision 1.52
diff -u -r1.46 -r1.52
--- src/dinoex_upload.c	6 Feb 2011 13:23:15 -0000	1.46
+++ src/dinoex_upload.c	25 Apr 2011 07:44:57 -0000	1.52
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_upload.c,v 1.46 2011/02/06 13:23:15 cvs Exp $
+ * $Id: dinoex_upload.c,v 1.52 2011/04/25 07:44:57 cvs Exp $
  *
  */
 
@@ -22,6 +22,7 @@
 #include "dinoex_upload.h"
 #include "dinoex_irc.h"
 #include "dinoex_curl.h"
+#include "dinoex_jobs.h"
 #include "dinoex_misc.h"
 
 /* search for a custom uploaddir of a group admin */
@@ -125,7 +126,7 @@
 
   msg = setup_dcc_local(&(l->con.local));
   tempstr = getsendname(l->file);
-  privmsg_fast(l->nick, "\1DCC SEND %s %s %" LLPRINTFMT "d %u\1", /* NOTRANSLATE */
+  privmsg_fast(l->nick, IRC_CTCP "DCC SEND %s %s %" LLPRINTFMT "d %u" IRC_CTCP, /* NOTRANSLATE */
                tempstr, msg, l->totalsize, l->token);
   mydelete(msg);
   msg = mymalloc(maxtextlength);
@@ -164,7 +165,7 @@
   if (retval == 2)
     {
       tempstr = getsendname(l->file);
-      privmsg_fast(l->nick, "\1DCC RESUME %s %d %" LLPRINTFMT "d %u\1", /* NOTRANSLATE */
+      privmsg_fast(l->nick, IRC_CTCP "DCC RESUME %s %d %" LLPRINTFMT "d %u" IRC_CTCP, /* NOTRANSLATE */
                    tempstr, l->con.remoteport, s.st_size, l->token);
       mydelete(tempstr);
       l->con.connecttime = gdata.curtime;
@@ -181,7 +182,7 @@
 }
 
 /* accept incoming connection */
-void l_setup_accept(upload * const l)
+static void l_setup_accept(upload * const l)
 {
   SIGNEDSOCK int addrlen;
   char *msg;
@@ -269,6 +270,84 @@
   return highests;
 }
 
+/* perfrom io for upload */
+void l_perform(int changesec)
+{
+  upload *ul;
+
+  updatecontext();
+
+  ul = irlist_get_head(&gdata.uploads);
+  while(ul) {
+    gnetwork = &(gdata.networks[ul->net]);
+
+    /*----- see if uploads are sending anything to us ----- */
+    if (ul->ul_status == UPLOAD_STATUS_GETTING) {
+      if (FD_ISSET(ul->con.clientsocket, &gdata.readset)) {
+        l_transfersome(ul);
+      }
+    }
+
+    if (ul->ul_status == UPLOAD_STATUS_LISTENING) {
+      if (FD_ISSET(ul->con.listensocket, &gdata.readset)) {
+        l_setup_accept(ul);
+      }
+    }
+
+    if (ul->ul_status == UPLOAD_STATUS_CONNECTING) {
+      if (FD_ISSET(ul->con.clientsocket, &gdata.writeset)) {
+        int callval_i;
+        int connect_error;
+        SIGNEDSOCK int connect_error_len = sizeof(connect_error);
+
+        callval_i = getsockopt(ul->con.clientsocket,
+                               SOL_SOCKET, SO_ERROR,
+                               &connect_error, &connect_error_len);
+
+        if (callval_i < 0) {
+          int errno2 = errno;
+          outerror(OUTERROR_TYPE_WARN,
+                   "Couldn't determine upload connection status on %s: %s",
+                   gnetwork->name, strerror(errno));
+          l_closeconn(ul, "Upload Connection Failed status:", errno2);
+          continue;
+        }
+        if (connect_error) {
+          l_closeconn(ul, "Upload Connection Failed", connect_error);
+          continue;
+        }
+        ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA,
+                          "Upload Connection Established on %s", gnetwork->name);
+        ul->ul_status = UPLOAD_STATUS_GETTING;
+        FD_CLR(ul->con.clientsocket, &gdata.writeset);
+        notice(ul->nick, "DCC Connection Established");
+        ul->con.connecttime = gdata.curtime;
+      }
+      if (changesec && ul->con.lastcontact + CTIMEOUT < gdata.curtime) {
+        l_closeconn(ul, "Upload Connection Timed Out", 0);
+        continue;
+      }
+    }
+
+    if (changesec) {
+      l_istimeout(ul);
+
+      if (ul->ul_status == UPLOAD_STATUS_DONE) {
+        close_qupload(ul->net, ul->nick);
+        mydelete(ul->nick);
+        mydelete(ul->hostname);
+        mydelete(ul->uploaddir);
+        mydelete(ul->file);
+        mydelete(ul->con.remoteaddr);
+        ul = irlist_delete(&gdata.uploads, ul);
+        continue;
+      }
+    }
+    ul = irlist_get_next(ul);
+  }
+  gnetwork = NULL;
+}
+
 /* check if a filename is already in a upload */
 int file_uploading(const char *file)
 {
@@ -338,6 +417,7 @@
   return 1;
 }
 
+/* check for valid upload user and size */
 int invalid_upload(const char *nick, const char *hostmask, off_t len)
 {
   updatecontext();
Index: src/dinoex_upload.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_upload.h,v
retrieving revision 1.13
retrieving revision 1.15
diff -u -r1.13 -r1.15
--- src/dinoex_upload.h	13 Nov 2010 20:13:58 -0000	1.13
+++ src/dinoex_upload.h	14 Apr 2011 04:32:04 -0000	1.15
@@ -1,6 +1,6 @@
 /*
  * by Dirk Meyer (dinoex)
- * Copyright (C) 2004-2010 Dirk Meyer
+ * Copyright (C) 2004-2011 Dirk Meyer
  *
  * By using this file, you agree to the terms and conditions set
  * forth in the GNU General Public License.  More information is
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_upload.h,v 1.13 2010/11/13 20:13:58 cvs Exp $
+ * $Id: dinoex_upload.h,v 1.15 2011/04/14 04:32:04 cvs Exp $
  *
  */
 
@@ -17,9 +17,9 @@
 
 int l_setup_file(upload * const l, struct stat *stp);
 int l_setup_passive(upload * const l, char *token);
-void l_setup_accept(upload * const l);
 const char *l_print_state(upload * const l);
 int l_select_fdset(int highests);
+void l_perform(int changesec);
 
 int file_uploading(const char *file);
 int invalid_upload(const char *nick, const char *hostmask, off_t len);
Index: src/dinoex_user.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_user.c,v
retrieving revision 1.60
retrieving revision 1.63
diff -u -r1.60 -r1.63
--- src/dinoex_user.c	7 Feb 2011 22:31:39 -0000	1.60
+++ src/dinoex_user.c	1 Jul 2011 04:31:31 -0000	1.63
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_user.c,v 1.60 2011/02/07 22:31:39 cvs Exp $
+ * $Id: dinoex_user.c,v 1.63 2011/07/01 04:31:31 cvs Exp $
  *
  */
 
@@ -61,7 +61,7 @@
     return;
 
   len = strlen(str);
-  if (str[--len] != '\1')
+  if (str[--len] != IRCCTCP)
     return;
 
   str[len] = '\0';
@@ -75,7 +75,7 @@
   if (strncmp(msg1, key, len) != 0)
     return 0;
 
-  if ((key[len] == 0) || (key[len] == '\1'))
+  if ((key[len] == 0) || (key[len] == IRCCTCP))
     return 1;
 
   return 0;
@@ -88,29 +88,29 @@
           nick, gnetwork->name);
 
   if (!msg2) {
-    notice(nick, "\1CLIENTINFO DCC PING VERSION XDCC UPTIME " /* NOTRANSLATE */
-    ":Use CTCP CLIENTINFO <COMMAND> to get more specific information\1");
+    notice(nick, IRC_CTCP "CLIENTINFO DCC PING VERSION XDCC UPTIME " /* NOTRANSLATE */
+    ":Use CTCP CLIENTINFO <COMMAND> to get more specific information" IRC_CTCP);
     return;
   }
   caps(msg2);
   if (strncmp(msg2, "PING", 4) == 0) {
-    notice(nick, "\1CLIENTINFO PING returns the arguments it receives\1");
+    notice(nick, IRC_CTCP "CLIENTINFO PING returns the arguments it receives" IRC_CTCP);
     return;
   }
   if (strncmp(msg2, "DCC", 3) == 0) {
-    notice(nick, "\1CLIENTINFO DCC requests a DCC for chatting or file transfer\1");
+    notice(nick, IRC_CTCP "CLIENTINFO DCC requests a DCC for chatting or file transfer" IRC_CTCP);
     return;
   }
   if (strncmp(msg2, "VERSION", 7) == 0) {
-    notice(nick, "\1CLIENTINFO VERSION shows information about this client's version\1");
+    notice(nick, IRC_CTCP "CLIENTINFO VERSION shows information about this client's version" IRC_CTCP);
     return;
   }
   if (strncmp(msg2, "XDCC", 4) == 0) {
-    notice(nick, "\1CLIENTINFO XDCC LIST|SEND list and DCC file(s) to you\1");
+    notice(nick, IRC_CTCP "CLIENTINFO XDCC LIST|SEND list and DCC file(s) to you" IRC_CTCP);
     return;
   }
   if (strncmp(msg2, "UPTIME", 6) == 0) {
-    notice(nick, "\1CLIENTINFO UPTIME shows how long this client has been running\1");
+    notice(nick, IRC_CTCP "CLIENTINFO UPTIME shows how long this client has been running" IRC_CTCP);
     return;
   }
 }
@@ -521,6 +521,7 @@
 static void log_xdcc_request3(privmsginput *pi, const char *msg)
 {
   const char *sep;
+  const char *part3;
 
   if (msg == NULL) {
     msg = "";
@@ -528,6 +529,9 @@
   } else {
     sep = ": ";
   }
+  part3 = pi->msg3;
+  if (part3 == NULL)
+    part3 = "";
   ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
           "XDCC %s %s%s%s (%s %s on %s)",
           pi->msg2, pi->msg3, sep, msg, pi->nick, pi->hostmask, gnetwork->name);
@@ -1071,7 +1075,7 @@
   char *tempstr2;
 
   /*----- CLIENTINFO ----- */
-  if (test_ctcp(pi->msg1, "\1CLIENTINFO")) { /* NOTRANSLATE */
+  if (test_ctcp(pi->msg1, IRC_CTCP "CLIENTINFO")) { /* NOTRANSLATE */
     if (check_ignore(pi->nick, pi->hostmask))
       return 0;
     send_clientinfo(pi->nick, pi->msg2);
@@ -1079,12 +1083,12 @@
   }
   if (type != 0) {
     /*----- PING ----- */
-    if (test_ctcp(pi->msg1, "\1PING")) { /* NOTRANSLATE */
+    if (test_ctcp(pi->msg1, IRC_CTCP "PING")) { /* NOTRANSLATE */
       if (check_ignore(pi->nick, pi->hostmask))
         return 0;
       strip_trailing_action(pi->msg2);
       strip_trailing_action(pi->msg3);
-      notice(pi->nick, "\1PING%s%s%s%s\1", /* NOTRANSLATE */
+      notice(pi->nick, IRC_CTCP "PING%s%s%s%s" IRC_CTCP, /* NOTRANSLATE */
              pi->msg2 ? " " : "", /* NOTRANSLATE */
              pi->msg2 ? pi->msg2 : "",
              pi->msg3 ? " " : "", /* NOTRANSLATE */
@@ -1096,10 +1100,10 @@
     }
   }
  /*----- VERSION ----- */
-  if (test_ctcp(pi->msg1, "\1VERSION")) { /* NOTRANSLATE */
+  if (test_ctcp(pi->msg1, IRC_CTCP "VERSION")) { /* NOTRANSLATE */
     if (check_ignore(pi->nick, pi->hostmask))
       return 0;
-    notice(pi->nick, "\1VERSION iroffer-dinoex " VERSIONLONG ", " "http://iroffer.dinoex.net/" "%s%s" FEATURES "\1",
+    notice(pi->nick, IRC_CTCP "VERSION iroffer-dinoex " VERSIONLONG ", " "http://iroffer.dinoex.net/" "%s%s" FEATURES IRC_CTCP,
            gdata.hideos ? "" : " - ", /* NOTRANSLATE */
            gdata.hideos ? "" : gdata.osstring);
     ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
@@ -1108,12 +1112,12 @@
     return 0;
   }
  /*----- UPTIME ----- */
-  if (test_ctcp(pi->msg1, "\1UPTIME")) { /* NOTRANSLATE */
+  if (test_ctcp(pi->msg1, IRC_CTCP "UPTIME")) { /* NOTRANSLATE */
     if (check_ignore(pi->nick, pi->hostmask))
       return 0;
     tempstr2 = mymalloc(maxtextlength);
     tempstr2 = getuptime(tempstr2, 0, gdata.startuptime, maxtextlength);
-    notice(pi->nick, "\1UPTIME %s\1", tempstr2); /* NOTRANSLATE */
+    notice(pi->nick, IRC_CTCP "UPTIME %s" IRC_CTCP, tempstr2); /* NOTRANSLATE */
     ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
             "[CTCP] %s on %s: UPTIME",
              pi->nick, gnetwork->name);
@@ -1121,12 +1125,12 @@
     return 0;
   }
   /*----- STATUS ----- */
-  if (test_ctcp(pi->msg1, "\1STATUS")) { /* NOTRANSLATE */
+  if (test_ctcp(pi->msg1, IRC_CTCP "STATUS")) { /* NOTRANSLATE */
     if (check_ignore(pi->nick, pi->hostmask))
       return 0;
     tempstr2 = mymalloc(maxtextlength);
     tempstr2 = getstatuslinenums(tempstr2, maxtextlength);
-    notice(pi->nick, "\1%s\1", tempstr2); /* NOTRANSLATE */
+    notice(pi->nick, IRC_CTCP "%s" IRC_CTCP, tempstr2); /* NOTRANSLATE */
     ioutput(OUT_S|OUT_L|OUT_D, COLOR_YELLOW,
                "[CTCP] %s on %s: STATUS",
                pi->nick, gnetwork->name);
@@ -1138,7 +1142,7 @@
     return 1;
 
   /*----- DCC SEND/CHAT/RESUME ----- */
-  if (test_ctcp(pi->msg1, "\1DCC")) { /* NOTRANSLATE */
+  if (test_ctcp(pi->msg1, IRC_CTCP "DCC")) { /* NOTRANSLATE */
     if (pi->msg2 == NULL)
       return 0; /* ignore */
     if (check_ignore(pi->nick, pi->hostmask))
@@ -1456,6 +1460,18 @@
   write_statefile();
 }
 
+/* get respondtochannelxdccn for current network */
+static unsigned int get_respondtochannelxdcc(void)
+{
+  return (gnetwork->respondtochannelxdcc != 2) ? gnetwork->respondtochannelxdcc : gdata.respondtochannelxdcc;
+}
+
+/* get respondtochannellist for current network */
+static unsigned int get_respondtochannellist(void)
+{
+  return (gnetwork->respondtochannellist != 2) ? gnetwork->respondtochannellist : gdata.respondtochannellist;
+}
+
 static void privmsgparse2(int type, int decoded, privmsginput *pi)
 {
   char *begin;
@@ -1478,10 +1494,10 @@
   caps(pi->hostmask);
   /*----- XDCC ----- */
   if ((strcmp(pi->msg1, "XDCC") == 0) || /* NOTRANSLATE */
-      (strcmp(pi->msg1, "\1XDCC") == 0) || /* NOTRANSLATE */
+      (strcmp(pi->msg1, IRC_CTCP "XDCC") == 0) || /* NOTRANSLATE */
       (strcmp(pi->msg1, "CDCC") == 0) || /* NOTRANSLATE */
-      (strcmp(pi->msg1, "\1CDCC") == 0)) { /* NOTRANSLATE */
-    if (!gdata.respondtochannelxdcc) {
+      (strcmp(pi->msg1, IRC_CTCP "CDCC") == 0)) { /* NOTRANSLATE */
+    if (get_respondtochannelxdcc() == 0) {
       if (not_for_me(pi->dest))
         return; /* ignore */
     }
@@ -1495,12 +1511,12 @@
   }
 
   /*----- !LIST ----- */
-  if ((test_ctcp(pi->msg1, "\1!LIST")) || /* NOTRANSLATE */
+  if ((test_ctcp(pi->msg1, IRC_CTCP "!LIST")) || /* NOTRANSLATE */
       (strcmp(pi->msg1, "!LIST") == 0)) { /* NOTRANSLATE */
     const char *rtclmsg;
     char *tempstr2;
 
-    if (!gdata.respondtochannellist) {
+    if (get_respondtochannellist() == 0) {
       if (not_for_me(pi->dest))
         return; /* ignore */
     }
Index: src/dinoex_utilities.c
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_utilities.c,v
retrieving revision 1.103
retrieving revision 1.109
diff -u -r1.103 -r1.109
--- src/dinoex_utilities.c	6 Feb 2011 01:28:12 -0000	1.103
+++ src/dinoex_utilities.c	21 Jul 2011 10:35:19 -0000	1.109
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_utilities.c,v 1.103 2011/02/06 01:28:12 cvs Exp $
+ * $Id: dinoex_utilities.c,v 1.109 2011/07/21 10:35:19 cvs Exp $
  *
  */
 
@@ -71,14 +71,14 @@
 
   len1 = strlen(str1);
   max = len1 + strlen(str2) + 1;
-  if ((delimiter != 0 ) && (str1[len1] != (unsigned char)delimiter))
+  if ((delimiter != 0 ) && ((unsigned char)str1[len1] != (unsigned char)delimiter))
     ++max;
 #ifndef WITHOUT_MEMSAVE
   copy = (char *)mymalloc2(max, 0, src_function, src_file, src_line);
 #else /* WITHOUT_MEMSAVE */
   copy = mymalloc(max);
 #endif /* WITHOUT_MEMSAVE */
-  if ((delimiter != 0 ) && (str1[len1 - 1] != (unsigned char)delimiter)) {
+  if ((delimiter != 0 ) && ((unsigned char)str1[len1 - 1] != (unsigned char)delimiter)) {
     snprintf(copy, max, "%s%c%s", str1, delimiter, str2); /* NOTRANSLATE */
   } else {
     snprintf(copy, max, "%s%s", str1, str2); /* NOTRANSLATE */
@@ -150,31 +150,6 @@
   return 1;
 }
 
-/* validate config and warn if password is not encrypted */
-void checkadminpass2(const char *masterpass)
-{
-#ifndef NO_CRYPT
-  unsigned int err=0;
-  unsigned int i;
-
-  updatecontext();
-
-  if (!masterpass || strlen(masterpass) < 13U) ++err;
-
-  for (i=0; !err && i<strlen(masterpass); ++i) {
-    if (!((masterpass[i] >= 'a' && masterpass[i] <= 'z') ||
-          (masterpass[i] >= 'A' && masterpass[i] <= 'Z') ||
-          (masterpass[i] >= '0' && masterpass[i] <= '9') ||
-          (masterpass[i] == '.') ||
-          (masterpass[i] == '$') ||
-          (masterpass[i] == '/')))
-      ++err;
-  }
-
-  if (err) outerror(OUTERROR_TYPE_CRASH, "adminpass is not encrypted!");
-#endif /* NO_CRYPT */
-}
-
 /* strip quotes from a string */
 char *clean_quotes(char *str)
 {
@@ -489,7 +464,7 @@
 
   dest = (unsigned char *)str;
   for (copy=dest; *copy != 0; ++copy) {
-    if (*copy == 0x03U) { /* color */
+    if (*copy == IRCCOLOR) { /* color */
       if (!isdigit(copy[1])) continue;
       ++copy;
       if (!isdigit(copy[1])) continue;
@@ -503,11 +478,11 @@
       continue;
     }
     switch (*copy) {
-    case 0x02U: /* bold */
-    case 0x0FU: /* end formatting */
-    case 0x16U: /* inverse */
-    case 0x1DU: /* italic */
-    case 0x1FU: /* underline */
+    case IRCBOLD: /* bold */
+    case IRCNORMAL: /* end formatting */
+    case IRCINVERSE: /* inverse */
+    case IRCITALIC: /* italic */
+    case IRCUNDERLINE: /* underline */
     case 0x7FU:
       break;
     default:
@@ -856,6 +831,15 @@
   return (((ir_uint64)(tv->tv_sec)) * 1000) + (((ir_uint64)(tv->tv_usec)) / 1000);
 }
 
+/* get current time in ms */
+ir_uint64 get_time_in_ms(void)
+{
+  struct timeval timestruct;
+
+  gettimeofday(&timestruct, NULL);
+  return timeval_to_ms(&timestruct);
+}
+
 /* get local date and time in ISO */
 char *user_getdatestr(char* str, time_t Tp, size_t len)
 {
@@ -890,7 +874,7 @@
 /* sort a linked list with selection sort */
 void irlist_sort2(irlist_t *list, int (*cmpfunc)(const void *a, const void *b))
 {
-  irlist_t newlist = {0, 0};
+  irlist_t newlist = {0, 0, 0};
   void *cur;
   void *ltry;
   void *last;
@@ -927,7 +911,7 @@
 /* sort a linked list with merge sort */
 void irlist_sort2(irlist_t *list, int (*cmpfunc)(const void *a, const void *b))
 {
-  irlist_t newlist = {0, 0};
+  irlist_t newlist = {0, 0, 0};
   irlist_t *p;
   irlist_t *q;
   irlist_t *e;
@@ -946,12 +930,12 @@
     nmerges = 0; /* count number of merges we do in this pass */
 
     while (p) {
-      nmerges++;  /* there exists a merge to be done */
+      ++nmerges;  /* there exists a merge to be done */
       /* step `insize' places along from p */
       q = p;
       psize = 0;
-      for (i = 0; i < insize; i++) {
-        psize++;
+      for (i = 0; i < insize; ++i) {
+        ++psize;
         q = irlist_get_next(q);
         if (!q) break;
       }
Index: src/dinoex_utilities.h
===================================================================
RCS file: /usr/home/public/iroffer/src/dinoex_utilities.h,v
retrieving revision 1.53
retrieving revision 1.55
diff -u -r1.53 -r1.55
--- src/dinoex_utilities.h	5 Feb 2011 11:05:55 -0000	1.53
+++ src/dinoex_utilities.h	21 Jul 2011 10:35:20 -0000	1.55
@@ -9,7 +9,7 @@
  * If you received this file without documentation, it can be
  * downloaded from http://iroffer.dinoex.net/
  *
- * $Id: dinoex_utilities.h,v 1.53 2011/02/05 11:05:55 cvs Exp $
+ * $Id: dinoex_utilities.h,v 1.55 2011/07/21 10:35:20 cvs Exp $
  *
  */
 
@@ -29,7 +29,6 @@
 unsigned int verifyshell(irlist_t *list, const char *file);
 const char *save_nick(const char * nick);
 unsigned int verifypass2(const char *masterpass, const char *testpass);
-void checkadminpass2(const char *masterpass);
 char *clean_quotes(char *str);
 char *to_hostmask(const char *nick, const char *hostname);
 const char *getfilename(const char *pathname);
@@ -67,6 +66,7 @@
 char *getpart_eol(const char *line, unsigned int howmany);
 unsigned int convert_spaces_to_match(char *str);
 ir_uint64 timeval_to_ms(struct timeval *tv);
+ir_uint64 get_time_in_ms(void);
 char *user_getdatestr(char* str, time_t Tp, size_t len);
 
 void irlist_sort2(irlist_t *list, int (*cmpfunc)(const void *a, const void *b));
Index: src/iroffer_admin.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_admin.c,v
retrieving revision 1.373
retrieving revision 1.384
diff -u -r1.373 -r1.384
--- src/iroffer_admin.c	9 Feb 2011 05:53:27 -0000	1.373
+++ src/iroffer_admin.c	12 Jul 2011 19:17:54 -0000	1.384
@@ -50,7 +50,6 @@
 static void u_msgread(const userinput * const u);
 static void u_msgdel(const userinput * const u);
 static void u_memstat(const userinput * const u);
-static void u_qsend(const userinput * const u);
 static void u_shutdown(const userinput * const u);
 static void u_debug(const userinput * const u);
 static void u_jump(const userinput * const u);
@@ -109,7 +108,8 @@
 {2,2,method_allow_all,a_iqueue,        "IQUEUE","nick n [net]","Queues pack <n> for <nick> into idle queue"},
 {2,2,method_allow_all,a_iqueue,        "BATCH","nick n-m [net]","Queues pack <n> to <m> for <nick> into idle queue"},
 {2,2,method_allow_all,u_psend,         "PSEND","channel style [net]","Sends <style> (full|minimal|summary) XDCC LIST to <channel>"},
-{2,2,method_allow_all,u_qsend,         "QSEND","[id]","Start an extra transfer from queue"},
+{2,2,method_allow_all,a_qsend,         "QSEND","[id]","Start an extra transfer from main queue"},
+{2,2,method_allow_all,a_iqsend,        "IQSEND","[id]","Push entry from idle queue into main queue"},
 {2,5,method_allow_all,a_slotsmax,      "SLOTSMAX","[slots]","temporary change slotsmax to <slots>"},
 {2,5,method_allow_all,a_queuesize,     "QUEUESIZE","[slots]","temporary change queuesize to <slots>"},
 {2,5,method_allow_all,a_requeue,       "REQUEUE","x y","Moves main queue entry from position <x> to <y>"},
@@ -220,6 +220,11 @@
 {6,5,method_allow_all,a_print,         "PRINT","key","Print config variable <key>"},
 {6,1,method_allow_all,a_identify,      "IDENTIFY","[net]","Send stored password again to nickserv"},
 {6,2,method_allow_all,a_holdqueue,     "HOLDQUEUE","[x]","Change holdqueue flag, x=1 set, x=0 reset"},
+{6,5,method_allow_all,a_offline,       "OFFLINE","[net]","Close given network or all networks"},
+{6,5,method_allow_all,a_online,        "ONLINE","[net]","Connect to given network or to all networks"},
+#ifdef USE_RUBY
+{6,5,method_allow_all,a_ruby,          "RUBY","method [args]","Call a method in the ruby_script with parameters <args>"},
+#endif /* USE_RUBY */
 {6,5,method_allow_all,u_shutdown,      "SHUTDOWN","act","Shutdown iroffer, <act> is \"now\", \"delayed\", or \"cancel\""},
 {6,5,method_console,  a_backgroud,     "BACKGROUND",NULL,"Switch to background mode"},
 {6,5,method_allow_all,a_dump,          "DUMP",NULL,"Write a dump into the logfile"},
@@ -264,76 +269,79 @@
   
   updatecontext();
   
-  mydelete(u->snick);
   u->chat = NULL;
   u->net = 0;
   u->level = ADMIN_LEVEL_PUBLIC;
-  mydelete(u->hostmask);
-  mydelete(u->cmd);
-  mydelete(u->arg1e);
-  mydelete(u->arg2e);
-  mydelete(u->arg3e);
-  mydelete(u->arg1);
-  mydelete(u->arg2);
-  mydelete(u->arg3);
+  free_userinput(u);
+}
+
+static void u_runcmd(userinput * const u)
+{
+#ifdef DEBUG
+  ir_uint64 ms1;
+  ir_uint64 ms2;
+#endif /* DEBUG */
+  char *tempstr;
+  int i;
+
+#ifdef DEBUG
+  ms1 = get_time_in_ms();
+#endif /* DEBUG */
+  for (i=0; i < (int)((sizeof(userinput_parse)/sizeof(userinput_parse_t))); i++) {
+    if (u->level < userinput_parse[i].level)
+      continue;
+    if ((userinput_parse[i].methods_allowed & u->method) == 0)
+      continue;
+    if (strcmp(userinput_parse[i].command, u->cmd) != 0)
+      continue;
+  
+    tempstr = mymalloc(maxtextlength);
+    tempstr[0] = 0;
+    if (u->method == method_console) {
+      snprintf(tempstr, maxtextlength - 1, "(console)");
+    }
+    if (u->method == method_dcc) {
+      snprintf(tempstr, maxtextlength - 1, "(DCC Chat: %s)" " (network: %s)",
+               save_nick(u->chat->nick), gnetwork->name);
+    }
+    if (u->method == method_msg) {
+      snprintf(tempstr, maxtextlength - 1, "(MSG: %s)" " (network: %s)",
+               u->snick, gnetwork->name);
+    }
+    if (tempstr[0] != 0) {
+      ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA, "ADMIN %s requested %s", u->cmd, tempstr);
+    }
+    mydelete(tempstr);
+    userinput_parse[i].handler(u);
+
+#ifdef DEBUG
+    ms2 = get_time_in_ms();
+    if (gdata.debug > 0)
+      ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA, "ADMIN %s"
+              " running: %ld ms", u->cmd, (long)(ms2 - ms1));
+#endif /* DEBUG */
+    return;
+  }
+  a_respond(u, "** User Command Not Recognized, try \"HELP\"");
 }
 
 #define u_respond a_respond
 
 void u_parseit(userinput * const u) {
-   int i,found = 0;
    gnetwork_t *backup;
-#ifdef DEBUG
-   struct timeval timestruct1;
-   struct timeval timestruct2;
-   ir_uint64 ms1;
-   ir_uint64 ms2;
-#endif /* DEBUG */
    
    updatecontext();
    
-#ifdef DEBUG
-   gettimeofday(&timestruct1, NULL);
-#endif /* DEBUG */
    backup = gnetwork;
    if ( gnetwork == NULL )
      gnetwork = &(gdata.networks[0]);
    if (!u->cmd || !strlen(u->cmd)) {
       u_respond(u,"** Missing Command, try again");
-      u_fillwith_clean(u);
-      gnetwork = backup;
-      return;
       }
-   
-   for (i=0; !found && i<(int)((sizeof(userinput_parse)/sizeof(userinput_parse_t))); i++) {
-      if ( (!strcmp(userinput_parse[i].command,u->cmd)) &&
-           (userinput_parse[i].level <= u->level ) &&
-           (userinput_parse[i].methods_allowed & u->method) ) {
-         found=1;
-         userinput_parse[i].handler(u);
-         }
+   else {
+      u_runcmd(u);
       }
    
-   if (!found)
-      u_respond(u,"** User Command Not Recognized, try \"HELP\"");
-   
-   if (found && u->method==method_console)
-      ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA, "ADMIN %s requested (console)", u->cmd);
-   if (found && u->method==method_dcc)
-      ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA, "ADMIN %s requested (DCC Chat: %s) (network: %s)",
-               u->cmd, save_nick(u->chat->nick), gnetwork->name);
-   if (found && u->method==method_msg)
-      ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA, "ADMIN %s requested (MSG: %s) (network: %s)",
-              u->cmd, u->snick, gnetwork->name);
-   
-#ifdef DEBUG
-   gettimeofday(&timestruct2, NULL);
-   ms1 = timeval_to_ms(&timestruct1);
-   ms2 = timeval_to_ms(&timestruct2);
-   if (gdata.debug > 0)
-     ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA, "COMMAND %s running: %ld ms", u->cmd, (long)(ms2 - ms1));
-#endif /* DEBUG */
-   
    u_fillwith_clean(u);
    gnetwork = backup;
    
@@ -897,6 +905,7 @@
                     (tr->nomin || (tr->xpack->minspeed == 0.0)) ? "no" : tempstr2 ,
                     (tr->nomax || (tr->maxspeed == 0.0)) ? "no" : tempstr4 ,
                     tr->startresume ? tempstr3 : "no");
+          u_respond(u, "  ^- [%s country=%s]", tr->con.remoteaddr, tr->country ? tr->country : "??" );
         }
       else
         {
@@ -1443,7 +1452,7 @@
        a_respond(u, "network: %u: %s", ss + 1, gdata.networks[ss].name);
        msg = mymalloc(maxtextlength);
        my_dcc_ip_show(msg, maxtextlength - 1, &(gdata.networks[ss].myip), ss);
-       a_respond(u, "DCC IP: %s NAT=%u", msg, gdata.networks[ss].usenatip);
+       a_respond(u, "DCC IP: %s NAT=%u OFFLINE=%u", msg, gdata.networks[ss].usenatip, gdata.networks[ss].offline);
        mydelete(msg);
        
        backup = gnetwork;
@@ -1651,6 +1660,9 @@
       u_respond(u,"NOTICE: Delayed shutdown activated, iroffer will shutdown once there are no active transfers");
       u_respond(u,"NOTICE: To cancel the delayed shutdown, issue \"SHUTDOWN CANCEL\"");
       }
+   if (gdata.holdqueue) {
+      u_respond(u, "NOTICE: HOLDQUEUE is on, no new transfers are started.");
+      }
    
    mydelete(tempstr);
    }
@@ -1952,30 +1964,6 @@
     }
 }
 
-
-static void u_qsend(const userinput * const u)
-{
-  unsigned int num = 0;
-  
-  updatecontext();
-  
-  if (!irlist_size(&gdata.mainqueue))
-    {
-      u_respond(u,"No Users Queued");
-      return;
-    }
-  
-  if (irlist_size(&gdata.trans) >= gdata.maxtrans)
-    {
-      u_respond(u,"Too many transfers");
-      return;
-    }
-  
-  if (u->arg1) num = atoi(u->arg1);
-  send_from_queue(2, num, NULL);
-  return;
-}
-
 static void u_shutdown(const userinput * const u) {
    updatecontext();
    
@@ -1990,7 +1978,7 @@
       }
    
    if (!strcmp(u->arg1,"NOW")) {
-      shutdowniroffer();
+      gdata.needsshutdown = 1;
       }
    else if (!strcmp(u->arg1,"DELAYED")) {
       u_respond(u,"Delayed shutdown activated, iroffer will shutdown once there are no active transfers");
@@ -2181,7 +2169,7 @@
   DIR *d;
   struct dirent *f;
   char *thefile, *tempstr;
-  irlist_t dirlist = {0, 0};
+  irlist_t dirlist = {0, 0, 0};
   int thedirlen;
   
   updatecontext();
Index: src/iroffer_dccchat.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_dccchat.c,v
retrieving revision 1.51
retrieving revision 1.54
diff -u -r1.51 -r1.54
--- src/iroffer_dccchat.c	23 Nov 2010 06:42:04 -0000	1.51
+++ src/iroffer_dccchat.c	1 Jul 2011 09:52:28 -0000	1.54
@@ -56,9 +56,9 @@
   
   msg = setup_dcc_local(&(chat->con.local));
   if (token != NULL) {
-    privmsg_fast(nick, "\1DCC CHAT CHAT %s %s\1", msg, token);
+    privmsg_fast(nick, IRC_CTCP "DCC CHAT CHAT %s %s" IRC_CTCP, msg, token);
   } else {
-    privmsg_fast(nick, "\1DCC CHAT CHAT %s\1", msg);
+    privmsg_fast(nick, IRC_CTCP "DCC CHAT CHAT %s" IRC_CTCP, msg);
   }
   my_getnameinfo(msg, maxtextlength -1, &(chat->con.local.sa));
   chat->con.localaddr = mystrdup(msg);
@@ -391,7 +391,7 @@
   
   len = vsnprintf(tempstr, maxtextlength, format, ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN_LOUD | OUTERROR_TYPE_NOLOG,
                "DCCCHAT: Output too large, ignoring!");
@@ -450,13 +450,7 @@
       FD_CLR(chat->con.clientsocket, &gdata.readset);
       FD_CLR(chat->con.clientsocket, &gdata.writeset);
       usleep(100*1000);
-      /*
-       * cygwin close() is broke, if outstanding data is present
-       * it will block until the TCP connection is dead, sometimes
-       * upto 10-20 minutes, calling shutdown() first seems to help
-       */
-      shutdown(chat->con.clientsocket, SHUT_RDWR);
-      close(chat->con.clientsocket);
+      shutdown_close(chat->con.clientsocket);
       mydelete(chat->groups);
       mydelete(chat->hostmask);
       mydelete(chat->nick);
Index: src/iroffer_defines.h
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_defines.h,v
retrieving revision 1.26
retrieving revision 1.27
diff -u -r1.26 -r1.27
--- src/iroffer_defines.h	6 Feb 2011 13:58:31 -0000	1.26
+++ src/iroffer_defines.h	1 Jul 2011 09:52:28 -0000	1.27
@@ -113,8 +113,8 @@
 #define mycalloc(x) calloc(1, x)
 #endif
 
-#define  maxtextlengthshort 60
-#define  maxtextlength 512
+#define  maxtextlengthshort 60U
+#define  maxtextlength 512U
 #define INPUT_BUFFER_LENGTH 2048U
 
 #define LISTEN_PORT_REUSE_TIME (30*60) /* 30 minutes */
Index: src/iroffer_display.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_display.c,v
retrieving revision 1.20
retrieving revision 1.22
diff -u -r1.20 -r1.22
--- src/iroffer_display.c	23 Nov 2010 06:42:04 -0000	1.20
+++ src/iroffer_display.c	1 Jul 2011 09:52:28 -0000	1.22
@@ -132,10 +132,11 @@
    }
 
 void gototop (void) {
-   if (gdata.background == 2) return;
    gdata.attop = 1;
    if ( gdata.noscreen )
       return;
+   if (gdata.background == 2)
+      return;
    
    tostdout(IRVT_CURSOR_HOME1, gdata.termlines - 2);
    }
@@ -213,10 +214,11 @@
   unsigned int maxlen;
   unsigned int nicklen;
   
-  if (gdata.background == 2) return;
   gdata.attop = 0;
   if ( gdata.noscreen )
     return;
+  if (gdata.background == 2)
+    return;
   
   mynick = get_console_nick();
   nicklen = 16 + strlen(mynick);
@@ -275,7 +277,7 @@
     {
       len = vsnprintf(tempstr,maxtextlength,format,ap);
       
-      if ((len < 0) || (len >= maxtextlength))
+      if ((len < 0) || (len >= (int)maxtextlength))
         {
           len = 0;
         }
Index: src/iroffer_globals.h
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_globals.h,v
retrieving revision 1.198
retrieving revision 1.203
diff -u -r1.198 -r1.203
--- src/iroffer_globals.h	10 Feb 2011 18:31:34 -0000	1.198
+++ src/iroffer_globals.h	12 Jul 2011 19:17:54 -0000	1.203
@@ -70,6 +70,7 @@
 irlist_t log_exclude_text;
 irlist_t fish_exclude_nick;
 irlist_t group_admin;
+irlist_t periodicmsg;
 time_t configtime[MAXCONFIG];
 char *configfile[MAXCONFIG];
 char *osstring;
@@ -82,7 +83,6 @@
 char *hadminpass;
 char *statefile;
 char *xdcclistfile;
-char *periodicmsg_nick, *periodicmsg_msg;
 char *config_nick;
 char *user_realname, *user_modes, *loginname;
 char *restrictprivlistmsg;
@@ -235,7 +235,9 @@
 unsigned int show_group_of_pack;
 unsigned int dump_all;
 unsigned int tcp_nodelay;
-unsigned int bdummy;
+unsigned int announce_size;
+unsigned int subdirs_delayed;
+unsigned int idummy;
 
 context_t context_log[MAXCONTEXTS];
 ir_boutput_t stdout_buffer;
@@ -252,6 +254,7 @@
 time_t curtime;
 long totaluptime;
 ir_uint64 curtimems;
+ir_uint64 selecttimems;
 ir_int64 totalsent;
 unsigned long xdccsent[XDCC_SENT_SIZE];
 unsigned long xdccrecv[XDCC_SENT_SIZE];
@@ -305,7 +308,7 @@
 unsigned int maxb;
 unsigned int adjustcore;
 unsigned int overallmaxspeeddaytimestart, overallmaxspeeddaytimeend;
-unsigned int periodicmsg_time;
+unsigned int idummy2;
 int ignore;
 
 /* screen */
@@ -330,7 +333,7 @@
 unsigned int next_tr_id;
 unsigned int context_cur_ptr;
 unsigned int maxtrans;
-unsigned int udummy;
+unsigned int idummy3;
 
 int max_fds_from_rlimit;
 int logfd;
Index: src/iroffer_headers.h
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_headers.h,v
retrieving revision 1.147
retrieving revision 1.155
diff -u -r1.147 -r1.155
--- src/iroffer_headers.h	7 Feb 2011 20:00:50 -0000	1.147
+++ src/iroffer_headers.h	10 Jun 2011 05:43:05 -0000	1.155
@@ -122,6 +122,7 @@
 typedef struct
 {
   irlist_item_t *head;
+  irlist_item_t *tail;
   unsigned int size;
   unsigned int dummy;
 } irlist_t;
@@ -180,7 +181,7 @@
    ir_uint32 crc32;
    int file_fd;
    unsigned int file_fd_count;
-   unsigned int dummy;
+   unsigned int announce;
    off_t file_fd_location;
 #ifdef HAVE_MMAP
    irlist_t mmaps;
@@ -272,6 +273,7 @@
   float maxspeed;
   xdcc *xpack;
   ir_connection_t con;
+  char *country;
   char *nick;
   char *caps_nick;
   char *hostname;
@@ -596,7 +598,7 @@
 __attribute__ ((format(printf, 2, 0)))
 #endif
 vnotice(const char *nick, const char *format, va_list ap);
-int sstrlen (const char *p);
+size_t sstrlen (const char *p);
 void joinchannel(channel_t *c);
 void updatecontext_f(const char *file, const char *func, unsigned int line);
 void dumpcontext(void);
@@ -637,10 +639,10 @@
 /* permanently add/delete items (includes malloc/free) */
 #ifndef WITHOUT_MEMSAVE
 #define irlist_add(x,y) irlist_add2(x,y,__FUNCTION__,__FILE__,__LINE__)
-void* irlist_add2(irlist_t *list, unsigned int size,
+void* irlist_add2(irlist_t *list, size_t size,
                   const char *src_function, const char *src_file, unsigned int src_line);
 #else
-void* irlist_add(irlist_t *list, unsigned int size);
+void* irlist_add(irlist_t *list, size_t size);
 #endif
 void* irlist_delete(irlist_t *list, void *item);
 void irlist_delete_all(irlist_t *list);
@@ -715,7 +717,7 @@
 
 /* statefile.c */
 void write_statefile(void);
-void read_statefile(void);
+unsigned int read_statefile(void);
 
 /* dccchat.c */
 int setupdccchatout(const char *nick, const char *hostmask, const char *token);
Index: src/iroffer_main.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_main.c,v
retrieving revision 1.352
retrieving revision 1.374
diff -u -r1.352 -r1.374
--- src/iroffer_main.c	5 Feb 2011 11:05:55 -0000	1.352
+++ src/iroffer_main.c	1 Jul 2011 10:07:54 -0000	1.374
@@ -32,19 +32,19 @@
 #include "dinoex_jobs.h"
 #include "dinoex_ruby.h"
 #include "dinoex_main.h"
-#include "dinoex_user.h"
 #include "dinoex_chat.h"
 #include "dinoex_misc.h"
 
 /* local functions */
 static void mainloop(void);
-static void ir_parseline(char *line);
 
 /* main */
 int
 #ifdef __GNUC__
+#if !defined(__STDC_VERSION__) || __STDC_VERSION__ != 199901L
 __attribute__ ((noreturn))
 #endif
+#endif
 main(int argc, char *const *argv) {
    
    initvars();
@@ -97,15 +97,14 @@
    static int changequartersec, changesec, changemin, changehour;
    static time_t lasttime, lastmin, lasthour, last4sec, last5sec, last20sec;
    static time_t lastautoadd;
-   static time_t last3min, last2min, lastignoredec, lastperiodicmsg;
+   static time_t last3min, last2min, lastignoredec;
    static int first_loop = 1;
    static ir_uint64 last250ms;
 
    userinput *pubplist;
    userinput *urehash;
    ir_uint64 xdccsent;
-   unsigned int i, j;
-   int length;
+   unsigned int i;
    int highests;
    unsigned int ss;
    upload *ul;
@@ -123,8 +122,14 @@
        FD_ZERO(&gdata.readset);
        FD_ZERO(&gdata.writeset);
        changehour=changemin=changesec=changequartersec=0;
+       gettimeofday(&timestruct, NULL);
+       last250ms = gdata.curtimems;
+       gdata.curtimems = timeval_to_ms(&timestruct);
+       ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "Startup"
+              " running: %ld ms", (long)(gdata.curtimems - last250ms));
+       gdata.curtime = timestruct.tv_sec;
        lasttime=gdata.curtime;
-       last250ms = ((ir_uint64)lasttime) * 1000;
+       last250ms = gdata.curtimems;
        lastmin=(lasttime/60)-1;
        lasthour=(lasttime/60/60)-1;
        last4sec = last5sec = last20sec = last2min = last3min = lasttime;
@@ -179,9 +184,6 @@
       
       updatecontext();
    
-      timestruct.tv_sec = 0;
-      timestruct.tv_usec = 250*1000;
-      
       if (gdata.debug > 3)
         {
           select_dump("try", highests);
@@ -191,6 +193,10 @@
       
       tostdout_write();
       
+      gettimeofday(&timestruct, NULL);
+      gdata.selecttimems = timeval_to_ms(&timestruct);
+      timestruct.tv_sec = 0;
+      timestruct.tv_usec = 250*1000;
       if (select(highests+1, &gdata.readset, &gdata.writeset, NULL, &timestruct) < 0)
         {
           if (errno != EINTR)
@@ -205,103 +211,11 @@
           FD_ZERO(&gdata.execset);
         }
       
-#ifdef USE_CURL
-      fetch_perform();
-#endif /* USE_CURL */
-      
       if (gdata.debug > 3)
         {
           select_dump("got", highests);
         }
       
-      if (gdata.needsshutdown)
-        {
-          gdata.needsshutdown = 0;
-          shutdowniroffer();
-        }
-      
-      if (gdata.needsreap)
-        {
-          pid_t child;
-          int status;
-          
-          gdata.needsreap = 0;
-          
-          while ((child = waitpid(-1, &status, WNOHANG)) > 0)
-            {
-              for (ss=0; ss<gdata.networks_online; ss++)
-                {
-                  if (gdata.networks[ss].serverstatus == SERVERSTATUS_RESOLVING)
-                    {
-                      if (child == gdata.networks[ss].serv_resolv.child_pid)
-                        {
-                      /* lookup failed */
-#ifdef NO_WSTATUS_CODES
-                      ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
-                              "Unable to resolve server %s (status=0x%.8X)",
-                              gdata.networks[ss].curserver.hostname,
-                              status);
-#else
-#ifndef NO_HOSTCODES
-                      if (WIFEXITED(status) &&
-                          (WEXITSTATUS(status) >= 20) &&
-                          (WEXITSTATUS(status) <= 23))
-                        {
-                          const char *errstr;
-                          switch (WEXITSTATUS(status))
-                            {
-                            case 20:
-                              errstr = "host not found";
-                              break;
-                              
-                            case 21:
-                              errstr = "no ip address";
-                              break;
-                              
-                            case 22:
-                              errstr = "non-recoverable name server";
-                              break;
-                              
-                            case 23:
-                              errstr = "try again later";
-                              break;
-                              
-                            default:
-                              errstr = "unknown";
-                              break;
-                            }
-                          ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
-                                  "Unable to resolve server %s (%s)",
-                                  gdata.networks[ss].curserver.hostname, errstr);
-                        }
-                      else
-#endif
-                        {
-                          ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
-                                  "Unable to resolve server %s (status=0x%.8X, %s: %d)",
-                                  gdata.networks[ss].curserver.hostname,
-                                  status,
-                                  WIFEXITED(status) ? "exit" : WIFSIGNALED(status) ? "signaled" : "??",
-                                  WIFEXITED(status) ? WEXITSTATUS(status) : WIFSIGNALED(status) ? WTERMSIG(status) : 0);
-                        }
-#endif
-                          gdata.networks[ss].serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
-                        }
-                      /* else  this is an old child, ignore */
-                    }
-              
-                  if (child == gdata.networks[ss].serv_resolv.child_pid)
-                    {
-                  /* cleanup */
-                  close(gdata.networks[ss].serv_resolv.sp_fd[0]);
-                  FD_CLR(gdata.networks[ss].serv_resolv.sp_fd[0], &gdata.readset);
-                  gdata.networks[ss].serv_resolv.sp_fd[0] = 0;
-                  gdata.networks[ss].serv_resolv.child_pid = 0;
-                    }
-                } /* networks */
-            }
-        }
-      
       /*----- one second check ----- */
       
       updatecontext();
@@ -313,6 +227,9 @@
       
       gdata.curtimems = timeval_to_ms(&timestruct);
       gdata.curtime = timestruct.tv_sec;
+      if (gdata.curtimems > gdata.selecttimems + 1000)
+        outerror(OUTERROR_TYPE_WARN, "Iroffer was blocked for %lims",
+                 (long)(gdata.curtimems - gdata.selecttimems));
       
       /* adjust for drift and cpu usage */
       if ((gdata.curtimems > (last250ms+1000)) ||
@@ -336,14 +253,22 @@
       changesec = 0;
       if (gdata.curtime != lasttime) {
          
-         if (gdata.curtime < lasttime-3) {
-            outerror(OUTERROR_TYPE_WARN,"System Time Changed Backwards %lim %lis!!\n",
-               (long)(lasttime-gdata.curtime)/60,(long)(lasttime-gdata.curtime)%60);
+         if (gdata.curtime < lasttime - MAX_WAKEUP_WARN) {
+            outerror(OUTERROR_TYPE_WARN, "System Time Changed Backwards %lim %lis!!\n",
+                     (long)(lasttime-gdata.curtime)/60, (long)(lasttime-gdata.curtime)%60);
             }
          
-         if (gdata.curtime > lasttime+10) {
-            outerror(OUTERROR_TYPE_WARN,"System Time Changed Forward or Mainloop Skipped %lim %lis!!\n",
-               (long)(gdata.curtime-lasttime)/60,(long)(gdata.curtime-lasttime)%60);
+         if (gdata.curtime > lasttime + MAX_WAKEUP_WARN) {
+            outerror(OUTERROR_TYPE_WARN, "System Time Changed Forward or Mainloop Skipped %lim %lis!!\n",
+                     (long)(gdata.curtime-lasttime)/60, (long)(gdata.curtime-lasttime)%60);
+              if (gdata.debug > 0) {
+                dump_slow_context();
+                }
+            }
+
+         if (gdata.curtime > lasttime + MAX_WAKEUP_ERR) {
+            outerror(OUTERROR_TYPE_WARN, "System Time Changed Forward or Mainloop Skipped %lim %lis!!\n",
+               (long)(gdata.curtime-lasttime)/60, (long)(gdata.curtime-lasttime)%60);
             if (gdata.debug > 0)
               {
                 dumpcontext();
@@ -365,6 +290,22 @@
          changemin = 1;
          }
       
+      if (gdata.needsshutdown)
+        {
+          gdata.needsshutdown = 0;
+          shutdowniroffer();
+        }
+      
+      if (gdata.needsreap)
+        {
+          gdata.needsreap = 0;
+          irc_resolved();
+        }
+      
+#ifdef USE_CURL
+      fetch_perform();
+#endif /* USE_CURL */
+      
       updatecontext();
       
       if (changesec) {
@@ -382,21 +323,6 @@
          run_delayed_jobs();
       }
 
-      if (changequartersec)
-        {
-          tr = irlist_get_head(&gdata.trans);
-          while(tr)
-            {
-              if ( !tr->nomax &&
-                   (tr->maxspeed > 0))
-                {
-                  tr->tx_bucket += tr->maxspeed * (1024 / 4);
-                  tr->tx_bucket = min2(tr->tx_bucket, MAX_TRANSFER_TX_BURST_SIZE * tr->maxspeed * 1024);
-                }
-              tr = irlist_get_next(tr);
-            }
-        }
-      
       updatecontext();
       
       /*----- see if anything waiting on console ----- */
@@ -404,521 +330,15 @@
       if (!gdata.background && FD_ISSET(fileno(stdin), &gdata.readset))
          parseconsole();
       
-      updatecontext();
-      
-      for (ss=0; ss<gdata.networks_online; ss++)
-        {
-          gnetwork = &(gdata.networks[ss]);
-      /*----- see if gdata.ircserver is sending anything to us ----- */
-      if (gnetwork->serverstatus == SERVERSTATUS_CONNECTED && FD_ISSET(gnetwork->ircserver, &gdata.readset)) {
-         char tempbuffa[INPUT_BUFFER_LENGTH];
-         gnetwork->lastservercontact = gdata.curtime;
-         gnetwork->servertime = 0;
-         memset(&tempbuffa, 0, INPUT_BUFFER_LENGTH);
-         length = readserver_ssl(&tempbuffa, INPUT_BUFFER_LENGTH);
-         
-         if (length < 1) {
-            if (errno != EAGAIN) {
-            ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
-                    "Closing Server Connection on %s: %s",
-                    gnetwork->name, (length<0) ? strerror(errno) : "Closed");
-            if (gdata.exiting)
-              {
-                gnetwork->recentsent = 0;
-              }
-            close_server();
-            mydelete(gnetwork->curserveractualname);
-            }
-            }
-         else
-           {
-             j=strlen(gnetwork->server_input_line);
-             for (i=0; i<(unsigned int)length; i++)
-               {
-                 if ((tempbuffa[i] == '\n') || (j == (INPUT_BUFFER_LENGTH-1)))
-                   {
-                     if (j && (gnetwork->server_input_line[j-1] == 0x0D))
-                       {
-                         j--;
-                       }
-                     gnetwork->server_input_line[j] = '\0';
-                     ir_parseline(gnetwork->server_input_line);
-                     j = 0;
-                   }
-                 else
-                   {
-                     gnetwork->server_input_line[j] = tempbuffa[i];
-                     j++;
-                   }
-               }
-             gnetwork->server_input_line[j] = '\0';
-           }
-        }
-      
-      if ((gnetwork->serverstatus == SERVERSTATUS_SSL_HANDSHAKE) &&
-	((FD_ISSET(gnetwork->ircserver, &gdata.writeset)) || (FD_ISSET(gnetwork->ircserver, &gdata.readset))))
-        {
-          handshake_ssl();
-        }
-      
-      if (gnetwork->serverstatus == SERVERSTATUS_TRYING && FD_ISSET(gnetwork->ircserver, &gdata.writeset))
-        {
-          int callval_i;
-          int connect_error;
-          SIGNEDSOCK int connect_error_len = sizeof(connect_error);
-          
-          callval_i = getsockopt(gnetwork->ircserver,
-                                 SOL_SOCKET, SO_ERROR,
-                                 &connect_error, &connect_error_len);
-          
-          if (callval_i < 0)
-            {
-              outerror(OUTERROR_TYPE_WARN,
-                       "Couldn't determine connection status: %s on %s",
-                       strerror(errno), gnetwork->name);
-            }
-          else if (connect_error)
-            {
-              ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                      "Server Connection Failed: %s on %s", strerror(connect_error), gnetwork->name);
-            }
-          
-          if ((callval_i < 0) || connect_error)
-            {
-              close_server();
-            }
-          else
-            {
-	    SIGNEDSOCK int addrlen; 
-          
-            ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                    "Server Connection to %s Established, Logging In",  gnetwork->name);
-            gnetwork->serverstatus = SERVERSTATUS_CONNECTED;
-            gnetwork->connecttime = gdata.curtime;
-            gnetwork->botstatus = BOTSTATUS_LOGIN;
-            ch = irlist_get_head(&(gnetwork->channels));
-            if (ch == NULL)
-              {
-                gnetwork->botstatus = BOTSTATUS_JOINED;
-                start_sends();
-              }
-            FD_CLR(gnetwork->ircserver, &gdata.writeset);
-#if 0
-            if (set_socket_nonblocking(gnetwork->ircserver, 0) < 0 )
-	      outerror(OUTERROR_TYPE_WARN,"Couldn't Set Blocking");
-#endif
-	    
-            addrlen = sizeof(gnetwork->myip);
-            bzero((char *) &(gnetwork->myip), sizeof(gnetwork->myip));
-            if (getsockname(gnetwork->ircserver, &(gnetwork->myip.sa), &addrlen) >= 0)
-              {
-                if (gdata.debug > 0)
-                  {
-                    char *msg;
-                    msg = mymalloc(maxtextlength);
-                    my_getnameinfo(msg, maxtextlength -1, &(gnetwork->myip.sa));
-                    ioutput(OUT_S, COLOR_YELLOW, "using %s", msg);
-                    mydelete(msg);
-                  }
-                if (!gnetwork->usenatip)
-                  {
-                    gnetwork->ourip = ntohl(gnetwork->myip.sin.sin_addr.s_addr);
-                    if (gdata.debug > 0)
-                      {
-                        ioutput(OUT_S, COLOR_YELLOW, "ourip = " IPV4_PRINT_FMT,
-                                IPV4_PRINT_DATA(gnetwork->ourip));
-                      }
-                  }
-              }
-            else
-              outerror(OUTERROR_TYPE_WARN, "couldn't get ourip on %s", gnetwork->name);
-	    
-            handshake_ssl();
-            }
-         }
-      
-      if ((gnetwork->serverstatus == SERVERSTATUS_RESOLVING) &&
-          FD_ISSET(gnetwork->serv_resolv.sp_fd[0], &gdata.readset))
-        {
-          res_addrinfo_t remote;
-          length = read(gnetwork->serv_resolv.sp_fd[0],
-                        &remote, sizeof(res_addrinfo_t));
-          
-          kill(gnetwork->serv_resolv.child_pid, SIGKILL);
-          FD_CLR(gnetwork->serv_resolv.sp_fd[0], &gdata.readset);
-          
-          if (length != sizeof(res_addrinfo_t))
-            {
-              ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
-                      "Error resolving server %s on %s",
-                      gnetwork->curserver.hostname, gnetwork->name);
-              gnetwork->serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
-            }
-          else
-            {
-              /* continue with connect */
-              if (connectirc2(&remote))
-                {
-                  /* failed */
-                  gnetwork->serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
-                }
-            }
-        }
-      
-      if (changesec && gnetwork->serverstatus == SERVERSTATUS_RESOLVING)
-        {
-          int timeout;
-          timeout = CTIMEOUT + (gnetwork->serverconnectbackoff * CBKTIMEOUT);
-          
-          if (gnetwork->lastservercontact + timeout < gdata.curtime)
-            {
-              kill(gnetwork->serv_resolv.child_pid, SIGKILL);
-              ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                      "Server Resolve Timed Out (%u seconds) on %s", timeout, gnetwork->name);
-              gnetwork->serverstatus = SERVERSTATUS_NEED_TO_CONNECT;
-            }
-        }
-      
-      if (changesec && ((gnetwork->serverstatus == SERVERSTATUS_TRYING) || (gnetwork->serverstatus == SERVERSTATUS_SSL_HANDSHAKE)))
-        {
-          int timeout;
-          timeout = CTIMEOUT + (gnetwork->serverconnectbackoff * CBKTIMEOUT);
-          
-          if (gnetwork->lastservercontact + timeout < gdata.curtime)
-            {
-              ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                      "Server Connection Timed Out (%u seconds) on %s", timeout, gnetwork->name);
-              close_server();
-            }
-        }
-      
-      if (gdata.needsswitch)
-        {
-          gdata.needsswitch = 0;
-          switchserver(-1);
-        }
-        } /* networks */
-      gnetwork = NULL;
-      
-      updatecontext();
-      
-      ul = irlist_get_head(&gdata.uploads);
-      while(ul)
-        {
-          gnetwork = &(gdata.networks[ul->net]);
-          /*----- see if uploads are sending anything to us ----- */
-          if (ul->ul_status == UPLOAD_STATUS_GETTING && FD_ISSET(ul->con.clientsocket, &gdata.readset))
-            {
-              l_transfersome(ul);
-            }
-
-          if (ul->ul_status == UPLOAD_STATUS_LISTENING && FD_ISSET(ul->con.listensocket, &gdata.readset))
-            {
-              l_setup_accept(ul);
-            }
-
-          if (ul->ul_status == UPLOAD_STATUS_CONNECTING && FD_ISSET(ul->con.clientsocket, &gdata.writeset))
-            {
-              int callval_i;
-              int connect_error;
-              SIGNEDSOCK int connect_error_len = sizeof(connect_error);
-              
-              callval_i = getsockopt(ul->con.clientsocket,
-                                     SOL_SOCKET, SO_ERROR,
-                                     &connect_error, &connect_error_len);
-              
-              if (callval_i < 0)
-                {
-                  int errno2 = errno;
-                  outerror(OUTERROR_TYPE_WARN,
-                           "Couldn't determine upload connection status on %s: %s",
-                           gnetwork->name, strerror(errno));
-                  l_closeconn(ul, "Upload Connection Failed status:", errno2);
-                }
-              else if (connect_error)
-                {
-                  l_closeconn(ul,"Upload Connection Failed",connect_error);
-                }
-              
-              if ((callval_i < 0) || connect_error)
-                {
-                  FD_CLR(ul->con.clientsocket, &gdata.writeset);
-                }
-              else
-                {
-                  ioutput(OUT_S|OUT_L|OUT_D, COLOR_MAGENTA,
-                          "Upload Connection Established on %s", gnetwork->name);
-                  ul->ul_status = UPLOAD_STATUS_GETTING;
-                  FD_CLR(ul->con.clientsocket, &gdata.writeset);
-                  notice(ul->nick,"DCC Connection Established");
-                  ul->con.connecttime = gdata.curtime;
-                }
-            }
-          
-          if (changesec && ul->ul_status == UPLOAD_STATUS_CONNECTING && ul->con.lastcontact + CTIMEOUT < gdata.curtime)
-            {
-              FD_CLR(ul->con.clientsocket, &gdata.readset);
-              l_closeconn(ul,"Upload Connection Timed Out",0);
-            }
-          
-          if (changesec)
-            {            
-              l_istimeout(ul);
-            }
-          
-          if (changesec && ul->ul_status == UPLOAD_STATUS_DONE)
-            {
-              close_qupload(ul->net, ul->nick);
-              mydelete(ul->nick);
-              mydelete(ul->hostname);
-              mydelete(ul->uploaddir);
-              mydelete(ul->file);
-              mydelete(ul->con.remoteaddr);
-              ul = irlist_delete(&gdata.uploads, ul);
-            }
-          else
-            {
-              ul = irlist_get_next(ul);
-            }
-        }
-      gnetwork = NULL;
-      
-      updatecontext();
-      /*----- see if dccchat is sending anything to us ----- */
-      for (chat = irlist_get_head(&gdata.dccchats);
-           chat;
-           chat = irlist_get_next(chat))
-        {
-          char tempbuffa[INPUT_BUFFER_LENGTH];
-          gnetwork = &(gdata.networks[chat->net]);
-          switch (chat->status)
-          {
-          case DCCCHAT_CONNECTING:
-            if (FD_ISSET(chat->con.clientsocket, &gdata.writeset))
-            {
-              int callval_i;
-              int connect_error;
-              SIGNEDSOCK int connect_error_len = sizeof(connect_error);
-              
-              callval_i = getsockopt(chat->con.clientsocket,
-                                     SOL_SOCKET, SO_ERROR,
-                                     &connect_error, &connect_error_len);
-              
-              if (callval_i < 0)
-                {
-                  int errno2 = errno;
-                  outerror(OUTERROR_TYPE_WARN,
-                           "Couldn't determine dcc connection status on %s: %s",
-                           gnetwork->name, strerror(errno));
-                  notice(chat->nick, "DCC Chat Connect Attempt Failed: %s", strerror(errno2));
-                }
-              else if (connect_error)
-                {
-                  ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                          "DCC Chat Connect Attempt Failed on %s: %s",
-                          gnetwork->name, strerror(connect_error));
-                  notice(chat->nick, "DCC Chat Connect Attempt Failed: %s", strerror(connect_error));
-                }
-              
-              if ((callval_i < 0) || connect_error)
-                {
-                  shutdowndccchat(chat,0);
-                }
-              else
-                {
-                  setupdccchatconnected(chat);
-                }
-            }
-            break;
-          case DCCCHAT_LISTENING:
-            if (FD_ISSET(chat->con.listensocket, &gdata.readset))
-              {
-                setupdccchataccept(chat);
-              }
-            break;
-          case DCCCHAT_AUTHENTICATING:
-          case DCCCHAT_CONNECTED:
-            if (FD_ISSET(chat->con.clientsocket, &gdata.readset))
-              {
-                  memset(tempbuffa, 0, INPUT_BUFFER_LENGTH);
-                  length = recv(chat->con.clientsocket, &tempbuffa, INPUT_BUFFER_LENGTH, MSG_DONTWAIT);
-                  
-                  if (length < 1)
-                    {
-                      ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                              "DCC Chat Lost on %s: %s",
-                              gnetwork->name,
-                              (length<0) ? strerror(errno) : "Closed");
-                      notice(chat->nick, "DCC Chat Lost: %s", (length<0) ? strerror(errno) : "Closed");
-                      shutdowndccchat(chat,0);
-                      /* deleted below */
-                    }
-                  else
-                    {
-                      j=strlen(chat->dcc_input_line);
-                      for (i=0; i<(unsigned int)length; i++)
-                        {
-                          if ((tempbuffa[i] == '\n') || (j == (INPUT_BUFFER_LENGTH-1)))
-                            {
-                              if (j && (chat->dcc_input_line[j-1] == 0x0D))
-                                {
-                                  j--;
-                                }
-                              chat->dcc_input_line[j] = '\0';
-                              parsedccchat(chat, chat->dcc_input_line);
-                              j = 0;
-                            }
-                          else
-                            {
-                              chat->dcc_input_line[j] = tempbuffa[i];
-                              j++;
-                            }
-                        }
-                      chat->dcc_input_line[j] = '\0';
-                    }
-                  break;
-                  
-              }
-            break;
-          case DCCCHAT_UNUSED:
-          default:
-            break;
-          }
-        }
-      gnetwork = NULL;
-      
-      updatecontext();
-      
-      i = j = select_starting_transfer(irlist_size(&gdata.trans));
-      
-      tr = irlist_get_nth(&gdata.trans, i);
-      
-      /* first: do from cur to end */
-      while(tr)
-        {
-          if (tr->tr_status == TRANSFER_STATUS_SENDING)
-            {
-              /*----- look for transfer some -----  send at least once a second, or more if necessary */
-              if (changequartersec || FD_ISSET(tr->con.clientsocket, &gdata.writeset))
-                {
-                  gnetwork = &(gdata.networks[tr->net]);
-                  t_transfersome(tr);
-                }
-            }
-          tr = irlist_get_next(tr);
-        }
-      
-      /* second: do from begin to cur-1 */
-      tr = irlist_get_head(&gdata.trans);
-      while(tr && j--)
-        {
-          if (tr->tr_status == TRANSFER_STATUS_SENDING)
-            {
-              /*----- look for transfer some -----  send at least once a second, or more if necessary */
-              if (changequartersec || FD_ISSET(tr->con.clientsocket, &gdata.writeset))
-                {
-                  gnetwork = &(gdata.networks[tr->net]);
-                  t_transfersome(tr);
-                }
-            }
-          tr = irlist_get_next(tr);
-        }
-      
-      tr = irlist_get_head(&gdata.trans);
-      while(tr)
-        {
-          gnetwork = &(gdata.networks[tr->net]);
-          /*----- look for listen reminders ----- */
-          if (changesec &&
-              (tr->tr_status == TRANSFER_STATUS_LISTENING) &&
-              ((gdata.curtime - tr->con.lastcontact) >= 30) &&
-              (tr->reminded == 0))
-            {
-              t_remind(tr);
-            }
-          if (changesec &&
-              (tr->tr_status == TRANSFER_STATUS_LISTENING) &&
-              ((gdata.curtime - tr->con.lastcontact) >= 90) &&
-              (tr->reminded == 1) && !gdata.quietmode)
-            {
-              t_remind(tr);
-            }
-          if (changesec &&
-              (tr->tr_status == TRANSFER_STATUS_LISTENING) &&
-              ((gdata.curtime - tr->con.lastcontact) >= 150) &&
-              (tr->reminded == 2) && !gdata.quietmode)
-            {
-              t_remind(tr);
-            }
-
-         if (changesec &&
-             (tr->tr_status == TRANSFER_STATUS_CONNECTING) &&
-             FD_ISSET(tr->con.clientsocket, &gdata.writeset))
-            {
-              t_connected(tr);
-            }
-  
-          /*----- look for listen->connected ----- */
-          if ((tr->tr_status == TRANSFER_STATUS_LISTENING) &&
-              FD_ISSET(tr->con.listensocket, &gdata.readset))
-            {
-              t_establishcon(tr);
-              t_check_new_connection(tr);
-            }
-          
-          /*----- look for junk to read ----- */
-          if (((tr->tr_status == TRANSFER_STATUS_SENDING) ||
-               (tr->tr_status == TRANSFER_STATUS_WAITING)) &&
-              FD_ISSET(tr->con.clientsocket, &gdata.readset))
-            {
-              t_readjunk(tr);
-            }
-          
-          /*----- look for done flushed status ----- */
-          if (tr->tr_status == TRANSFER_STATUS_WAITING)
-            {
-              t_flushed(tr);
-            }
-          
-          /*----- look for lost transfers ----- */
-          if (changesec && (tr->tr_status != TRANSFER_STATUS_DONE))
-            {
-              t_istimeout(tr);
-            }
-          
-          /*----- look for finished transfers ----- */
-          if (tr->tr_status == TRANSFER_STATUS_DONE)
-            {
-              char *trnick;
-
-              trnick = tr->nick;
-              mydelete(tr->caps_nick);
-              mydelete(tr->hostname);
-              mydelete(tr->con.localaddr);
-              mydelete(tr->con.remoteaddr);
-              tr = irlist_delete(&gdata.trans, tr);
-              
-              if (!gdata.exiting &&
-                  irlist_size(&gdata.mainqueue) &&
-                  (irlist_size(&gdata.trans) < gdata.slotsmax))
-                {
-                  check_idle_queue();
-                  send_from_queue(0, 0, trnick);
-                }
-              mydelete(trnick);
-            }
-          else
-            {
-              tr = irlist_get_next(tr);
-            }
-         }
-      gnetwork = NULL;
-
+      irc_perform(changesec);
+      l_perform(changesec);
+      chat_perform();
+      t_perform(changesec, changequartersec);
 #ifndef WITHOUT_TELNET
       telnet_perform();
 #endif /* WITHOUT_TELNET */
 #ifndef WITHOUT_HTTP
-      h_perform(changesec);
+      h_perform(changesec, changequartersec);
 #endif /* WITHOUT_HTTP */
       
       /*----- time for a delayed shutdown? ----- */
@@ -1095,19 +515,9 @@
         }
       
       /*----- periodicmsg_time seconds ----- */
-      if (changesec && ((unsigned)gdata.curtime > (lastperiodicmsg + gdata.periodicmsg_time*60))) {
-         lastperiodicmsg = gdata.curtime;
-         
-         for (ss=0; ss<gdata.networks_online; ss++) {
-            if (gdata.periodicmsg_nick && gdata.periodicmsg_msg
-            && (gdata.networks[ss].serverstatus == SERVERSTATUS_CONNECTED) ) {
-               gnetwork = &(gdata.networks[ss]);
-               privmsg(gdata.periodicmsg_nick, "%s", gdata.periodicmsg_msg);
-            }
-         }
-         
+      if (changesec) {
+         send_periodicmsg();
          }
-      gnetwork = NULL;
       
       updatecontext();
       
@@ -1349,7 +759,7 @@
              irlist_size(&gdata.mainqueue) &&
              (irlist_size(&gdata.trans) < gdata.maxtrans))
            {
-             check_idle_queue();
+             check_idle_queue(0);
              send_from_queue(1, 0, NULL);
            }
          write_files();
@@ -1476,6 +886,7 @@
 #ifdef USE_RUBY
 	 rehash_myruby(1);
 #endif /* USE_RUBY */
+         delayed_announce();
          }
       
       updatecontext();
@@ -1484,7 +895,7 @@
         {
           reverify_restrictsend();
           update_hour_dinoex(lastmin);
-          check_idle_queue();
+          check_idle_queue(0);
           clean_uploadhost();
           auto_rehash();
         }
@@ -1608,28 +1019,6 @@
          }
       
       updatecontext();
-      for (ss=0; ss<gdata.networks_online; ss++) {
-        gnetwork = &(gdata.networks[ss]);
-      if (gnetwork->offline)
-        continue;
-      if (gnetwork->serverstatus == SERVERSTATUS_NEED_TO_CONNECT)
-        {
-          int timeout;
-          timeout = CTIMEOUT + (gnetwork->serverconnectbackoff * CBKTIMEOUT);
-          
-          if (gnetwork->lastservercontact + timeout < gdata.curtime)
-            {
-              if (gdata.debug > 0)
-                {
-                  ioutput(OUT_S, COLOR_YELLOW,
-                          "Reconnecting to server (%u seconds) on %s",
-                          timeout, gnetwork->name);
-                }
-              switchserver(-1);
-            }
-        }
-      } /* networks */
-      gnetwork = NULL;
       
       if (gdata.needsrehash) {
          gdata.needsrehash = 0;
@@ -1670,620 +1059,9 @@
       /* END */
       updatecontext();
       if (gdata.needsclear) drawbot();
-      if (gdata.attop) gotobot();
       
       changehour=changemin=0;
       
    }
 
-static void ir_parseline(char *line) {
-   char *part2, *part3, *part4, *part5;
-   char *part3a;
-   char *t;
-   unsigned int i;
-   char *tptr;
-   channel_t *ch;
-   
-   updatecontext();
-   
-   removenonprintable(line);
-#ifdef USE_RUBY
-   if (do_myruby_server(line))
-     return;
-#endif /* USE_RUBY */
-   /* we only support lines upto maxtextlength, truncate line */
-   line[maxtextlength-1] = '\0';
-   
-   if (gdata.debug > 0)
-      ioutput(OUT_S, COLOR_CYAN, ">IRC>: %u, %s", gnetwork->net + 1, line);
-   
-   part2 = getpart(line,2);
-   if (part2 == NULL)
-     {
-       return;
-     }
-   part3 = getpart(line,3);
-   part4 = getpart(line,4);
-   part5 = getpart(line,5);
-   
-   
-   if (part3 && part3[0] == ':')
-     {
-       part3a = part3+1;
-     }
-   else
-     {
-       part3a = part3;
-     }
-   
- /* NOTICE nick */
-   if (part3 && gnetwork->caps_nick && !strcmp(caps(part2), "NOTICE") && !strcmp(caps(part3), gnetwork->caps_nick))
-     {
-       /* nickserv */
-       identify_check(line);
-#ifdef USE_RUBY
-       if (do_myruby_notice(line) == 0)
-#endif /* USE_RUBY */
-       privmsgparse(0, 0, line);
-     }
- 
- /* :server 001  xxxx :welcome.... */
-   if ( !strcmp(part2,"001") )
-     {
-       ioutput(OUT_S|OUT_L, COLOR_NO_COLOR, "Server welcome: %s", line);
-       update_server_welcome(line);
-       
-       /* update server name */
-       mydelete(gnetwork->curserveractualname);
-       gnetwork->curserveractualname = getpart(line+1, 1);
-       
-       /* update nick */
-       mydelete(gnetwork->user_nick);
-       mydelete(gnetwork->caps_nick);
-       gnetwork->user_nick = mystrdup(part3);
-       gnetwork->caps_nick = mystrdup(part3);
-       caps(gnetwork->caps_nick);
-       gnetwork->nick_number = 0;
-       gnetwork->next_restrict = gdata.curtime + gdata.restrictsend_delay;
-       gdata.needsclear = 1;
-       
-       tptr = get_user_modes();
-       if (tptr && strlen(tptr))
-         {
-           writeserver(WRITESERVER_NOW, "MODE %s %s",
-                       gnetwork->user_nick, tptr);
-         }
-       
-       /* server connected raw command */
-       tptr = irlist_get_head(&(gnetwork->server_connected_raw));
-       while(tptr)
-         {
-           writeserver(WRITESERVER_NORMAL, "%s", tptr);
-           tptr = irlist_get_next(tptr);
-         }
-       
-       /* nickserv */
-       identify_needed(0);
-     }
-
-   /* :server 005 xxxx aaa bbb=x ccc=y :are supported... */
-   if ( !strcmp(part2,"005") )
-     {
-       unsigned int ii = 4;
-       char *item;
-       
-       while((item = getpart(line, ii++)))
-         {
-           if (item[0] == ':')
-             {
-               mydelete(item);
-               break;
-             }
-           
-           if (!strncmp("PREFIX=(", item, 8))
-             {
-               char *ptr = item+8;
-               unsigned int pi;
-               memset(&(gnetwork->prefixes), 0, sizeof(gnetwork->prefixes));
-               for (pi = 0; (ptr[pi] && (ptr[pi] != ')') && (pi < MAX_PREFIX)); pi++)
-                 {
-                   gnetwork->prefixes[pi].p_mode = ptr[pi];
-                 }
-               if (ptr[pi] == ')')
-                 {
-                   ptr += pi + 1;
-                   for (pi = 0; (ptr[pi] && (pi < MAX_PREFIX)); pi++)
-                     {
-                       gnetwork->prefixes[pi].p_symbol = ptr[pi];
-                     }
-                 }
-               for (pi = 0; pi < MAX_PREFIX; pi++)
-                 {
-                   if ((gnetwork->prefixes[pi].p_mode && !gnetwork->prefixes[pi].p_symbol) ||
-                       (!gnetwork->prefixes[pi].p_mode && gnetwork->prefixes[pi].p_symbol))
-                     {
-                       outerror(OUTERROR_TYPE_WARN,
-                                "Server prefix list on %s doesn't make sense, using defaults: %s",
-                                gnetwork->name, item);
-                       initprefixes();
-                     }
-                 }
-             }
-           
-           if (!strncmp("CHANMODES=", item, 10))
-             {
-               char *ptr = item+10;
-               unsigned int ci;
-               unsigned int cm;
-               memset(&(gnetwork->chanmodes), 0, sizeof(gnetwork->chanmodes));
-               for (ci = cm = 0; (ptr[ci] && (cm < MAX_CHANMODES)); ci++)
-                 {
-                   if (ptr[ci+1] == ',')
-                     {
-                       /* we only care about ones with arguments */
-                       gnetwork->chanmodes[cm++] = ptr[ci++];
-                     }
-                 }
-             }
-           
-           mydelete(item);
-         }
-     }
-  
- /* :server 401 botnick usernick :No such nick/channel */
-   if ( !strcmp(part2, "401") && part3 && !strcmp(part3, "*") && part4 )
-     {
-       lost_nick(part4);
-     }
-  
- /* :server 433 old new :Nickname is already in use. */
-   if ( !strcmp(part2,"433") && part3 && !strcmp(part3,"*") && part4 )
-     {
-       ioutput(OUT_S, COLOR_NO_COLOR,
-               "Nickname %s already in use on %s, trying %s%u",
-               part4,
-               gnetwork->name,
-               get_config_nick(),
-               gnetwork->nick_number);
-       
-       /* generate new nick and retry */
-       writeserver(WRITESERVER_NORMAL, "NICK %s%u",
-                   get_config_nick(),
-                   gnetwork->nick_number++);
-     }
-
- /* :server 470 botnick #channel :(you are banned) transfering you to #newchannel */
-   if ( !strcmp(part2, "470") && part3 && part4 && part5 )
-     {
-       outerror(OUTERROR_TYPE_WARN_LOUD,
-                "channel on %s: %s", gnetwork->name, strstr(line, "470"));
-       for (ch = irlist_get_head(&(gnetwork->channels));
-            ch;
-            ch = irlist_get_next(ch))
-         {
-           if (strcmp(caps(part3), gnetwork->caps_nick))
-             continue;
-           if (strcmp(caps(part4), ch->name))
-             continue;
-           ch->flags |= CHAN_KICKED;
-         }
-     }
-
-   /* names list for a channel */
-   /* :server 353 our_nick = #channel :nick @nick +nick nick */
-   if ( !strcmp(part2,"353") && part3 && part4 && part5 )
-     {
-       caps(part5);
-       
-       ch = irlist_get_head(&(gnetwork->channels));
-       while(ch)
-         {
-           if (!strcmp(part5,ch->name))
-             {
-               break;
-             }
-           ch = irlist_get_next(ch);
-         }
-       
-       if (!ch)
-         {
-           ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                   "Got name data for %s which is not a known channel on %s!",
-                   part5, gnetwork->name);
-           writeserver(WRITESERVER_NORMAL, "PART %s", part5);
-         }
-       else
-	 {
-	   for (i=0; (t = getpart(line,6+i)); i++)
-	     {
-               addtomemberlist(ch, i == 0 ? t+1 : t);
-	       mydelete(t);
-	     }
-	 }
-     }
-  
- /* ERROR :Closing Link */
-   if (strncmp(line, "ERROR :Closing Link", strlen("ERROR :Closing Link")) == 0) {
-      if (gdata.exiting)
-         gnetwork->recentsent = 0;
-      else {
-         ioutput(OUT_S|OUT_L|OUT_D, COLOR_RED,
-                 "Server Closed Connection on %s: %s",
-                 gnetwork->name, line);
-         close_server();
-         }
-      }
-   
- /* server ping */
-   if (PING_SRVR && (strncmp(line, "PING :", 6) == 0)) {
-      if (gdata.debug > 0)
-         ioutput(OUT_S, COLOR_NO_COLOR,
-                 "Server Ping on %s: %s",
-                 gnetwork->name, line);
-      writeserver(WRITESERVER_NOW, "PO%s", line+2);
-      }
-
-   if (gnetwork->lastping != 0) {
-     if (strcmp(part2, "PONG") == 0) {
-       lag_message();
-     }
-   }
-
- /* JOIN */
-   if (!strcmp(part2, "JOIN") && part3a && gnetwork->caps_nick) {
-      char* nick;
-      int j;
-      nick = mymalloc(strlen(line)+1);
-      j=1;
-      gnetwork->nocon = 0;
-      while(line[j] != '!' && j<sstrlen(line)) {
-         nick[j-1] = line[j];
-         j++;
-         }
-      nick[j-1]='\0';
-      if (!strcmp(caps(nick), gnetwork->caps_nick))
-        {
-          /* we joined */
-          /* clear now, we have succesfully logged in */
-          gnetwork->serverconnectbackoff = 0;
-          ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                  "Joined %s on %s", caps(part3a), gnetwork->name);
-          
-          ch = irlist_get_head(&(gnetwork->channels));
-          while(ch)
-            {
-              if (!strcmp(part3a,ch->name))
-                {
-                  ch->flags |= CHAN_ONCHAN;
-                  ch->lastjoin = gdata.curtime;
-                  ch->nextann = gdata.curtime + gdata.waitafterjoin;
-                  if (ch->joinmsg)
-                    {
-                      writeserver(WRITESERVER_NOW, "PRIVMSG %s :%s", ch->name, ch->joinmsg);
-                    }
-                  gnetwork->botstatus = BOTSTATUS_JOINED;
-                  start_sends();
-                  break;
-                }
-              ch = irlist_get_next(ch);
-            }
-          
-
-          if (!ch)
-            {
-              ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                  "%s is not a known channel on %s!",
-                  part3a, gnetwork->name);
-            }
-        }
-      else
-	{
-	  /* someone else joined */
-	  caps(part3a);
-          ch = irlist_get_head(&(gnetwork->channels));
-          while(ch)
-            {
-              if (!strcmp(part3a,ch->name))
-                {
-                  break;
-                }
-              ch = irlist_get_next(ch);
-            }
-	  
-	  if (!ch)
-            {
-              ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                      "%s is not a known channel on %s!",
-                      part3a, gnetwork->name);
-            }
-	  else
-            {
-              addtomemberlist(ch,nick);
-            }
-	}
-	
-      mydelete(nick);
-      }
-
- /* PART */
-   if (!strcmp(part2, "PART") && part3a && gnetwork->caps_nick)
-     {
-       char* nick;
-       int j;
-       nick = mymalloc(strlen(line)+1);
-       j=1;
-       while(line[j] != '!' && j<sstrlen(line))
-	 {
-	   nick[j-1] = line[j];
-	   j++;
-	 }
-       nick[j-1]='\0';
-       
-       if (!strcmp(caps(nick), gnetwork->caps_nick))
-	 {
-	   /* we left? */
-	   ;
-	 }
-       else
-	 {
-	   /* someone else left */
-	   caps(part3a);
-           ch = irlist_get_head(&(gnetwork->channels));
-           while(ch)
-             {
-               if (!strcmp(part3a,ch->name))
-                 {
-                   break;
-                 }
-               ch = irlist_get_next(ch);
-             }
-	   
-	   if (!ch)
-             {
-               ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
-                       "%s is not a known channel on %s!",
-                       part3a, gnetwork->name);
-             }
-	   else
-             {
-               removefrommemberlist(ch,nick);
-             }
-           reverify_restrictsend();
-	 }
-       
-       mydelete(nick);
-     }
-   
- /* QUIT */
-   if (!strcmp(part2, "QUIT") && gnetwork->caps_nick)
-     {
-       char* nick;
-       int j;
-       nick = mymalloc(strlen(line)+1);
-       j=1;
-       while(line[j] != '!' && j<sstrlen(line))
-	 {
-	   nick[j-1] = line[j];
-	   j++;
-	 }
-       nick[j-1]='\0';
-       
-       if (!strcmp(caps(nick), gnetwork->caps_nick))
-	 {
-	   /* we quit? */
-           outerror(OUTERROR_TYPE_WARN_LOUD,
-                    "Forced quit on %s: %s", gnetwork->name, line);
-           close_server();
-           clean_send_buffers();
-           /* do not reconnect */
-           gnetwork->serverstatus = SERVERSTATUS_EXIT;
-	 }
-       else
-	 {
-	   /* someone else quit */
-           ch = irlist_get_head(&(gnetwork->channels));
-           while(ch)
-             {
-               removefrommemberlist(ch,nick);
-               ch = irlist_get_next(ch);
-             }
-           reverify_restrictsend();
-	 }
-       
-       mydelete(nick);
-     }
-   
- /* NICK */
-   if (!strcmp(part2, "NICK") && part3a)
-     {
-       char *oldnick, *newnick;
-       int j;
-       oldnick = mymalloc(strlen(line)+1);
-       j=1;
-       while(line[j] != '!' && j<sstrlen(line))
-	 {
-	   oldnick[j-1] = line[j];
-	   j++;
-	 }
-       oldnick[j-1]='\0';
-
-       newnick = part3a;
-       
-       if (gnetwork->caps_nick && !strcmp(caps(oldnick), gnetwork->caps_nick))
-	 {
-           /* nickserv */
-           identify_needed(0);
-           
-           /* we changed, update nick */
-           mydelete(gnetwork->user_nick);
-           mydelete(gnetwork->caps_nick);
-           gnetwork->user_nick = mystrdup(part3a);
-           gnetwork->caps_nick = mystrdup(part3a);
-           caps(gnetwork->caps_nick);
-           gnetwork->nick_number = 0;
-           gdata.needsclear = 1;
-         }
-       
-       ch = irlist_get_head(&(gnetwork->channels));
-       while(ch)
-         {
-           changeinmemberlist_nick(ch, oldnick, newnick);
-           ch = irlist_get_next(ch);
-         }
-       
-       user_changed_nick(oldnick, newnick);
-       
-       mydelete(oldnick);
-     }
-   
- /* KICK */
-   if (!strcmp(part2, "KICK") && part3a && part4 && gnetwork->caps_nick)
-     {
-       ch = irlist_get_head(&(gnetwork->channels));
-       while(ch)
-         {
-           if (!strcmp(caps(part3a),ch->name))
-             {
-               if(!strcmp(caps(part4), gnetwork->caps_nick))
-                 {
-                   /* we were kicked */
-                   if ( gdata.noautorejoin )
-                     {
-                       outerror(OUTERROR_TYPE_WARN_LOUD,
-                               "Kicked on %s: %s", gnetwork->name, line);
-                       ch->flags |= CHAN_KICKED;
-                       clearmemberlist(ch);
-                       reverify_restrictsend();
-                     }
-                   else
-                     {
-                       outerror(OUTERROR_TYPE_WARN_LOUD,
-                               "Kicked on %s, Rejoining: %s", gnetwork->name, line);
-                       ch->flags &= ~CHAN_ONCHAN;
-                       joinchannel(ch);
-                     }
-                 }
-               else
-                 {
-                   /* someone else was kicked */
-                   removefrommemberlist(ch,part4);
-                 }
-             }
-           ch = irlist_get_next(ch);
-         }
-       reverify_restrictsend();
-     }
-   
-   /* MODE #channel +x ... */
-   if (!strcmp(part2,"MODE") && part3 && part4)
-     {
-       /* find channel */
-       for (ch = irlist_get_head(&(gnetwork->channels)); ch; ch = irlist_get_next(ch))
-         {
-           if (!strcasecmp(ch->name, part3))
-             {
-               break;
-             }
-         }
-       if (ch)
-         {
-           unsigned int plus = 0;
-           unsigned int part = 5;
-           char *ptr;
-           
-           for (ptr = part4; *ptr; ptr++)
-             {
-               if (*ptr == '+')
-                 {
-                   plus = 1;
-                 }
-               else if (*ptr == '-')
-                 {
-                   plus = 0;
-                 }
-               else
-                 {
-                   unsigned int ii;
-                   for (ii = 0; (ii < MAX_PREFIX && gnetwork->prefixes[ii].p_mode); ii++)
-                     {
-                       if (*ptr == gnetwork->prefixes[ii].p_mode)
-                         {
-                           /* found a nick mode */
-                           char *nick = getpart(line, part++);
-                           if (nick)
-                             {
-                               if (nick[strlen(nick)-1] == '\1')
-                                 {
-                                   nick[strlen(nick)-1] = '\0';
-                                 }
-                               if (plus == 0)
-                                 {
-                                   if (strcasecmp(nick, get_config_nick()) == 0)
-                                     {
-                                       identify_needed(0);
-                                     }
-                                 }
-                               changeinmemberlist_mode(ch, nick,
-                                                       gnetwork->prefixes[ii].p_symbol,
-                                                       plus);
-                               mydelete(nick);
-                             }
-                           break;
-                         }
-                     }
-                   for (ii = 0; (ii < MAX_CHANMODES && gnetwork->chanmodes[ii]); ii++)
-                     {
-                       if (*ptr == gnetwork->chanmodes[ii])
-                         {
-                           /* found a channel mode that has an argument */
-                           part++;
-                           break;
-                         }
-                     }
-                 }
-             }
-         }
-       else
-         {
-           if (strcasecmp(part3, get_config_nick()) == 0)
-             {
-               if (part4[0] == '-')
-                 identify_needed(0);
-             }
-         }
-     }
-
- /* PRIVMSG */
-   if (!strcmp(part2,"PRIVMSG"))
-     {
-#ifndef WITHOUT_BLOWFISH
-       char *line2;
-
-       line2 = test_fish_message(line, part3, part4, part5);
-       if (line2)
-         {
-#ifdef USE_RUBY
-           if (do_myruby_privmsg(line2) == 0)
-#endif /* USE_RUBY */
-           privmsgparse(1, 1, line2);
-           mydelete(line2);
-         }
-       else
-         {
-#endif /* WITHOUT_BLOWFISH */
-#ifdef USE_RUBY
-           if (do_myruby_privmsg(line) == 0)
-#endif /* USE_RUBY */
-           privmsgparse(1, 0, line);
-#ifndef WITHOUT_BLOWFISH
-         }
-#endif /* WITHOUT_BLOWFISH */
-     }
-   
-   mydelete(part2);
-   mydelete(part3);
-   mydelete(part4);
-   mydelete(part5);
-   }
-
 /* End of File */
Index: src/iroffer_misc.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_misc.c,v
retrieving revision 1.322
retrieving revision 1.328
diff -u -r1.322 -r1.328
--- src/iroffer_misc.c	28 Jan 2011 07:05:06 -0000	1.322
+++ src/iroffer_misc.c	1 Jul 2011 09:52:28 -0000	1.328
@@ -351,7 +351,7 @@
   
   len = vsnprintf(msg,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"WRITESERVER: Output too large, ignoring!");
       mydelete(msg);
@@ -467,6 +467,9 @@
       return;
     }
   
+  if ( !gdata.noscreen && !gdata.background)
+    gototop();
+
   sendannounce();
   gnetwork->serverbucket += EXCESS_BUCKET_ADD;
   gnetwork->serverbucket = min2(gnetwork->serverbucket, EXCESS_BUCKET_MAX);
@@ -811,7 +814,7 @@
 #endif
 #endif
         
-        gdata.crashing = 1;
+        ++(gdata.crashing);
         
         ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR,
                 "!!! iroffer has received a fatal signal. !!!");
@@ -982,10 +985,12 @@
         
         ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "Context Trace:");
         
+        if ( gdata.crashing == 1 ) {
         dumpcontext();
         dumpgdata();
         
         ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "Crashing... Please report this problem to dinoex");
+        }
         
         tostdout_disable_buffering();
         
@@ -1501,6 +1506,7 @@
 
 void initvars(void)
 {
+  struct timeval timestruct;
   unsigned int ss;
 
   memset(&gdata, 0, sizeof(gdata_t));
@@ -1530,8 +1536,10 @@
   outerror(OUTERROR_TYPE_WARN, "max_file_size limited to 2GB");
 #endif
   
-  gdata.startuptime = gdata.curtime = time(NULL);
-  gdata.curtimems = ((ir_uint64)gdata.curtime) * 1000;
+  gettimeofday(&timestruct, NULL);
+  gdata.curtimems = timeval_to_ms(&timestruct);
+  gdata.curtime = timestruct.tv_sec;
+  gdata.startuptime = timestruct.tv_sec;
   
   gdata.sendbuff = mycalloc(BUFFERSIZE);
   gdata.console_input_line = mycalloc(INPUT_BUFFER_LENGTH);
@@ -1560,6 +1568,7 @@
    struct rlimit rlim;
    int callval;
    unsigned int ss;
+   unsigned int save;
    
    updatecontext();
    
@@ -1779,11 +1788,12 @@
    
    if (gdata.statefile)
      {
-       read_statefile();
-       start_main_queue();
-       import_xdccfile();
-       write_statefile();
+       save = read_statefile();
+       save += import_xdccfile();
+       if (save > 0)
+         write_statefile();
        autotrigger_rebuild();
+       start_main_queue();
      }
    
    /* fork to background if in background mode */
Index: src/iroffer_statefile.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_statefile.c,v
retrieving revision 1.72
retrieving revision 1.74
diff -u -r1.72 -r1.74
--- src/iroffer_statefile.c	5 Feb 2011 11:05:55 -0000	1.72
+++ src/iroffer_statefile.c	5 May 2011 20:00:29 -0000	1.74
@@ -166,6 +166,10 @@
 
 void write_statefile(void)
 {
+#ifdef DEBUG
+  ir_uint64 ms1;
+  ir_uint64 ms2;
+#endif /* DEBUG */
   char *statefile_tmp, *statefile_bkup;
   int fd;
   int callval;
@@ -180,6 +184,9 @@
       return;
     }
   
+#ifdef DEBUG
+  ms1 = get_time_in_ms();
+#endif /* DEBUG */
   statefile_tmp = mystrsuffix(gdata.statefile, ".tmp");
   statefile_bkup = mystrsuffix(gdata.statefile, "~");
   
@@ -285,7 +292,13 @@
   
   if (gdata.debug > 0)
     {
+#ifdef DEBUG
+      ms2 = get_time_in_ms();
+      ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "Done"
+              " running: %ld ms", (long)(ms2 - ms1));
+#else
       ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "Done");
+#endif /* DEBUG */
     }
   
  error_out:
@@ -324,7 +337,7 @@
 }
 
 
-void read_statefile(void)
+unsigned int read_statefile(void)
 {
   int fd;
   ir_uint32 *buffer, *buffer_begin;
@@ -334,6 +347,7 @@
   struct stat st;
   statefile_hdr_t *hdr;
   ir_uint32 calluval;
+  unsigned int save = 0;
   int callval;
   time_t timestamp = 0;
   
@@ -341,7 +355,7 @@
   
   if (gdata.statefile == NULL)
     {
-      return;
+      return save;
     }
   
   ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "Loading State File... ");
@@ -354,14 +368,14 @@
     {
       outerror(OUTERROR_TYPE_WARN_LOUD, "Cant Access State File '%s': %s",
                gdata.statefile, strerror(errno));
-      return;
+      return ++save;
     }
   
   if ((fstat(fd, &st) < 0) || (st.st_size < ((off_t)(sizeof(ir_uint32) * 2) + (off_t)(sizeof(MD5Digest)))))
     {
       ioutput(OUT_S|OUT_L|OUT_D, COLOR_NO_COLOR, "State File: Too small, Skipping");
       close(fd);
-      return;
+      return ++save;
     }
   
   buffer_len = st.st_size;
@@ -466,6 +480,7 @@
                 {
                   char *statefile_tmp;
                   char *statefile_date;
+                  ++save;
                   statefile_date = mycalloc(maxtextlengthshort);
                   getdatestr(statefile_date, 0, maxtextlengthshort);
                   statefile_tmp = mystrjoin(gdata.statefile, statefile_date, '.');
@@ -817,7 +832,7 @@
   
   mydelete(buffer_begin);
   
-  return;
+  return save;
 }
 
 
Index: src/iroffer_transfer.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_transfer.c,v
retrieving revision 1.95
retrieving revision 1.96
diff -u -r1.95 -r1.96
--- src/iroffer_transfer.c	7 Feb 2011 20:00:50 -0000	1.95
+++ src/iroffer_transfer.c	14 May 2011 06:18:31 -0000	1.96
@@ -858,8 +858,7 @@
              }
          }
        
-       queue_punishslowusers(&gdata.mainqueue, t->net, t->nick);
-       queue_punishslowusers(&gdata.idlequeue, t->net, t->nick);
+       queue_punish_abuse("You are being punished for your slowness", t->net, t->nick);
        
        hostmask = to_hostmask( "*", t->hostname);
        ignore = get_ignore(hostmask);
Index: src/iroffer_upload.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_upload.c,v
retrieving revision 1.48
retrieving revision 1.49
diff -u -r1.48 -r1.49
--- src/iroffer_upload.c	7 Feb 2011 20:00:50 -0000	1.48
+++ src/iroffer_upload.c	8 Apr 2011 18:58:00 -0000	1.49
@@ -51,7 +51,7 @@
   if (retval == 2)
     {
       tempstr = getsendname(l->file);
-      privmsg_fast(l->nick, "\1DCC RESUME %s %d %" LLPRINTFMT "d\1",
+      privmsg_fast(l->nick, IRC_CTCP "DCC RESUME %s %d %" LLPRINTFMT "d" IRC_CTCP,
                    tempstr, l->con.remoteport, s.st_size);
       mydelete(tempstr);
       return;
Index: src/iroffer_utilities.c
===================================================================
RCS file: /usr/home/public/iroffer/src/iroffer_utilities.c,v
retrieving revision 1.276
retrieving revision 1.290
diff -u -r1.276 -r1.290
--- src/iroffer_utilities.c	10 Feb 2011 18:28:10 -0000	1.276
+++ src/iroffer_utilities.c	1 Jul 2011 09:52:28 -0000	1.290
@@ -86,7 +86,7 @@
    len = vsnprintf(tempstr, maxtextlength, format, args);
    va_end(args);
    
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       snprintf(tempstr, maxtextlength, "OUTERROR-INT: Output too large, ignoring!");
     }
@@ -185,7 +185,7 @@
   len = vsnprintf(tempstr, maxtextlength, format, args);
   va_end(args);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN_LOUD | OUTERROR_TYPE_NOLOG,
                "MYLOG-INT: Output too large, ignoring!");
@@ -247,7 +247,7 @@
      {
        snprintf(tempstr, maxtextlength, "IOUTPUT-INT: Output too large, ignoring!");
      }
-   if (len >= maxtextlength)
+   if (len >= (int)maxtextlength)
      {
        tempstr[maxtextlength-1] = 0;
      }
@@ -338,7 +338,7 @@
   
   len = vsnprintf(tempstr,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"PRVMSG-SLOW: Output too large, ignoring!");
       return;
@@ -360,7 +360,7 @@
   
   len = vsnprintf(tempstr,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"PRVMSG-FAST: Output too large, ignoring!");
       return;
@@ -386,7 +386,7 @@
   
   len = vsnprintf(tempstr,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"PRVMSG: Output too large, ignoring!");
       return;
@@ -420,7 +420,7 @@
   
   len = vsnprintf(tempstr,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"NOTICE-SLOW: Output too large, ignoring!");
       return;
@@ -442,7 +442,7 @@
   
   len = vsnprintf(tempstr,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"NOTICE-FAST: Output too large, ignoring!");
       return;
@@ -476,7 +476,7 @@
   
   len = vsnprintf(tempstr,maxtextlength,format,ap);
   
-  if ((len < 0) || (len >= maxtextlength))
+  if ((len < 0) || (len >= (int)maxtextlength))
     {
       outerror(OUTERROR_TYPE_WARN,"NOTICE: Output too large, ignoring!");
       return;
@@ -485,9 +485,9 @@
   writeserver_notice(WRITESERVER_NORMAL, nick, tempstr, len);
 }
 
-int sstrlen (const char *p) {
-   if (!p) return -1;
-   return ((int)(strlen(p)));
+size_t sstrlen (const char *p) {
+   if (!p) return 0;
+   return (strlen(p));
    }
 
 
@@ -511,11 +511,14 @@
   meminfo_t *newmeminfo;
   unsigned int cc;
   unsigned int dd;
+  unsigned int meminfo_depth_grow;
   size_t len;
-  int i;
-  int start;
+  unsigned long i;
+  unsigned long start;
 
-  len = MEMINFOHASHSIZE * sizeof(meminfo_t) * (gdata.meminfo_depth+grow);
+  meminfo_depth_grow = gdata.meminfo_depth;
+  meminfo_depth_grow += grow;
+  len = MEMINFOHASHSIZE * sizeof(meminfo_t) * (meminfo_depth_grow);
   newmeminfo = calloc(len,1);
   
   /* replace zero entry */
@@ -548,11 +551,11 @@
           if (gdata.meminfo[(cc*(gdata.meminfo_depth)) + dd].ptr)
             {
               /* find new location */
-              start = mycalloc_hash(gdata.meminfo[(cc*(gdata.meminfo_depth)) + dd].ptr) * (gdata.meminfo_depth+grow);
+              start = mycalloc_hash(gdata.meminfo[(cc*(gdata.meminfo_depth)) + dd].ptr) * (meminfo_depth_grow);
               
-              for (i=0; newmeminfo[(i+start)%(MEMINFOHASHSIZE * (gdata.meminfo_depth+grow))].ptr; i++) ;
+              for (i=0; newmeminfo[(i+start)%(MEMINFOHASHSIZE * (meminfo_depth_grow))].ptr; i++) ;
               
-              i = (i+start)%(MEMINFOHASHSIZE * (gdata.meminfo_depth+grow));
+              i = (i+start)%(MEMINFOHASHSIZE * (meminfo_depth_grow));
               
               newmeminfo[i] = gdata.meminfo[(cc*(gdata.meminfo_depth)) + dd];
             }
@@ -566,7 +569,7 @@
     }
   
   gdata.meminfo = newmeminfo;
-  gdata.meminfo_depth += grow;
+  gdata.meminfo_depth = meminfo_depth_grow;
   
   if (gdata.debug > 0)
     {
@@ -595,7 +598,7 @@
    
    if (gdata.meminfo_count >= ((MEMINFOHASHSIZE * gdata.meminfo_depth) / 2))
      {
-       meminfo_grow((int)(gdata.meminfo_depth/3 + 1));
+       meminfo_grow((int)(gdata.meminfo_depth + 1));
      }
    
    start = mycalloc_hash(t) * gdata.meminfo_depth;
@@ -618,7 +621,7 @@
 
 void mydelete2(void *t) {
    unsigned char *ut = (unsigned char *)t;
-   unsigned int i;
+   unsigned long i;
    unsigned long start;
    
    updatecontext();
@@ -652,10 +655,14 @@
       gdata.meminfo_count--;
       }
    
+   /* we are crashing, do not shrink meminfo */
+   if (gdata.crashing)
+     return;
+   
    if ((gdata.meminfo_depth > 1) &&
        (gdata.meminfo_count < ((MEMINFOHASHSIZE * gdata.meminfo_depth) / 8)))
      {
-       meminfo_grow(-1);
+       meminfo_grow(-((int)((gdata.meminfo_depth+1)/2)));
      }
    
    return;
@@ -702,6 +709,8 @@
   for (i=0; i<MAXCONTEXTS; i++)
     {
       c = &gdata.context_log[(gdata.context_cur_ptr + 1 + i) % MAXCONTEXTS];
+      if (c->file == NULL)
+        continue;
       
       ioutput(OUT_S|OUT_L, COLOR_NO_COLOR,
               "Trace %3i  %-20s %-16s:%5i  %lu.%06lu",
@@ -770,23 +779,10 @@
 
 #define gdata_irlist_iter_end } }
 
-#define gdata_iter_as_print_number(format) \
-    dump_line("  : " format, iter);
-
-#define gdata_iter_as_print_number_cast(format,type) \
-    dump_line("  : " format, (type) iter);
-
 #define gdata_iter_as_print_string \
     dump_line("  : %s", gdata_string(iter));
 
 
-#define gdata_iter_as_print_int(name)   gdata_iter_as_print_number("%d", name)
-#define gdata_iter_as_print_uint(name)  gdata_iter_as_print_number("%u", name)
-#define gdata_iter_as_print_long(name)  gdata_iter_as_print_number("%ld", name)
-#define gdata_iter_as_print_ulong(name) gdata_iter_as_print_number("%lu", name)
-#define gdata_iter_as_print_float(name) gdata_iter_as_print_number("%.5f", name)
-
-
 #define gdata_iter_print_number(format,name) \
     dump_line("  " #name ": " format, iter-> name);
 
@@ -1135,6 +1131,7 @@
           "  : has_md5=%d md5sum=" MD5_PRINT_FMT,
           iter->has_md5sum, MD5_PRINT_DATA(iter->md5sum));
   dump_line("  : crc32=" CRC32_PRINT_FMT, iter->crc32);
+  gdata_iter_print_uint(announce);
   gdata_iter_print_string(group);
   gdata_iter_print_string(group_desc);
   gdata_iter_print_string(lock);
@@ -1711,10 +1708,10 @@
 #define IRLIST_EXT_TO_INT_CONST(p) ((const irlist_item_t *)p - 1)
 
 #ifndef WITHOUT_MEMSAVE
-void* irlist_add2(irlist_t *list, unsigned int size,
+void* irlist_add2(irlist_t *list, size_t size,
                   const char *src_function, const char *src_file, unsigned int src_line)
 #else /* WITHOUT_MEMSAVE */
-void* irlist_add(irlist_t *list, unsigned int size)
+void* irlist_add(irlist_t *list, size_t size)
 #endif /* WITHOUT_MEMSAVE */
 {
   irlist_item_t *iitem;
@@ -1744,10 +1741,15 @@
   if (!list->size)
     {
       assert(!list->head);
+      assert(!list->tail);
+      
+      list->tail = iitem;
     }
   else
     {
       assert(list->head);
+      assert(list->tail);
+      assert(!list->tail->next);
     }
   
   iitem->next = list->head;
@@ -1758,20 +1760,6 @@
   return;
 }
 
-static void *irlist_loop_tail(const irlist_t *list)
-{
-  irlist_item_t *tail;
-  irlist_item_t *test;
-
-  tail = NULL;
-  test = list->head;
-  while (test != NULL) {
-    tail = test;
-    test = tail->next;
-  }
-  return tail;
-}
-
 static void *irlist_loop_match(const irlist_t *list, irlist_item_t *match) 
 {
   irlist_item_t *tail;
@@ -1791,28 +1779,29 @@
 void irlist_insert_tail(irlist_t *list, void *item)
 {
   irlist_item_t *iitem = IRLIST_EXT_TO_INT(item);
-  irlist_item_t *tail;
   
   updatecontext();
   
+  assert(iitem);
   assert(!iitem->next);
   
   if (!list->size)
     {
       assert(!list->head);
+      assert(!list->tail);
       
       list->head = iitem;
     }
   else
     {
       assert(list->head);
-      tail = irlist_loop_tail(list);
-      assert(tail);
-      assert(!tail->next);
-      tail->next = iitem;
+      assert(list->tail);
+      assert(!list->tail->next);
+      list->tail->next = iitem;
     }
   
   iitem->next = NULL;
+  list->tail = iitem;
   
   list->size++;
   
@@ -1833,6 +1822,11 @@
     {
       iitem->next = iafter->next;
     }
+  else
+    {
+      assert(list->tail == iafter);
+      list->tail = iitem;
+    }
   
   iafter->next = iitem;
   
@@ -1867,19 +1861,30 @@
   
   assert(list->size > 0);
   assert(list->head);
+  assert(list->tail);
   
   next = iitem->next;
   
   if (list->head == iitem)
     {
-      list->head = iitem->next;
+      list->head = next;
+      if (list->tail == iitem)
+        {
+          assert(!next);
+          list->tail = NULL;
+        }
     }
   else
     {
       tail = irlist_loop_match(list, iitem);
       assert(tail);
       assert(tail->next == iitem);
-      tail->next = iitem->next;
+      tail->next = next;
+      if (list->tail == iitem)
+        {
+          assert(!next);
+          list->tail = tail;
+        }
     }
   
   iitem->next = NULL;
@@ -1908,6 +1913,7 @@
   
   assert(list->size == 0);
   assert(!list->head);
+  assert(!list->tail);
   
   return;
 }
@@ -1920,30 +1926,31 @@
   if (list->head)
     {
       assert(list->size > 0);
+      assert(list->tail);
       return IRLIST_INT_TO_EXT(list->head);
     }
   else
     {
       assert(list->size == 0);
+      assert(!list->tail);
       return NULL;
     }
 }
 
 void* irlist_get_tail(const irlist_t *list)
 {
-  irlist_item_t *tail;
-  
   updatecontext();
   
-  if (list->head)
+  if (list->tail)
     {
       assert(list->size > 0);
-      tail = irlist_loop_tail(list);
-      return IRLIST_INT_TO_EXT(tail);
+      assert(list->head);
+      return IRLIST_INT_TO_EXT(list->tail);
     }
   else
     {
       assert(list->size == 0);
+      assert(!list->head);
       return NULL;
     }
 }
@@ -2107,7 +2114,7 @@
       if (gdata.tcprangestart)
         {
           port = gdata.tcprangestart + retry;
-          if ((int)port > gdata.tcprangelimit)
+          if ((unsigned int)port > gdata.tcprangelimit)
             {
               /* give up */
               retry = max;
